---
title: "Preprocessing and analysis of the domains of human TF isoforms"
author: "Sviatoslav Sidorov"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/rstudio/tf-isoforms-publication") # replace with your path
knitr::opts_chunk$set(echo = TRUE)
stringsAsFactors = F
#library(tidyverse)
library(forcats)
library(ggplot2)
library(dplyr)
library(stringr)
library(scales)
library(kableExtra)
library(biomaRt)
#library(seqinr)
library(yaml)
library(data.tree)
#library(XLConnect)
#library(msa)
```

## Retrieve and count all human TFs from the HumanTFs database

First, retrieve all transcription factors from the [Human Transcription Factors](http://humantfs.ccbr.utoronto.ca/index.php) database ([Lambert et al., 2018](https://www.sciencedirect.com/science/article/pii/S0092867418301065?via%3Dihub)):

```{r, include=T}
humantfs = as_tibble(read.csv(file = "input_data/humantfs1.01/DatabaseExtract_v_1.01.csv", header = T, row.names = 1))
```

Rename families: "CxxC" into "CxxC ZF" and "CxxC; AT hook" into "CxxC ZF; AT hook" - to unify them with the "CxxC ZF; MBD" family.

```{r, include=T}
humantfs = humantfs %>%
  mutate(DBD = ifelse(DBD == "CxxC", "CxxC ZF", as.character(DBD))) %>%
  mutate(DBD = ifelse(DBD == "CxxC; AT hook", "CxxC ZF; AT hook", as.character(DBD)))
```

Overall, Lambert et al. consider `r nrow(humantfs)` proteins, of which `r nrow(humantfs %>% filter(Is.TF. == "Yes"))` they classify as transcription factors. `r nrow(humantfs %>% filter(Is.TF. == "Yes" & DBD != "Unknown"))` of the transcription factors have a known DBD.

Let's consider all `r nrow(humantfs %>% filter(Is.TF. == "Yes"))` transcription factors. Here is a snippet of the HumanTFs table:

```{r, include=T}
tfs = humantfs %>% 
  filter(Is.TF. == "Yes")

kable(tfs[1:6,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

This table contains `r nrow(humantfs %>% filter(Is.TF. == "Yes"))` human TFs. 

```{r, include=T}
humantfs_dbd_ids = c()

for (record in (tfs %>% dplyr::select(Interpro.ID.s.))) {
  humantfs_dbd_ids = c(humantfs_dbd_ids, unlist(str_split(record, ";")))
}

humantfs_dbd_ids = unique(humantfs_dbd_ids[humantfs_dbd_ids != "" &
                                           humantfs_dbd_ids != "None"])
```

The "Interpro.ID.s." column of this table contains InterPro IDs of various domains in these TFs ([HumanTFs README](http://humantfs.ccbr.utoronto.ca/download/v_1.01/Readme_TFs_v_1.01.txt) erroniously claims that this column contains IDs of DBDs only, but from the comparison of these IDs to the domain IDs from HumanTFs web pages for individual TFs it is evident that this column contains not only DBD IDs). These IDs total to `r length(humantfs_dbd_ids)`.

Plot the TF abundance:

```{r, include=T, fig.width=15, fig.height=10}
tfs %>%
  dplyr::count(DBD) %>%
  mutate(DBD = fct_reorder(DBD, dplyr::desc(n))) %>%
  ggplot(aes(x = DBD, y = n)) +
    geom_col(fill = "red") +
    scale_y_continuous(breaks = seq(0, 800, 100)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 14),
          axis.text.y = element_text(size = 14)) +
    theme(axis.title = element_text(size = 16))
```

Only top 10 families:

```{r, include=T}
tfs %>%
  dplyr::count(DBD) %>%
  mutate(DBD = fct_reorder(DBD, dplyr::desc(n))) %>%
  arrange(dplyr::desc(n)) %>%
  head(10) %>%
  ggplot(aes(x = DBD, y = n)) +
    geom_col(fill = "red") +
    scale_y_continuous(breaks = seq(0, 800, 100)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 14),
          axis.text.y = element_text(size = 14)) +
    theme(axis.title = element_text(size = 16))
```

The five most abundant TF families are C2H2 ZF (`r nrow(tfs %>% filter(DBD == "C2H2 ZF"))`), Homeodomain (`r nrow(tfs %>% filter(DBD == "Homeodomain"))`), bHLH (`r nrow(tfs %>% filter(DBD == "bHLH"))`), TFs with unknown DBD (`r nrow(tfs %>% filter(DBD == "Unknown"))`), and bZIP (`r nrow(tfs %>% filter(DBD == "bZIP"))`), which corresponds very well to the histograms shown in [Lambert et al., 2018](https://www.sciencedirect.com/science/article/pii/S0092867418301065?via%3Dihub), Fig. 1B.

# Investigate InterPro entries from HumanTFs

Read in all records from the InterPro database v77.0 (14/11/2019):

```{r, include=T}
interpro_entries = read.delim("input_data/interpro77.0/entry.list")
```

Some InterPro entries used in HumanTFs were removed from InterPro v77 which is used in this analysis:

```{r, include=T}
humantfs_dbd_ids[!humantfs_dbd_ids %in% (interpro_entries %>% pull(ENTRY_AC))]
```

According to the InterPro help desk, signatures from the removed InterPro entries are removed themselves or integrated into other InterPro accessions. So, let us edit the list of DBD InterPro accessions according to the information from the helpdesk:

```{r, include=T}
# Drop the accessions that were removed from the database without re-assignment
humantfs_dbd_ids = humantfs_dbd_ids[!humantfs_dbd_ids %in% c("IPR016608", "IPR003068", "IPR029780")]

# Replace the other invalid InterPro accessions with the ones where individual signatures were re-integrated
humantfs_dbd_ids = humantfs_dbd_ids[!humantfs_dbd_ids %in% c("IPR007087", "IPR013110", "IPR020478", "IPR021129",
                                                             "IPR013999", "IPR015880", "IPR013069", "IPR013723",
                                                             "IPR004022", "IPR018500", "IPR003606", "IPR008946",
                                                             "IPR011510", "IPR011038", "IPR006055")]

humantfs_dbd_ids = c(humantfs_dbd_ids, "IPR013087", "IPR025789", "IPR017956", "IPR001660",
                                       "IPR014012", "IPR013087", "IPR041661", "IPR000210",
                                       "IPR003652", "IPR018501", "IPR018501", "IPR007728",
                                       "IPR035500", "IPR001660", "IPR012674", "IPR013520")

# Take unique entries, in case some of the added ones were already present
humantfs_dbd_ids = unique(humantfs_dbd_ids)

write.table(humantfs_dbd_ids,
            file = "results/domains/humantfs_dbd_ids.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Now, the list of InterPro entries from HumanTFs contains `r length(humantfs_dbd_ids)` elements.

All currently valid InterPro entries from HumanTFs are shown below:

```{r, include=T}
dbd_ipr_humantfs = interpro_entries %>%
  filter(ENTRY_AC %in% humantfs_dbd_ids)

write.table(dbd_ipr_humantfs,
            file = "results/domains/dbd_ipr_humantfs.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

kable(dbd_ipr_humantfs) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

# Investigate transcription factors from HumanTFs in Ensembl 99

Parse the whole human Ensembl 99 annotation:

```{r, include=T}
# ensembl = useEnsembl(biomart = "ensembl",
#                      dataset = "hsapiens_gene_ensembl",
#                      version = "99")
#
# ensg_enst_ensp = getBM(attributes = c("ensembl_gene_id", "ensembl_transcript_id", "ensembl_peptide_id"),
#                        filters = "transcript_biotype",
#                        values = "protein_coding",
#                        mart = ensembl)
#
# write.table(ensg_enst_ensp, file = "data/ensembl99/ensg_enst_ensp_99.tsv", quote = F, sep = "\t", row.names = F)
#
# write.table(ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID), file = "data/ensembl99/ensg_enst_ensp_99_tfs.tsv", quote = F, sep = "\t", row.names = F)

ensg_enst_ensp = read.delim("input_data/ensembl99/ensg_enst_ensp_99.tsv")
```

The annotation contains `r ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_gene_id) %>% unique() %>% length()` TF genes from the HumanTFs database and `r ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_transcript_id) %>% unique() %>% length()` coding TF transcripts. So `r tfs %>% pull(Ensembl.ID) %>% unique() %>% length() - ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_gene_id) %>% unique() %>% length()` TFs from HumanTFs do not have coding transcripts in Ensembl 99:

```{r, include=T}
kable(tfs[!tfs$Ensembl.ID %in% (ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_gene_id) %>% unique()), "Ensembl.ID"]) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

`DUX1_HUMAN` and `DUX3_HUMAN` are UniProt accessions that do not have any corresponding genes in Ensebml v99, while the other three genes are

```{r, include=T}
# gene_biotype_table = getBM(attributes = "gene_biotype", 
#                            filters = "ensembl_gene_id", 
#                            values = c("ENSG00000249459", "ENSG00000214189", "ENSG00000228623"), 
#                            mart = ensembl)

# write.table(gene_biotype_table, 
#             file = "input_data/ensembl99/gene_biotype_table_99.tsv", 
#             quote = F, sep = "\t", row.names = F)

gene_biotype_table = read.delim("input_data/ensembl99/gene_biotype_table_99.tsv")

kable(gene_biotype_table) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

and so they are filtered out either.

# Investigate domain matches in TF protein products from Ensembl 99

The following table contains all domain matches with InterPro entry IDs in TF protein products annotated in Ensembl 99. The matches were obtained using InterProScan v5.39-77.0:

```{r, include=T}
ips_domains_ipr_ens99 = read.delim(file = "input_data/interpro77.0/protein_fasta_tfs_99.fa.tsv", 
                                   header = F, 
                                   row.names = NULL, 
                                   col.names = c("protein_accession", "seq_md5", "seq_len", 
                                                 "db", "domain_accession", "domain_description",
                                                 "start", "stop", "evalue",
                                                 "status", "run_date", "ipr_accession",
                                                 "ipr_description", "go_terms", "pathways")) %>%
  as_tibble() %>%
  filter(!is.na(ipr_accession) & (ipr_accession != "")) %>%
  mutate(protein_accession = str_extract(protein_accession, "[A-Z0-9]+")) %>%
  left_join(ensg_enst_ensp, by = c("protein_accession" = "ensembl_peptide_id"))
```

Here we do not filter matches by e-value, because:

- e-values of signatures from different databases are not comparable;

- some databases can use criteria other than e-value to report matches (see InterProScan developer's comment: https://github.com/ebi-pf-team/interproscan/issues/9).

We consider a match valid if its signature has an InterPro accession ID.

The table contains `r nrow(ips_domains_ipr_ens99)` records for `r ips_domains_ipr_ens99 %>% pull(ensembl_transcript_id) %>% unique() %>% length()` transcripts from `r ips_domains_ipr_ens99 %>% pull(ensembl_gene_id) %>% unique() %>% length()` genes. So, `r ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_transcript_id) %>% unique() %>% length() - ips_domains_ipr_ens99 %>% pull(ensembl_transcript_id) %>% unique() %>% length()` transcripts and `r ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_gene_id) %>% unique() %>% length() - ips_domains_ipr_ens99 %>% pull(ensembl_gene_id) %>% unique() %>% length()` genes do not have any matches. The two genes are:

```{r, include=T}
genes_overall = ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_gene_id) %>% unique()

genes_with_matches = ips_domains_ipr_ens99 %>% pull(ensembl_gene_id) %>% unique()

kable(tfs %>% filter(Ensembl.ID %in% genes_overall[!genes_overall %in% genes_with_matches]) %>% dplyr::select(Ensembl.ID, HGNC.symbol)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

According to HumanTFs, NFE4 does not posses a DBD and is included in the Unknown family. It has no evidence from previous annotations of being a TF. ZNF365 is included in the C2H2 ZF family and has some evidence of being a TF from previous annotations, but its isoforms do not show a C2H2 ZF domain. Overall, these two proteins indeed do not have strong evidence of being TFs, and so we exclude them from the analysis.

The bar-chart below shows the numbers of matches with coordinates from different databases (one InterPro entry can correspond to signatures from several databases):

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99 %>%
  dplyr::select(db) %>%
  ggplot(aes(x = db)) +
    geom_bar(aes(fill = db)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 30000)) +
    theme_classic() +
    theme(legend.position = "none")

ips_domains_ipr_ens99_iprs = ips_domains_ipr_ens99 %>% pull(ipr_accession) %>% unique()
```

Overall, there are `r nrow(ips_domains_ipr_ens99)` signatures from `r ips_domains_ipr_ens99 %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` matches (InterPro entries). In the scanning results, we have `r length(ips_domains_ipr_ens99_iprs)` different InterPro entries, `r length(ips_domains_ipr_ens99_iprs[ips_domains_ipr_ens99_iprs %in% humantfs_dbd_ids])` of which are present in HumanTFs (and consequently, `r length(ips_domains_ipr_ens99_iprs) - length(ips_domains_ipr_ens99_iprs[ips_domains_ipr_ens99_iprs %in% humantfs_dbd_ids])` of all different InterPro entries are not present there). Hence, `r length(humantfs_dbd_ids) - length(ips_domains_ipr_ens99_iprs[ips_domains_ipr_ens99_iprs %in% humantfs_dbd_ids])` InterPro entries from HumanTFs were not found in the scanning process:

```{r, include=T}
kable(dbd_ipr_humantfs[!dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_iprs,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")

write.table(ips_domains_ipr_ens99_iprs,
            file = "results/domains/ips_domains_ipr_ens99_iprs.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

write.table(ips_domains_ipr_ens99,
            file = "results/domains/ips_domains_ipr_ens99.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

write.table(tfs,
            file = "results/domains/tfs.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

write.table(humantfs_dbd_ids,
            file = "results/domains/humantfs_dbd_ids.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

# Prepare for the filtering of matches in TF protein products from Ensembl 99

InterPro has entries of 5 different types (information on each type is taken from [InterPro entry types](https://www.ebi.ac.uk/training/online/course/interpro-functional-and-structural-analysis-protei/what-interpro-entry/interpro-entry-types)):

* __Homologous Superfamily__ usually include proteins with a certain tertiary structure. Homologous Superfamilies are always composed of CATH-Gene3D and/or SUPERFAMILY signatures. Homologous Superfamily entries do not form hierarchies.

* __Protein Family__ contains proteins with a common ancestor. Families are organized in hierarchies.

* __Domain__ is a separable structural or functional part of a protein. They can form hierarchies.

* __Site__ is a small locus in a protein (typically, only several residues long) that may affect the protein's function. Sites do not form hierarchies. InterPro includes the following types of Sites:

    - __active sites__ contain residues with catalytic activity;

    - __binding sites__ contain residues that bind molecules or ions;
  
    - __post-translation modification (PTM) sites__ contain residues that can be chemically modified after translation;
  
    - __conserved sites__ are loci of an unknown function that are found in certain types of proteins.

* __Repeat__ is a short sequence repeated in a protein. It may facilitate binding or other characteristics. Repeats do not form hierarchies.

"Hierarchical relationships are identified between evolutionarily related InterPro entries, tracing those that represent smaller, functionally specific subfamilies of larger families, or subclasses of broader classes of domain" [Mitchell et al., 2018](https://academic.oup.com/nar/article/47/D1/D351/5162469).

Hence, we will need to hierarchically filter InterPro entries, prioritizing domains.

The numbers of matches (InterPro entries) of different types in TF protein isoforms:

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99 %>%
  left_join(interpro_entries, by = c("ipr_accession" = "ENTRY_AC")) %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession, ENTRY_TYPE) %>%
  distinct() %>%
  ungroup() %>%
  ggplot(aes(x = ENTRY_TYPE)) +
    geom_bar(aes(fill = ENTRY_TYPE)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 11000)) +
    theme_classic() + 
    theme(legend.position = "none")
```

Overall, there are `r ips_domains_ipr_ens99 %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` matches (InterPro entries) in TF protein isoforms. The most part of the entries are of the Domain and Homologous Superfamily types.

Furthermore, several signatures can colocalize in one InterPro entry. The plot below shows all signature combinations contained in matches:

```{r, include=T, fig.width=10}
db_intersections = as.data.frame(table(unlist(group_map(ips_domains_ipr_ens99 %>%
                                                group_by(ensembl_transcript_id, ipr_accession) %>%
                                                arrange(db),
                                              ~ paste(unique(.x %>% pull(db)), collapse = "_")))))
db_intersections %>%
  mutate(database_combination = Var1) %>%
  mutate(count = Freq) %>%
  arrange(dplyr::desc(count)) %>%
  mutate(database_combination = factor(database_combination, levels = database_combination)) %>%
  ggplot(aes(x = database_combination, y = count)) +
    geom_col(fill = "red") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

Hence, in general, for each InterPro entry we will need to select one signature out of several.

# Filter matches in TF protein products from Ensembl 99

## Calculate integrated coordinates

First, for each InterPro entry from the scanning results, calculate its integrated coordinates:

```{r, include=T}
ips_domains_ipr_ens99_int_raw = ips_domains_ipr_ens99 %>%
  group_by(ensembl_transcript_id, ipr_accession) %>%
  mutate(int_start = min(start)) %>%
  mutate(int_stop = max(stop)) %>%
  ungroup()
```

Next, obtain the lists of databases whose signatures comprise different types of InterPro entries:

Active sites:

```{r, include=T}
ips_domains_ipr_ens99 %>%
  mutate(ipr_accession = as.character(ipr_accession)) %>%
  left_join(interpro_entries %>% mutate(ENTRY_AC = as.character(ENTRY_AC)), by = c("ipr_accession" = "ENTRY_AC")) %>%
  mutate(db = as.character(db)) %>%
  filter(ENTRY_TYPE == "Active_site") %>%
  pull(db) %>%
  unique()
```

Binding sites:

```{r, include=T}
ips_domains_ipr_ens99 %>%
  mutate(ipr_accession = as.character(ipr_accession)) %>%
  left_join(interpro_entries %>% mutate(ENTRY_AC = as.character(ENTRY_AC)), by = c("ipr_accession" = "ENTRY_AC")) %>%
  mutate(db = as.character(db)) %>%
  filter(ENTRY_TYPE == "Binding_site") %>%
  pull(db) %>%
  unique()
```

Conserved sites:

```{r, include=T}
ips_domains_ipr_ens99 %>%
  mutate(ipr_accession = as.character(ipr_accession)) %>%
  left_join(interpro_entries %>% mutate(ENTRY_AC = as.character(ENTRY_AC)), by = c("ipr_accession" = "ENTRY_AC")) %>%
  mutate(db = as.character(db)) %>%
  filter(ENTRY_TYPE == "Conserved_site") %>%
  pull(db) %>%
  unique()
```

Domains:

```{r, include=T}
ips_domains_ipr_ens99 %>%
  mutate(ipr_accession = as.character(ipr_accession)) %>%
  left_join(interpro_entries %>% mutate(ENTRY_AC = as.character(ENTRY_AC)), by = c("ipr_accession" = "ENTRY_AC")) %>%
  mutate(db = as.character(db)) %>%
  filter(ENTRY_TYPE == "Domain") %>%
  pull(db) %>%
  unique()
```

Families:

```{r, include=T}
ips_domains_ipr_ens99 %>%
  mutate(ipr_accession = as.character(ipr_accession)) %>%
  left_join(interpro_entries %>% mutate(ENTRY_AC = as.character(ENTRY_AC)), by = c("ipr_accession" = "ENTRY_AC")) %>%
  mutate(db = as.character(db)) %>%
  filter(ENTRY_TYPE == "Family") %>%
  pull(db) %>%
  unique()
```

Homologous Superfamilies:

```{r, include=T}
ips_domains_ipr_ens99 %>%
  mutate(ipr_accession = as.character(ipr_accession)) %>%
  left_join(interpro_entries %>% mutate(ENTRY_AC = as.character(ENTRY_AC)), by = c("ipr_accession" = "ENTRY_AC")) %>%
  mutate(db = as.character(db)) %>%
  filter(ENTRY_TYPE == "Homologous_superfamily") %>%
  pull(db) %>%
  unique()
```

Repeats:

```{r, include=T}
ips_domains_ipr_ens99 %>%
  mutate(ipr_accession = as.character(ipr_accession)) %>%
  left_join(interpro_entries %>% mutate(ENTRY_AC = as.character(ENTRY_AC)), by = c("ipr_accession" = "ENTRY_AC")) %>%
  mutate(db = as.character(db)) %>%
  filter(ENTRY_TYPE == "Repeat") %>%
  pull(db) %>%
  unique()
```

As we saw above, some InterPro entries of the type Family have not only PIRSF or PANTHER signatures (which usually span the whole protein) but also domain-type signatures (Pfam, SMART, ProSiteProfiles, CDD, TIGRFAM, Hamap). 

I consider Hamap signatures to be domains, because, although Hamap is a database of protein families, it has detailed annotation rules for each family which include possible presence of certain domains ([Pedruzzi et al., 2015](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4383873/)); so, Hamap matches might designate domains as well. 

Consequently, it is better to re-calculate the integrated coordinates of such Family entries excluding PIRSF and PANTHER signatures, so the new integrated coordinates reflect actual domains:

```{r, include=T}
calc_new_int_coords = function(start, stop, int_start, int_stop, db) {
  all_matches = data.frame(start = start,
                           stop = stop,
                           db = as.character(db))
  
  domain_matches = all_matches %>%
    filter((db != "PIRSF") & (db != "PANTHER"))
  
  domain_matches_n = domain_matches %>%
     nrow()
  
  if (domain_matches_n == 0) {
    return(paste0(as.character(int_start), "_", as.character(int_stop)))
  }
  
  new_int_start = min(domain_matches$start)
  
  new_int_stop = max(domain_matches$stop)
  
  return(paste0(as.character(new_int_start), "_", as.character(new_int_stop)))
}

ips_domains_ipr_ens99_int_fam = ips_domains_ipr_ens99_int_raw %>%
  left_join(interpro_entries, by = c("ipr_accession" = "ENTRY_AC")) %>%
  filter(ENTRY_TYPE == "Family") %>%
  group_by(ensembl_transcript_id, ipr_accession) %>%
  do(mutate(., new_int_coords = calc_new_int_coords(.$start, .$stop, .$int_start[1], .$int_stop[1], .$db))) %>%
  do(mutate(., int_start = as.numeric(unlist(str_split(.$new_int_coords, "_"))[1]))) %>%
  do(mutate(., int_stop = as.numeric(unlist(str_split(.$new_int_coords, "_"))[2]))) %>%
  ungroup() %>%
  dplyr::select(-c("new_int_coords", "ENTRY_NAME"))

ips_domains_ipr_ens99_int = ips_domains_ipr_ens99_int_raw %>%
  left_join(interpro_entries, by = c("ipr_accession" = "ENTRY_AC")) %>%
  dplyr::select(-ENTRY_NAME) %>%
  filter(ENTRY_TYPE != "Family") %>%
  bind_rows(ips_domains_ipr_ens99_int_fam)
```

## Find specific and general InterPro entries

In the scanning results, analyse Domain and Family entries which form hierarchies:

* Mark the most specific entries. 

* For each entry that is a part of the Domain or Family hierarchy, store the ancestral InterPro entry, if any.

```{r, include=T}
# Find ancestral InterPro entries (may take time, therefore commented out)

find_ipr_ancestor = function(ipr_hierarchy, ipr_node, ipr_accessions_unique) {
  ancestors = Traverse(ipr_node, traversal = "ancestor")
  for (ancestor in ancestors) {
    if (ancestor$name %in% ipr_accessions_unique[ipr_accessions_unique != ipr_node$name]) {
      return(ancestor$name)
    }
  }
  return("")
}

calc_domain_status = function(ipr_hierarchy, ipr_accessions) {
  ipr_accessions_unique = unique(ipr_accessions)
  domain_statuses = data.frame(ipr = ipr_accessions_unique,
                               ipr_status = rep("specific", length(ipr_accessions_unique)),
                               ipr_ancestor = rep(NA, length(ipr_accessions_unique))) %>%
    mutate(ipr = as.character(ipr)) %>%
    mutate(ipr_status = as.character(ipr_status)) %>%
    mutate(ipr_ancestor = as.character(ipr_ancestor))
  for (ipr in ipr_accessions_unique) {
    ipr_node = FindNode(ipr_hierarchy, ipr)
    if (!is.null(ipr_node)) {
      ipr_ancestor_name = find_ipr_ancestor(ipr_hierarchy, ipr_node, ipr_accessions_unique)
      if (ipr_ancestor_name != "") {
        domain_statuses[domain_statuses$ipr == ipr_ancestor_name, "ipr_status"] = "general"
        domain_statuses[domain_statuses$ipr == ipr, "ipr_ancestor"] = ipr_ancestor_name
      }
    }
  }
  return(domain_statuses)
}

# ipr_hierarchy_yaml = read_yaml(file = "analysis/ParentChildTreeFile_to_yaml/output/ParentChildTreeFile_with_status.yaml")
ipr_hierarchy_yaml = read_yaml(file = "input_data/interpro77.0/ParentChildTreeFile_with_status.yaml")
ipr_hierarchy = as.Node(ipr_hierarchy_yaml)

# Find ancestral InterPro entries (may take time, therefore commented out)

ips_domains_ipr_ens99_int = ips_domains_ipr_ens99_int %>%
  mutate(ipr_accession = as.character(ipr_accession))

ips_domains_ipr_ens99_int_specific_retained = ips_domains_ipr_ens99_int %>%
  group_by(ensembl_transcript_id) %>%
  do(left_join(., calc_domain_status(ipr_hierarchy, .$ipr_accession), by = c("ipr_accession" = "ipr")))

write.table(ips_domains_ipr_ens99_int_specific_retained,
            "analysis/filter_ipr_hierarchy/ips_domains_ipr_ens99_int_specific_retained_ipr_status_ancestors_fam.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Load the obtained table with ancestral entries
ips_domains_ipr_ens99_int_specific_retained = read.delim("analysis/filter_ipr_hierarchy/ips_domains_ipr_ens99_int_specific_retained_ipr_status_ancestors_fam.tsv")

ips_domains_ipr_ens99_int_specific_retained_iprs = ips_domains_ipr_ens99_int_specific_retained %>% 
  filter(ipr_status == "specific") %>% 
  pull(ipr_accession) %>% 
  unique()
```

Now we have `r ips_domains_ipr_ens99_int_specific_retained_iprs %>% length()` unique specific InterPro entries out of `r ips_domains_ipr_ens99_iprs %>% length()` we had after scanning (specific and general together). So, almost all matches are specific. `r length(ips_domains_ipr_ens99_int_specific_retained_iprs[ips_domains_ipr_ens99_int_specific_retained_iprs %in% humantfs_dbd_ids])` of these entries are from HumanTFs. The following `r length(ips_domains_ipr_ens99_iprs[ips_domains_ipr_ens99_iprs %in% humantfs_dbd_ids]) - length(ips_domains_ipr_ens99_int_specific_retained_iprs[ips_domains_ipr_ens99_int_specific_retained_iprs %in% humantfs_dbd_ids])` InterPro entries from HumanTFs are general:

```{r, include=T}
kable(dbd_ipr_humantfs[(dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_iprs) & (!dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained_iprs),]) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

There are now `r nrow(ips_domains_ipr_ens99_int_specific_retained)` signatures in the table overall, of which `r nrow(ips_domains_ipr_ens99_int_specific_retained %>% filter(ipr_status == "specific"))` are under specific matches, and `r nrow(ips_domains_ipr_ens99_int_specific_retained %>% filter(ipr_status == "general"))` are under general matches.

Overall, there are `r ips_domains_ipr_ens99_int_specific_retained %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` matches, of which `r ips_domains_ipr_ens99_int_specific_retained %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are specific and `r ips_domains_ipr_ens99_int_specific_retained %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are general. The number of matched transcripts is `r ips_domains_ipr_ens99_int_specific_retained %>% pull(ensembl_transcript_id) %>% unique() %>% length()`. It did not change from the previous step, which is correct.

The numbers of specific InterPro entries of different types are shown below:

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99_int_specific_retained %>%
  filter(ipr_status == "specific") %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession, ENTRY_TYPE) %>%
  distinct() %>%
  ungroup() %>%
  ggplot(aes(x = ENTRY_TYPE)) +
    geom_bar(aes(fill = ENTRY_TYPE)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 11000)) +
    theme_classic() + 
    theme(legend.position = "none")
```

Only Domain and Family bars lowered, which is correct, as only domains and families comprise hierarchies in InterPro.

## Print examples of InterPro entry matches and integrated coordinates

Prepare functions for printing InterPro entry matches in a given TF isoform:

```{r, include=T}
# Adapted from https://github.com/luslab/spacemap-peptide-analysis/blob/051ea574875cde7450f9e4b38d1efb695bb88dd2/scripts/SPACEmap_peptide_analysis_final.Rmd#L45 (GNU General Public License v3.0: https://github.com/luslab/spacemap-peptide-analysis/blob/main/LICENSE)
generate_protein_df = function(transcript_id) {
  return(ips_domains_ipr_ens99_int_specific_retained %>%
           filter(ensembl_transcript_id == transcript_id))
}

preprocess_protein_df = function(protein.df) {
  c = 10 # vertical space between InterPro entries
  h = 5  # height of a match rectangle
  d = 5  # vertical space between rectangles
  
  protein.df.singatures = protein.df %>%
    dplyr::select(seq_len,
                  domain_accession,
                  ensembl_transcript_id,
                  start,
                  stop,
                  ipr_accession)
  
  protein.df.iprs = protein.df %>%
    dplyr::select(seq_len,
                  domain_accession,
                  ensembl_transcript_id,
                  start,
                  stop,
                  ipr_accession,
                  ipr_description,
                  int_start,
                  int_stop) %>%
    mutate(start = int_start,
           stop = int_stop,
           domain_accession = paste0(ipr_accession, " (", ipr_description, ")")) %>%
    dplyr::select(seq_len,
                  domain_accession,
                  ensembl_transcript_id,
                  start,
                  stop,
                  ipr_accession) %>%
    distinct()
  
  protein.df.all = protein.df.singatures %>%
    bind_rows(protein.df.iprs) %>%
    dplyr::rename(length = seq_len,
                  db.accession = domain_accession) %>%
    arrange(desc(start), desc(stop))
  
  ipr.numbers = unique(protein.df.all$ipr_accession)
  # ipr.numbers = ipr.numbers[ipr.numbers != ""]
  ipr.numbers = c(ipr.numbers, "")
  names(ipr.numbers) = as.character(1:(length(ipr.numbers)))
  
  protein.df.result = protein.df.all %>%
    rowwise() %>%
    mutate(ipr.n = as.numeric(names(ipr.numbers[ipr.numbers == ipr_accession]))) %>%
    arrange(ipr.n) %>%
    tibble::rownames_to_column(var = "row.n") %>%
    mutate(row.n = as.numeric(row.n)) %>%
    mutate(ymin = ipr.n * c + (row.n - 1) * (h + d)) %>%
    mutate(ymax = ymin + h)
  
  return(protein.df.result)
}

# generate_ipr_df = function(protein.df) {
#   ipr.label.shift.x = -10
#   ipr.label.shift.y = 5
#   return(protein.df %>%
#            dplyr::select(ipr_accession,
#                          start,
#                          stop,
#                          ymax) %>%
#            group_by(ipr_accession) %>%
#            do(mutate(., ipr.x = (min(.$start) + max(.$stop)) / 2 + ipr.label.shift.x)) %>%
#            do(mutate(., ipr.y = max(.$ymax) + ipr.label.shift.y)) %>%
#            ungroup() %>%
#            dplyr::select(ipr_accession,
#                          ipr.x,
#                          ipr.y) %>%
#            distinct())
# }

draw_matches = function(transcript_id) {
  signature.label.shift.x = 30
  label.font.size = 3
  x.axis.extension = 100
  
  protein.df = generate_protein_df(transcript_id)
  
  protein.df = preprocess_protein_df(protein.df)
  
  #ipr.df = generate_ipr_df(protein.df)
  
  p = ggplot(protein.df) +
    # Matches
    geom_rect(mapping = aes(xmin = start,
                            xmax = stop,
                            ymin = ymin,
                            ymax = ymax,
                            fill = db.accession)) +
    # Signature IDs
    geom_text(aes(x = stop + signature.label.shift.x,
                  y = (ymin + ymax) / 2,
                  label = db.accession),
              size = label.font.size) +
    # InterPro IDs
    # geom_text(data = ipr.df,
    #           aes(x = ipr.x,
    #               y = ipr.y,
    #               label = ipr_accession),
    #           size = label.font.size) +
    # Protein C-terminal mark
    geom_vline(xintercept = unlist(protein.df[1, "length"])) + 
    # Ruler
    scale_x_continuous(n.breaks = 7, 
                       limits = c(0, unlist(protein.df[1, "length"]) + x.axis.extension)) +
    # Formatting
    theme_classic() + 
    theme(axis.line.y = element_blank(),
          axis.text.y = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.x = element_blank(),
          legend.position ="none")
  
  ggsave(paste0("data/results/", transcript_id, "_IPR_matches.pdf"),
         p)
}
```

Print out two examples of matched protein TF isoforms to illustrate InterPro entry filtering later:

```{r, include=T}
draw_matches("ENST00000336840")
draw_matches("ENST00000177694")
```

```{r, include=T}
transcript_id = "ENST00000177694"

ips_domains_ipr_ens99_int_specific_retained %>%
  filter(ensembl_transcript_id == transcript_id) %>%
  dplyr::select(ipr_accession,
                int_start,
                int_stop,
                domain_accession,
                start,
                stop,
                ENTRY_TYPE) %>%
  arrange(as.numeric(int_start), as.numeric(int_stop))
```

## Check overlaps between matches of the type Domain

Check if we have overlapping specific domain InterPro entries (overlaps are calculated from integrated coordinates):

```{r, include=T}
check_overlaps = function(int_start, int_stop) {
  overlaps = c()
  all_coords = data.frame(int_start = int_start,
                          int_stop = int_stop)
  for (i in 1:nrow(all_coords)) {
    i_start = all_coords[i, "int_start"]
    i_stop = all_coords[i, "int_stop"]
    overlap_detected = F
    for (j in 1:nrow(all_coords)) {
      if (j == i) {
        next
      }
      j_start = all_coords[j, "int_start"]
      j_stop = all_coords[j, "int_stop"]
      if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
        overlaps = c(overlaps, T)
        overlap_detected = T
        break
      }
    }
    if (!overlap_detected) {
      overlaps = c(overlaps, F)
    }
  }
  return(overlaps)
}
ips_domains_ipr_ens99_int_specific_retained_overlapping.dom = ips_domains_ipr_ens99_int_specific_retained %>%
  group_by(ensembl_transcript_id) %>%
  filter(ipr_status == "specific") %>%
  filter(ENTRY_TYPE == "Domain") %>%
  dplyr::select(ensembl_transcript_id, ipr_accession, int_start, int_stop) %>%
  distinct() %>%
  do(mutate(., overlaps = check_overlaps(.$int_start, .$int_stop))) %>%
  filter(overlaps == T) %>%
  ungroup()
tr.with.overlapping.domains.count = ips_domains_ipr_ens99_int_specific_retained_overlapping.dom %>%
  pull(ensembl_transcript_id) %>%
  unique() %>%
  length()
```

We have `r nrow(ips_domains_ipr_ens99_int_specific_retained_overlapping.dom)` overlapping specific domains (so they are not in hierarchical relationship in InterPro)! They are located in `r tr.with.overlapping.domains.count` transcripts out of the total number of transcripts (`r ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`). Let us retain them at present, as they can have different meaning. For example, 

* In NFE2L3-201 (ENST00000056233), IPR004827 and IPR004826 probably denote a more general and a more specific type of domain (bZIP and bZIP-Maf, respectively).

* In YBX2-201 (ENST00000007699), IPR002059 and IPR019844 most probably denote the whole domain (CSP_DNA-bd) and its part (CSD-1), respectively.

* In TRPS1-201 (ENST00000220888), IPR013087 denotes a C2H2-ZF array, while IPR000679 defines a Znf-GATA domain inside the array, not intersecting with C2H2 domains.

* In SMYD3-214 (ENST00000490107), IPR001214 denotes a SET domain, while IPR002893 denotes a zinc finger MYND domain embedded into a SET domain.

* In ZNF426-201 (ENST00000253115), IPR013087 denotes a C2H2 zinc finger array, while IPR003656 defines two BED domains overlapping with the C2H2 zinc fingers.

* In MYF6-201 (ENST00000228641), IPR002546 defines a "Basic" domain and slightly overlaps with IPR011598 which defines a bHLH domain.

Consequently, it is not possible to have a general rule to select a domain from a number of overlaping InterPro accessions, and so we will not filter such domain InterPro accessions at present.

## Filter all matches against Domain matches

Next, let us filter out all matches (InterPro entries) intersecting domain matches:

```{r, include=T}
outside_domains = function(int_start, int_stop, ipr_type, i, ipr_status) {
  all_matches = data.frame(int_start = int_start,
                           int_stop = int_stop,
                           ipr_type = ipr_type,
                           ipr_status = ipr_status)
  i_start = all_matches[i, "int_start"]
  i_stop = all_matches[i, "int_stop"]
  domain_matches = all_matches %>%
    filter(ipr_type == "Domain") %>%
    filter(ipr_status == "specific")
  for (j in 1:nrow(domain_matches)) {
    j_start = domain_matches[j, "int_start"]
    j_stop = domain_matches[j, "int_stop"]
    if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
      return(F)
    }
  }
  return(T)
}
calc_retained_iprs = function(int_start, int_stop, ipr_type, ipr_status) {
  retain_ipr = c()
  if (!"Domain" %in% ipr_type) {
    return(rep(T, length(int_start)))
  }
  for (i in 1:length(int_start)) {
    if (ipr_type[i] != "Domain") {
      retain_ipr = c(retain_ipr, outside_domains(int_start, int_stop, ipr_type, i, ipr_status))
    } else {
      retain_ipr = c(retain_ipr, T)
    }
  }
  return(retain_ipr)
}
ips_domains_ipr_ens99_int_specific_retained1 = ips_domains_ipr_ens99_int_specific_retained %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., retain_ipr = calc_retained_iprs(.$int_start, .$int_stop, .$ENTRY_TYPE, .$ipr_status))) %>%
  ungroup()
ips_domains_ipr_ens99_int_specific_retained1 = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(retain_ipr == T)
ips_domains_ipr_ens99_int_specific_retained1_iprs = ips_domains_ipr_ens99_int_specific_retained1 %>% 
  filter(ipr_status == "specific") %>%
  pull(ipr_accession) %>% 
  unique()
```

Now we have `r ips_domains_ipr_ens99_int_specific_retained1_iprs %>% length()` unique specific InterPro entries out of `r ips_domains_ipr_ens99_int_specific_retained_iprs %>% length()` specific ones we had on the previous step. `r length(ips_domains_ipr_ens99_int_specific_retained1_iprs[ips_domains_ipr_ens99_int_specific_retained1_iprs %in% humantfs_dbd_ids])` of the retained specific entries are from HumanTFs. Hence, we lost the following `r length(ips_domains_ipr_ens99_int_specific_retained_iprs[ips_domains_ipr_ens99_int_specific_retained_iprs %in% humantfs_dbd_ids]) - length(ips_domains_ipr_ens99_int_specific_retained1_iprs[ips_domains_ipr_ens99_int_specific_retained1_iprs %in% humantfs_dbd_ids])` InterPro entries from HumanTFs:

```{r, include=T}
kable(dbd_ipr_humantfs[(dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained_iprs) & (!dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained1_iprs),]) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

There are now `r nrow(ips_domains_ipr_ens99_int_specific_retained1)` signatures in the table overall, of which `r nrow(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ipr_status == "specific"))` are under specific matches, and `r nrow(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ipr_status == "general"))` are under general matches.

Check how many specific InterPro entries of different types we have now:

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ipr_status == "specific") %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession, ENTRY_TYPE) %>%
  distinct() %>%
  ungroup() %>%
  ggplot(aes(x = ENTRY_TYPE)) +
    geom_bar(aes(fill = ENTRY_TYPE)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 11000)) +
    theme_classic() + 
    theme(legend.position = "none")
```

Overall, we now have `r ips_domains_ipr_ens99_int_specific_retained1 %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` matches, from which `r ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are specific and `r ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are general. All non-domain types went down, which is expected. Homologous Superfamily and Family decreased dramatically.

The number of matched transcripts did not change (`r ips_domains_ipr_ens99_int_specific_retained1 %>% pull(ensembl_transcript_id) %>% unique() %>% length()`), which is correct.

As we saw above, some Family InterPro entries contain domain signatures. Let us look at them closer:

```{r, include=T}
dom_family_iprs = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ENTRY_TYPE == "Family") %>%
  group_by(ensembl_transcript_id, ipr_accession) %>%
  do(filter(., ("Pfam" %in% db) | 
               ("SMART" %in% db) | 
               ("ProSiteProfiles" %in% db) |
               ("CDD" %in% db) |
               ("TIGRFAM" %in% db))) %>%
  dplyr::select(ipr_accession) %>%
  distinct() %>%
  ungroup() %>%
  pull(ipr_accession)
dom_family_iprs_unique = dom_family_iprs %>%
  unique()
dom_family_tx_count = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ENTRY_TYPE == "Family") %>%
  filter((db == "Pfam") | 
         (db == "SMART") | 
         (db == "ProSiteProfiles") |
         (db == "CDD") |
         (db == "TIGRFAM")) %>%
  pull(ensembl_transcript_id) %>%
  unique() %>%
  length()
```

So we have `r length(dom_family_iprs_unique)` different InterPro entries (general and specific) of the type Family which have domain signatures. Overall, we have `r length(dom_family_iprs)` such InterPro entries (matches) in our scanning results (out of all `r length(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ENTRY_TYPE == "Family") %>% group_by(ensembl_transcript_id, ipr_accession) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession))` Family matches, specific and general). The number of transcripts with these Family matches is `r dom_family_tx_count`. Consequently, our next step is to filter all remaining non-domain InterPro entries against these Family entries, because, effectively, they are domains.

## Preprocess matches of the type Family that have domain signatures

First, check if these entries have domain signatures in all transcripts where they are present:

```{r, include=T}
non_dom_family_iprs = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ENTRY_TYPE == "Family") %>%
  group_by(ensembl_transcript_id, ipr_accession) %>%
  do(filter(., (!"Pfam" %in% db) & 
               (!"SMART" %in% db) & 
               (!"ProSiteProfiles" %in% db) &
               (!"CDD" %in% db) &
               (!"TIGRFAM" %in% db))) %>%
  dplyr::select(ipr_accession) %>%
  distinct() %>%
  ungroup() %>%
  pull(ipr_accession)
non_dom_family_iprs_unique = non_dom_family_iprs %>%
  unique()
dom_family_iprs_unique[dom_family_iprs_unique %in% non_dom_family_iprs_unique]
```

No, there are `r length(dom_family_iprs_unique[dom_family_iprs_unique %in% non_dom_family_iprs_unique])` Family InterPro entries which have domain signatures in some transcripts, but do not have them in some other transcripts. We need to account for this in further analysis.

Secondly, let us change the type of the Family accessions with domain signatures from "Family" to "Domain_Family." It will simplify further analysis:

```{r, include=T}
ips_domains_ipr_ens99_int_specific_retained1_domfam = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ENTRY_TYPE == "Family") %>%
  group_by(ensembl_transcript_id, ipr_accession) %>%
  do(filter(., ("Pfam" %in% db) | 
               ("SMART" %in% db) | 
               ("ProSiteProfiles" %in% db) |
               ("CDD" %in% db) |
               ("TIGRFAM" %in% db))) %>%
  do(mutate(., ENTRY_TYPE = "Domain_Family"))
ips_domains_ipr_ens99_int_specific_retained1_nondomfam = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ENTRY_TYPE == "Family") %>%
  group_by(ensembl_transcript_id, ipr_accession) %>%
  do(filter(., (!"Pfam" %in% db) & 
               (!"SMART" %in% db) & 
               (!"ProSiteProfiles" %in% db) &
               (!"CDD" %in% db) &
               (!"TIGRFAM" %in% db)))
ips_domains_ipr_ens99_int_specific_retained1_nonfam = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ENTRY_TYPE != "Family")
ips_domains_ipr_ens99_int_specific_retained1 = ips_domains_ipr_ens99_int_specific_retained1_domfam %>%
  bind_rows(ips_domains_ipr_ens99_int_specific_retained1_nondomfam) %>%
  bind_rows(ips_domains_ipr_ens99_int_specific_retained1_nonfam)
retained1_nrow_prev = nrow(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ipr_status == "specific"))
ips_domains_ipr_ens99_int_specific_retained1_iprs = ips_domains_ipr_ens99_int_specific_retained1 %>% 
  filter(ipr_status == "specific") %>%
  pull(ipr_accession) %>% 
  unique()
ips_domains_ipr_ens99_int_specific_retained1_iprs_prev = ips_domains_ipr_ens99_int_specific_retained1_iprs
```

Now we got `r nrow(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ipr_status == "specific"))` specific matches, which is correct, because it is the same as after the previous step. `r length(ips_domains_ipr_ens99_int_specific_retained1_iprs[ips_domains_ipr_ens99_int_specific_retained1_iprs %in% humantfs_dbd_ids])` of unique specific InterPro entries are from HumanTFs, which is correct because it matches the previous value. At this stage, we have `r length(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ENTRY_TYPE == "Domain_Family") %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id, ipr_accession) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession))` specific and `r length(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ENTRY_TYPE == "Domain_Family") %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id, ipr_accession) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession))` general Domain-Family entries. Overall, we have `r length(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ENTRY_TYPE == "Domain_Family") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession))` Domain-Family entries, which is correct.

Next, check if these Domain-Family InterPro entries overlap with any other entries (otherwise, we do not need to filter against them, and they would naturally be retained after all other filtering steps):

```{r, include=T}
calc_domfam_ipr = function(int_start, int_stop, ipr_type, i, ipr_accession) {
  all_matches = data.frame(int_start = int_start,
                           int_stop = int_stop,
                           ipr_type = ipr_type,
                           ipr_accession = ipr_accession) %>%
    mutate(ipr_accession = as.character(ipr_accession))
  i_start = all_matches[i, "int_start"]
  i_stop = all_matches[i, "int_stop"]
  domfam_matches = all_matches %>%
    filter(ipr_type == "Domain_Family")
  for (j in 1:nrow(domfam_matches)) {
    j_start = domfam_matches[j, "int_start"]
    j_stop = domfam_matches[j, "int_stop"]
    j_ipr_accession = domfam_matches[j, "ipr_accession"]
    if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
      return(j_ipr_accession)
    }
  }
  return("None")
}
find_overlapping_domfam = function(int_start, int_stop, ipr_type, ipr_accession) {
  overlapping_domfam = c()
  if (!"Domain_Family" %in% ipr_type) {
    return(rep("None", length(int_start)))
  }
  for (i in 1:length(int_start)) {
    if ((ipr_type[i] != "Domain_Family") &
        (ipr_type[i] != "Domain")) {
      overlapping_domfam = c(overlapping_domfam, calc_domfam_ipr(int_start, int_stop, ipr_type, i, ipr_accession))
    } else {
      overlapping_domfam = c(overlapping_domfam, "None")
    }
  }
  return(overlapping_domfam)
}
overlapping_domfams = ips_domains_ipr_ens99_int_specific_retained1 %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., domfam_overlap = find_overlapping_domfam(.$int_start, .$int_stop, .$ENTRY_TYPE, .$ipr_accession))) %>%
  ungroup() %>%
  filter(domfam_overlap != "None")
```

```{r, include=T}
overlapping_domfam_iprs_unique = overlapping_domfams %>% 
  pull(domfam_overlap) %>% 
  unique()
overlapping_domfam_iprs_unique
```

So, `r length(overlapping_domfam_iprs_unique)` unique Domain-Family InterPro entries overlap with entries of other types. Overall, we have `r overlapping_domfams %>% group_by(ensembl_transcript_id) %>% dplyr::select(domfam_overlap) %>% distinct() %>% ungroup() %>% pull(domfam_overlap) %>% length()` such Domain-Family entries. Hence, we do need to prioritise Domain-Family entries next and filter all remaining (non-Domain) entries against them.

## Check overlaps between matches of the type Domain-Family 

First of all, let us check if there are overlaps between Domain-Family entries, and these overlaps, if any, are not just between general and corresponding specific entries (in which case we are not interested in them, as we are going to use only specific entries for filtering):

```{r, include=T}
check_overlaps = function(int_start, int_stop) {
  overlaps = c()
  all_coords = data.frame(int_start = int_start,
                          int_stop = int_stop)
  for (i in 1:nrow(all_coords)) {
    i_start = all_coords[i, "int_start"]
    i_stop = all_coords[i, "int_stop"]
    overlap_detected = F
    for (j in 1:nrow(all_coords)) {
      if (j == i) {
        next
      }
      j_start = all_coords[j, "int_start"]
      j_stop = all_coords[j, "int_stop"]
      if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
        overlaps = c(overlaps, T)
        overlap_detected = T
        break
      }
    }
    if (!overlap_detected) {
      overlaps = c(overlaps, F)
    }
  }
  return(overlaps)
}
ips_domains_ipr_ens99_int_specific_retained1_overlapping.df = ips_domains_ipr_ens99_int_specific_retained1 %>%
  group_by(ensembl_transcript_id) %>%
  filter(ENTRY_TYPE == "Domain_Family") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, ipr_accession, ipr_status, ipr_ancestor, int_start, int_stop) %>%
  distinct() %>%
  do(mutate(., overlaps = check_overlaps(.$int_start, .$int_stop))) %>%
  filter(overlaps == T)
kable(ips_domains_ipr_ens99_int_specific_retained1_overlapping.df) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

So, all the overlaps are pairs of a general and a specific entry which is a child of the general one, and hence we do not need to do anything with them (we will keep both general and specific entries like we did with the Domain entries).

Check if there are general Domain-Family entries not overlapping with any other Domain-Family entries:

```{r, include=T}
ips_domains_ipr_ens99_int_specific_retained1_overlapping.df_iprs = ips_domains_ipr_ens99_int_specific_retained1_overlapping.df %>%
  pull(ipr_accession) %>%
  unique()
dom_family_iprs_unique_single = dom_family_iprs_unique[!dom_family_iprs_unique %in% ips_domains_ipr_ens99_int_specific_retained1_overlapping.df_iprs]
dom_family_iprs_unique_single_general = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ENTRY_TYPE == "Domain_Family") %>%
  filter(ipr_accession %in% dom_family_iprs_unique_single) %>%
  filter(ipr_status == "general") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, ipr_accession, ipr_status, ENTRY_TYPE) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, ipr_accession) %>%
  distinct()
kable(dom_family_iprs_unique_single_general) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

Yes, there are `r nrow(dom_family_iprs_unique_single_general)` cases where there is only one Domain-Family entry in a transcript, and it is general. We need to make these entries in these transcripts specific:

```{r, include=T}
dom_family_iprs_unique_single_general_to_specific = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter(ENTRY_TYPE == "Domain_Family") %>%
  filter(ipr_accession %in% dom_family_iprs_unique_single) %>%
  filter(ensembl_transcript_id %in% 
           (dom_family_iprs_unique_single_general %>% 
              pull(ensembl_transcript_id) %>%
              unique())) %>%
  filter(ipr_status == "general") %>%
  mutate(ipr_status = "specific")
dom_family_iprs_unique_other = ips_domains_ipr_ens99_int_specific_retained1 %>%
  filter((ENTRY_TYPE != "Domain_Family") |
         (!ensembl_transcript_id %in% 
           (dom_family_iprs_unique_single_general %>% 
              pull(ensembl_transcript_id) %>%
              unique())) |
         (!ipr_accession %in% dom_family_iprs_unique_single) |
         (ipr_status != "general"))
ips_domains_ipr_ens99_int_specific_retained1 = dom_family_iprs_unique_single_general_to_specific %>%
  bind_rows(dom_family_iprs_unique_other)
ips_domains_ipr_ens99_int_specific_retained1_iprs = ips_domains_ipr_ens99_int_specific_retained1 %>% 
  filter(ipr_status == "specific") %>%
  pull(ipr_accession) %>% 
  unique()
```

After the replacement we got `r nrow(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ipr_status == "specific"))` specific matches, which is correct, because we had `r retained1_nrow_prev` specific matches on the previous step, and now we got `r nrow(dom_family_iprs_unique_single_general_to_specific %>% filter(ipr_status == "specific"))` additional specific matches. Now we have `r length(ips_domains_ipr_ens99_int_specific_retained1_iprs[ips_domains_ipr_ens99_int_specific_retained1_iprs %in% humantfs_dbd_ids])` unique specific InterPro entries from HumanTFs, which is more than we had on the previous step. This is because now we have additional specific Domain-Family entries:

```{r, include=T}
additional_domfam_iprs = ips_domains_ipr_ens99_int_specific_retained1_iprs[!ips_domains_ipr_ens99_int_specific_retained1_iprs %in% ips_domains_ipr_ens99_int_specific_retained1_iprs_prev]
kable(dbd_ipr_humantfs[dbd_ipr_humantfs$ENTRY_AC %in% additional_domfam_iprs,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

The total number of unique specific InterPro entries also increased to `r ips_domains_ipr_ens99_int_specific_retained1_iprs %>% length()`.

Overall, we have `r ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ENTRY_TYPE == "Domain_Family") %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` specific Domain-Family InterPro entries.

## Filter all remaining matches against Domain-Family matches

Now we are ready to filter all the remaining non-Domain InterPro entries against the specific Domain-Family ones:

```{r, include=T}
outside_df = function(int_start, int_stop, ipr_type, i, ipr_status) {
  all_matches = data.frame(int_start = int_start,
                           int_stop = int_stop,
                           ipr_type = ipr_type,
                           ipr_status = ipr_status)
  i_start = all_matches[i, "int_start"]
  i_stop = all_matches[i, "int_stop"]
  df_matches = all_matches %>%
    filter(ipr_type == "Domain_Family") %>%
    filter(ipr_status == "specific")
  for (j in 1:nrow(df_matches)) {
    j_start = df_matches[j, "int_start"]
    j_stop = df_matches[j, "int_stop"]
    if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
      return(F)
    }
  }
  return(T)
}
calc_retained_iprs = function(int_start, int_stop, ipr_type, ipr_status) {
  if (!"Domain_Family" %in% ipr_type) {
    return(rep(T, length(int_start)))
  }
  retain_ipr = c()
  for (i in 1:length(int_start)) {
    if ((ipr_type[i] != "Domain") & 
        (ipr_type[i] != "Domain_Family")) {
      retain_ipr = c(retain_ipr, outside_df(int_start, int_stop, ipr_type, i, ipr_status))
    } else {
      retain_ipr = c(retain_ipr, T)
    }
  }
  return(retain_ipr)
}
ips_domains_ipr_ens99_int_specific_retained2 = ips_domains_ipr_ens99_int_specific_retained1 %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., retain_ipr = calc_retained_iprs(.$int_start, .$int_stop, .$ENTRY_TYPE, .$ipr_status))) %>%
  ungroup()
ips_domains_ipr_ens99_int_specific_retained2 = ips_domains_ipr_ens99_int_specific_retained2 %>%
  filter(retain_ipr == T)
ips_domains_ipr_ens99_int_specific_retained2_iprs = ips_domains_ipr_ens99_int_specific_retained2 %>% 
  filter(ipr_status == "specific") %>%
  pull(ipr_accession) %>% 
  unique()
```

Now we have `r ips_domains_ipr_ens99_int_specific_retained2_iprs %>% length()` unique specific matches (InterPro entries) out of `r ips_domains_ipr_ens99_int_specific_retained1_iprs %>% length()` we had on the previous step. `r length(ips_domains_ipr_ens99_int_specific_retained2_iprs[ips_domains_ipr_ens99_int_specific_retained2_iprs %in% humantfs_dbd_ids])` of the retained specific entries are from HumanTFs. Hence, we lost the following `r length(ips_domains_ipr_ens99_int_specific_retained1_iprs[ips_domains_ipr_ens99_int_specific_retained1_iprs %in% humantfs_dbd_ids]) - length(ips_domains_ipr_ens99_int_specific_retained2_iprs[ips_domains_ipr_ens99_int_specific_retained2_iprs %in% humantfs_dbd_ids])` InterPro entries from HumanTFs:

```{r, include=T}
kable(dbd_ipr_humantfs[(dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained1_iprs) & (!dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained2_iprs),]) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

There are now `r nrow(ips_domains_ipr_ens99_int_specific_retained2)` signatures in the table overall, of which `r nrow(ips_domains_ipr_ens99_int_specific_retained2 %>% filter(ipr_status == "specific"))` are under specific matches, and `r nrow(ips_domains_ipr_ens99_int_specific_retained2 %>% filter(ipr_status == "general"))` are under general matches.

Check how many specific InterPro entries of different types we have now:

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99_int_specific_retained2 %>%
  filter(ipr_status == "specific") %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession, ENTRY_TYPE) %>%
  distinct() %>%
  ungroup() %>%
  ggplot(aes(x = ENTRY_TYPE)) +
    geom_bar(aes(fill = ENTRY_TYPE)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 11000)) +
    theme_classic() + 
    theme(legend.position = "none")
```

Active sites were removed completely. The number of binding sites did not change, while the number of conserved sites lowered considerably. Family entries subdivided into Family and Domain_Family. The number of Homologous Superfamily entries lowered considerably, while the number of Repeat entries did not change. The number of domains and domain-families did not change as well, which is correct. The number of families went down from `r length(ips_domains_ipr_ens99_int_specific_retained1 %>% filter(ipr_status == "specific") %>% filter(ENTRY_TYPE == "Family") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession))` (the number of specific Family matches after the separation of Domain-Family matches but before the last filtering) to `r length(ips_domains_ipr_ens99_int_specific_retained2 %>% filter(ipr_status == "specific") %>% filter(ENTRY_TYPE == "Family") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession))`.

Overall, there are `r ips_domains_ipr_ens99_int_specific_retained2 %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` matches, of which `r ips_domains_ipr_ens99_int_specific_retained2 %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are specific and `r ips_domains_ipr_ens99_int_specific_retained2 %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are general. The number of matched transcripts is `r ips_domains_ipr_ens99_int_specific_retained2 %>% pull(ensembl_transcript_id) %>% unique() %>% length()`. It did not change from the previous step, which is correct.

Next, let us prioritize Homologous Superfamily InterPro entries, as they also may represent domains (they mark loci with certain tertiary structures). 

## Check overlaps between matches of the type Homologous Superfamily

Check if we have overlapping InterPro entries among Homologous Superfamilies:

```{r, include=T}
check_overlaps = function(int_start, int_stop) {
  overlaps = c()
  all_coords = data.frame(int_start = int_start,
                          int_stop = int_stop)
  for (i in 1:nrow(all_coords)) {
    i_start = all_coords[i, "int_start"]
    i_stop = all_coords[i, "int_stop"]
    overlap_detected = F
    for (j in 1:nrow(all_coords)) {
      if (j == i) {
        next
      }
      j_start = all_coords[j, "int_start"]
      j_stop = all_coords[j, "int_stop"]
      if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
        overlaps = c(overlaps, T)
        overlap_detected = T
        break
      }
    }
    if (!overlap_detected) {
      overlaps = c(overlaps, F)
    }
  }
  return(overlaps)
}
ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf = ips_domains_ipr_ens99_int_specific_retained2 %>%
  group_by(ensembl_transcript_id) %>%
  filter(ENTRY_TYPE == "Homologous_superfamily") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, ipr_accession, ipr_description, int_start, int_stop) %>%
  distinct() %>%
  do(mutate(., overlaps = check_overlaps(.$int_start, .$int_stop))) %>%
  filter(overlaps == T)
transcripts.with.overplapping.hs.count = ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf %>%
  pull(ensembl_transcript_id) %>%
  unique() %>%
  length()
kable(ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

Thus, we have `r nrow(ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf)` overlapping Homologous Superfamily entries in `r transcripts.with.overplapping.hs.count` transcripts out of the total number of transcripts (`r ensg_enst_ensp %>% filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`).

Check how many Homologous Superfamily entries overlap in each transcript:

```{r, include=T}
ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf %>%
  mutate(n = n()) %>%
  pull(n) %>%
  unique()
```

So, overlapping Homologous Superfamily entries are in pairs. Check what pairs of InterPro entries they are:

```{r, include=T}
ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf_pair.table = ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf %>%
  do(arrange(., .$ipr_accession)) %>%
  do(mutate(., ipr_pair = paste0(.$ipr_accession[1], " / ", .$ipr_accession[2]))) %>%
  do(mutate(., description_pair = paste0(.$ipr_description[1], " / ", .$ipr_description[2]))) %>%
  group_by(ipr_pair, description_pair) %>%
  summarise(n = n()) %>%
  arrange(n, dplyr::desc(n))
kable(ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf_pair.table) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```
  
So, there are only `r nrow(ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf_pair.table)` different pairs of InterPro entries. Let us decide what to do in each case: either select a more specific-looking entry (according to InterPro descriptions) or use another criterion, according to literature or other databases:

    1) IPR011011 / IPR036427 (Zinc finger, FYVE/PHD-type / Bromodomain-like superfamily): According to UniProt, a zinc-finger domain is indeed embedded into a bromodomain  ([SP140L](https://www.uniprot.org/uniprot/Q9H930#structure)). Consequently, I will keep both Homologous Superfamily entries.

    2) IPR015943 / IPR036322 (WD40/YVTN repeat-like-containing domain superfamily / WD40-repeat-containing domain superfamily): According to the descriptions in InterPro ([IPR015943](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR015943/) and [IPR036322](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR036322/)), IPR036322 can be more specific, so let us retain it.

    3) IPR036388 / IPR036390 (Winged helix-like DNA-binding domain superfamily / Winged helix DNA-binding domain superfamily): Retain a more specific-looking entry IPR036390 (it is not clear from the InterPro descriptions, [IPR036388](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR036388/) and [IPR036390](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR036390/), which one could be more specific).

    4) IPR008967 / IPR012346 (p53-like transcription factor, DNA-binding / p53/RUNT-type transcription factor, DNA-binding domain superfamily): Retain a more specific-looking entry IPR012346 (the other entry, IPR008967, takes part in some other pairs a well).

    5) IPR008967 / IPR037095 (p53-like transcription factor, DNA-binding / RBP-J/Cbf11/Cbf12, DNA binding domain superfamily): Retain a more specific-looking entry IPR037095.

    6) IPR013783 / IPR014756 (Immunoglobulin-like fold / Immunoglobulin E-set): According to the corresponding descriptions in InterPro ([IPR013783](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR013783/) and [IPR014756](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR014756/)), IPR014756 can be more specific, so let us retain it.

    7) IPR011989 / IPR016024 (Armadillo-like helical / Armadillo-type fold): From InterPro descriptions ([IPR011989](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR011989/) and [IPR016024](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR016024/)) it is not clear which entry is more specific. Let us use IPR016024 (Armadillo-type fold) as it is given by UniProt ([TERB1](https://www.uniprot.org/uniprot/Q8NA31#structure)) for a protein entry corresponding to a transcript that contains both of these entries.

Now let us filter out the entries that we do not retain (we make them "general" in particular transcripts, where they overlap with Homologous Superfamily entries that we keep):

```{r, include=T}
specific.hs.number = ips_domains_ipr_ens99_int_specific_retained2 %>%
  filter(ipr_status == "specific") %>%
  filter(ENTRY_TYPE == "Homologous_superfamily") %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession) %>%
  distinct() %>%
  ungroup() %>%
  pull(ipr_accession) %>%
  length()
overlapping.sf.transcripts = ips_domains_ipr_ens99_int_specific_retained2_overlapping.sf$ensembl_transcript_id
overlapping.sf.iprs.to.general = c("IPR015943", "IPR036388", "IPR008967", "IPR013783", "IPR011989")
ips_domains_ipr_ens99_int_specific_retained2 = ips_domains_ipr_ens99_int_specific_retained2 %>%
  mutate(ipr_status = if_else((ensembl_transcript_id %in% overlapping.sf.transcripts) & (ipr_accession %in% overlapping.sf.iprs.to.general), "general", ipr_status))
```

After this step, the number of specific Homologous Superfamily entries went down from `r specific.hs.number` (all Homologous Superfamily entries are specific, because they do not form a hierarchy) to `r ips_domains_ipr_ens99_int_specific_retained2 %>% filter(ipr_status == "specific") %>% filter(ENTRY_TYPE == "Homologous_superfamily") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (some of the entries became general).

## Filter all remaining matches against Homologous Superfamily matches

Now, let us filter out InterPro entries of the types Site, Repeat and Family that overlap with specific Homologous Superfamily entries:

```{r, include=T}
outside_sf = function(int_start, int_stop, ipr_type, i, ipr_status) {
  all_matches = data.frame(int_start = int_start,
                           int_stop = int_stop,
                           ipr_type = ipr_type,
                           ipr_status = ipr_status)
  i_start = all_matches[i, "int_start"]
  i_stop = all_matches[i, "int_stop"]
  sf_matches = all_matches %>%
    filter(ipr_type == "Homologous_superfamily") %>%
    filter(ipr_status == "specific")
  for (j in 1:nrow(sf_matches)) {
    j_start = sf_matches[j, "int_start"]
    j_stop = sf_matches[j, "int_stop"]
    if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
      return(F)
    }
  }
  return(T)
}
calc_retained_iprs = function(int_start, int_stop, ipr_type, ipr_status) {
  if (!"Homologous_superfamily" %in% ipr_type) {
    return(rep(T, length(int_start)))
  }
  retain_ipr = c()
  for (i in 1:length(int_start)) {
    if ((ipr_type[i] != "Domain") &
        (ipr_type[i] != "Domain_Family") &
        (ipr_type[i] != "Homologous_superfamily")) {
      retain_ipr = c(retain_ipr, outside_sf(int_start, int_stop, ipr_type, i, ipr_status))
    } else {
      retain_ipr = c(retain_ipr, T)
    }
  }
  return(retain_ipr)
}
ips_domains_ipr_ens99_int_specific_retained3 = ips_domains_ipr_ens99_int_specific_retained2 %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., retain_ipr = calc_retained_iprs(.$int_start, .$int_stop, .$ENTRY_TYPE, .$ipr_status))) %>%
  ungroup()
ips_domains_ipr_ens99_int_specific_retained3 = ips_domains_ipr_ens99_int_specific_retained3 %>%
  filter(retain_ipr == T)
ips_domains_ipr_ens99_int_specific_retained3_iprs = ips_domains_ipr_ens99_int_specific_retained3 %>%
  filter(ipr_status == "specific") %>%
  pull(ipr_accession) %>%
  unique()
```

Now we have `r ips_domains_ipr_ens99_int_specific_retained3_iprs %>% length()` unique specific InterPro entries out of `r ips_domains_ipr_ens99_int_specific_retained2_iprs %>% length()` we had on the previous step. `r length(ips_domains_ipr_ens99_int_specific_retained3_iprs[ips_domains_ipr_ens99_int_specific_retained3_iprs %in% humantfs_dbd_ids])` of the retained specific entries are from HumanTFs. Hence, we lost the following `r length(ips_domains_ipr_ens99_int_specific_retained2_iprs[ips_domains_ipr_ens99_int_specific_retained2_iprs %in% humantfs_dbd_ids]) - length(ips_domains_ipr_ens99_int_specific_retained3_iprs[ips_domains_ipr_ens99_int_specific_retained3_iprs %in% humantfs_dbd_ids])` InterPro entries from HumanTFs:

```{r, include=T}
kable(dbd_ipr_humantfs[(dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained2_iprs) & (!dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained3_iprs),]) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

There are now `r nrow(ips_domains_ipr_ens99_int_specific_retained3)` signatures in the table overall, of which `r nrow(ips_domains_ipr_ens99_int_specific_retained3 %>% filter(ipr_status == "specific"))` are under specific matches, and `r nrow(ips_domains_ipr_ens99_int_specific_retained3 %>% filter(ipr_status == "general"))` are under general matches (this is more than we had on the previous step, because some Homologous Superfamily matches were marked "general" before this filtering step).

Check how many unique InterPro entries of different types we have now:

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99_int_specific_retained3 %>%
  filter(ipr_status == "specific") %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession, ENTRY_TYPE) %>%
  distinct() %>%
  ungroup() %>%
  ggplot(aes(x = ENTRY_TYPE)) +
    geom_bar(aes(fill = ENTRY_TYPE)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 11000)) +
    theme_classic() +
    theme(legend.position = "none")
```

The number of Domain and Domain-Family did not change, which is correct. The number of specific Homologous Superfamily entries also did not change since we made some of them general, and this is correct. Binding and conserved sites were almost all outside specific Homologous Superfamily entries, while the number of Family and Repeat entries decreased considerably.

Overall, there are `r ips_domains_ipr_ens99_int_specific_retained3 %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` matches, of which `r ips_domains_ipr_ens99_int_specific_retained3 %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are specific and `r ips_domains_ipr_ens99_int_specific_retained3 %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are general (again, this more than we had on the previous step, because some Homologous Superfamily matches became general). The number of matched transcripts is `r ips_domains_ipr_ens99_int_specific_retained3 %>% pull(ensembl_transcript_id) %>% unique() %>% length()`. It did not change from the previous step, which is correct.

## Check overlaps between matches of the Site types

Next, let us prioritize the remaining binding and conserved sites, as they may be parts of domains that were not accounted for by InterPro entries considered so far.

First, check if site entries overlap with each other:

```{r, include=T}
check_overlaps = function(int_start, int_stop) {
  overlaps = c()
  all_coords = data.frame(int_start = int_start,
                          int_stop = int_stop)
  for (i in 1:nrow(all_coords)) {
    i_start = all_coords[i, "int_start"]
    i_stop = all_coords[i, "int_stop"]
    overlap_detected = F
    for (j in 1:nrow(all_coords)) {
      if (j == i) {
        next
      }
      j_start = all_coords[j, "int_start"]
      j_stop = all_coords[j, "int_stop"]
      if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
        overlaps = c(overlaps, T)
        overlap_detected = T
        break
      }
    }
    if (!overlap_detected) {
      overlaps = c(overlaps, F)
    }
  }
  return(overlaps)
}
ips_domains_ipr_ens99_int_specific_retained3_overlapping.sites = ips_domains_ipr_ens99_int_specific_retained3 %>%
  group_by(ensembl_transcript_id) %>%
  filter(str_detect(ENTRY_TYPE, "site")) %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, ipr_accession, int_start, int_stop, ENTRY_TYPE) %>%
  distinct() %>%
  do(mutate(., overlaps = check_overlaps(.$int_start, .$int_stop))) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, int_start, int_stop, ENTRY_TYPE) %>%
  filter(overlaps == T)
kable(ips_domains_ipr_ens99_int_specific_retained3_overlapping.sites) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

So, we have `r nrow(ips_domains_ipr_ens99_int_specific_retained3_overlapping.sites)` overlapping sites, and among them there are only `r ips_domains_ipr_ens99_int_specific_retained3_overlapping.sites %>% pull(ipr_accession) %>% unique() %>% length()` unique entries of the type Conserved Site:

```{r, include=T}
overlapping.site.iprs = ips_domains_ipr_ens99_int_specific_retained3_overlapping.sites %>%
  pull(ipr_accession) %>%
  unique()
kable(interpro_entries %>%
  filter(ENTRY_AC %in% overlapping.site.iprs)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

According to InterPro (see [IPR000637](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR000637/) and [IPR017956](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR017956/)), IPR017956 (AT-hook) is the actual DBD of HMG proteins, so let us retain it and remove IPR000637:

```{r, include=T}
prev_conserved_sites_number = ips_domains_ipr_ens99_int_specific_retained3 %>%
  filter(ipr_status == "specific") %>%
  filter(ENTRY_TYPE == "Conserved_site") %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession) %>%
  distinct() %>%
  ungroup() %>%
  pull(ipr_accession) %>%
  length()
transcripts.with.overlapping.sites = ips_domains_ipr_ens99_int_specific_retained3_overlapping.sites %>%
  filter(ipr_accession == "IPR000637") %>%
  pull(ensembl_transcript_id) %>%
  unique()
ips_domains_ipr_ens99_int_specific_retained3 = ips_domains_ipr_ens99_int_specific_retained3 %>%
  filter((ipr_accession != "IPR000637") |
         (!ensembl_transcript_id %in% transcripts.with.overlapping.sites))
```

After this step, the number of specific Conserved Site entries went down from `r prev_conserved_sites_number` to `r ips_domains_ipr_ens99_int_specific_retained3 %>% filter(ipr_status == "specific") %>% filter(ENTRY_TYPE == "Conserved_site") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()`, which is correct (one entry went away in each pair of overlapping entries, and there were `r nrow(ips_domains_ipr_ens99_int_specific_retained3_overlapping.sites)` entries in total).

## Filter all remaining matches against Site matches

Next, let us filter out repeats and families overlapping with the retained sites:

```{r, include=T}
outside_sites = function(int_start, int_stop, ipr_type, i, ipr_status) {
  all_matches = data.frame(int_start = int_start,
                           int_stop = int_stop,
                           ipr_type = ipr_type,
                           ipr_status = ipr_status)
  i_start = all_matches[i, "int_start"]
  i_stop = all_matches[i, "int_stop"]
  site_matches = all_matches %>%
    filter((ipr_type == "Binding_site") |
           (ipr_type == "Conserved_site")) %>%
    filter(ipr_status == "specific")
  for (j in 1:nrow(site_matches)) {
    j_start = site_matches[j, "int_start"]
    j_stop = site_matches[j, "int_stop"]
    if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
      return(F)
    }
  }
  return(T)
}
calc_retained_iprs = function(int_start, int_stop, ipr_type, ipr_status) {
  if ((!"Binding_site" %in% ipr_type) &
      (!"Conserved_site" %in% ipr_type)) {
    return(rep(T, length(int_start)))
  }
  retain_ipr = c()
  for (i in 1:length(int_start)) {
    if ((ipr_type[i] != "Domain") &
        (ipr_type[i] != "Homologous_superfamily") &
        (ipr_type[i] != "Binding_site") &
        (ipr_type[i] != "Conserved_site")) {
      retain_ipr = c(retain_ipr, outside_sites(int_start, int_stop, ipr_type, i, ipr_status))
    } else {
      retain_ipr = c(retain_ipr, T)
    }
  }
  return(retain_ipr)
}
ips_domains_ipr_ens99_int_specific_retained4 = ips_domains_ipr_ens99_int_specific_retained3 %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., retain_ipr = calc_retained_iprs(.$int_start, .$int_stop, .$ENTRY_TYPE, .$ipr_status))) %>%
  ungroup()
ips_domains_ipr_ens99_int_specific_retained4 = ips_domains_ipr_ens99_int_specific_retained4 %>%
  filter(retain_ipr == T)
ips_domains_ipr_ens99_int_specific_retained4_iprs = ips_domains_ipr_ens99_int_specific_retained4 %>%
  filter(ipr_status == "specific") %>%
  pull(ipr_accession) %>%
  unique()
```

Now we have `r ips_domains_ipr_ens99_int_specific_retained4_iprs %>% length()` specific InterPro entries out of `r ips_domains_ipr_ens99_int_specific_retained3_iprs %>% length()` we had on the previous step. `r length(ips_domains_ipr_ens99_int_specific_retained4_iprs[ips_domains_ipr_ens99_int_specific_retained4_iprs %in% humantfs_dbd_ids])` of the retained entries are from HumanTFs. Hence, we lost the following `r length(ips_domains_ipr_ens99_int_specific_retained3_iprs[ips_domains_ipr_ens99_int_specific_retained3_iprs %in% humantfs_dbd_ids]) - length(ips_domains_ipr_ens99_int_specific_retained4_iprs[ips_domains_ipr_ens99_int_specific_retained4_iprs %in% humantfs_dbd_ids])` specific InterPro entry from HumanTFs:

```{r, include=T}
#kable(
dbd_ipr_humantfs[(dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained3_iprs) & (!dbd_ipr_humantfs$ENTRY_AC %in% ips_domains_ipr_ens99_int_specific_retained4_iprs),]# ) %>%
  # kable_styling(bootstrap_options = c("striped", "hover")) %>%
  # scroll_box(width = "100%")
```

There are now `r nrow(ips_domains_ipr_ens99_int_specific_retained4)` signatures in the table overall, of which `r nrow(ips_domains_ipr_ens99_int_specific_retained4 %>% filter(ipr_status == "specific"))` are under specific matches, and `r nrow(ips_domains_ipr_ens99_int_specific_retained4 %>% filter(ipr_status == "general"))` are under general matches.

Check how many unique InterPro entries of different types we have now:

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99_int_specific_retained4 %>%
  filter(ipr_status == "specific") %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession, ENTRY_TYPE) %>%
  distinct() %>%
  ungroup() %>%
  ggplot(aes(x = ENTRY_TYPE)) +
    geom_bar(aes(fill = ENTRY_TYPE)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 11000)) +
    theme_classic() +
    theme(legend.position = "none")
```

Hence, no repeats overlapped with sites, but some of the family entries did. The number of conserved sites did not change since we filtered out a particular type, which is correct.

Overall, there are `r ips_domains_ipr_ens99_int_specific_retained4 %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` matches, of which `r ips_domains_ipr_ens99_int_specific_retained4 %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are specific and `r ips_domains_ipr_ens99_int_specific_retained4 %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` are general. The number of matched transcripts is `r ips_domains_ipr_ens99_int_specific_retained4 %>% pull(ensembl_transcript_id) %>% unique() %>% length()`. It did not change from the previous step, which is correct.

## Check overlaps between matches of the Site types

Finally, let us prioritize repeats over families.

First of all, check if repeats overlap with each other:

```{r, include=T}
check_overlaps = function(int_start, int_stop) {
  overlaps = c()
  all_coords = data.frame(int_start = int_start,
                          int_stop = int_stop)
  for (i in 1:nrow(all_coords)) {
    i_start = all_coords[i, "int_start"]
    i_stop = all_coords[i, "int_stop"]
    overlap_detected = F
    for (j in 1:nrow(all_coords)) {
      if (j == i) {
        next
      }
      j_start = all_coords[j, "int_start"]
      j_stop = all_coords[j, "int_stop"]
      if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
        overlaps = c(overlaps, T)
        overlap_detected = T
        break
      }
    }
    if (!overlap_detected) {
      overlaps = c(overlaps, F)
    }
  }
  return(overlaps)
}
ips_domains_ipr_ens99_int_specific_retained4_overlapping.rep = ips_domains_ipr_ens99_int_specific_retained4 %>%
  group_by(ensembl_transcript_id) %>%
  filter(ENTRY_TYPE == "Repeat") %>%
  dplyr::select(ensembl_transcript_id, ipr_accession, int_start, int_stop, ENTRY_TYPE) %>%
  distinct() %>%
  do(mutate(., overlaps = check_overlaps(.$int_start, .$int_stop))) %>%
  filter(overlaps == T)
kable(ips_domains_ipr_ens99_int_specific_retained4_overlapping.rep) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

So, we have no overlapping repeats.

## Filter all remaining matches against Repeat matches

Then, filter out families that overlap with repeats:

```{r, include=T}
outside_repeats = function(int_start, int_stop, ipr_type, i, ipr_status) {
  all_matches = data.frame(int_start = int_start,
                           int_stop = int_stop,
                           ipr_type = ipr_type,
                           ipr_status = ipr_status)
  i_start = all_matches[i, "int_start"]
  i_stop = all_matches[i, "int_stop"]
  repeat_matches = all_matches %>%
    filter(ipr_type == "Repeat") %>%
    filter(ipr_status == "specific")
  for (j in 1:nrow(repeat_matches)) {
    j_start = repeat_matches[j, "int_start"]
    j_stop = repeat_matches[j, "int_stop"]
    if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
      return(F)
    }
  }
  return(T)
}
calc_retained_iprs = function(int_start, int_stop, ipr_type, ipr_status) {
  if (!"Repeat" %in% ipr_type) {
    return(rep(T, length(int_start)))
  }
  retain_ipr = c()
  for (i in 1:length(int_start)) {
    if (ipr_type[i] == "Family") {
      retain_ipr = c(retain_ipr, outside_repeats(int_start, int_stop, ipr_type, i, ipr_status))
    } else {
      retain_ipr = c(retain_ipr, T)
    }
  }
  return(retain_ipr)
}
ips_domains_ipr_ens99_int_specific_retained5 = ips_domains_ipr_ens99_int_specific_retained4 %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., retain_ipr = calc_retained_iprs(.$int_start, .$int_stop, .$ENTRY_TYPE, .$ipr_status))) %>%
  ungroup()
ips_domains_ipr_ens99_int_specific_retained5 = ips_domains_ipr_ens99_int_specific_retained5 %>%
   filter(retain_ipr == T)
ips_domains_ipr_ens99_int_specific_retained5_iprs = ips_domains_ipr_ens99_int_specific_retained5 %>%
  filter(ipr_status == "specific") %>%
  pull(ipr_accession) %>%
  unique()
```

Nothing filtered out on this step: there are still `r nrow(ips_domains_ipr_ens99_int_specific_retained5)` signatures in the table overall, of which `r nrow(ips_domains_ipr_ens99_int_specific_retained5 %>% filter(ipr_status == "specific"))` are under specific matches, and `r nrow(ips_domains_ipr_ens99_int_specific_retained5 %>% filter(ipr_status == "general"))` are under general matches. The number of matched transcripts also remains the same (`r ips_domains_ipr_ens99_int_specific_retained5 %>% pull(ensembl_transcript_id) %>% unique() %>% length()`), which is correct.

## Check overlaps between matches of the type Family

Check if we have overlapping InterPro entries among Families:

```{r, include=T}
check_overlaps = function(int_start, int_stop, ipr_status) {
  overlaps = c()
  all_coords = data.frame(int_start = int_start,
                          int_stop = int_stop,
                          ipr_status = ipr_status)
  for (i in 1:nrow(all_coords)) {
    i_start = all_coords[i, "int_start"]
    i_stop = all_coords[i, "int_stop"]
    i_ipr_status = all_coords[i, "ipr_status"]
    overlap_detected = F
    for (j in 1:nrow(all_coords)) {
      if (j == i) {
        next
      }
      j_start = all_coords[j, "int_start"]
      j_stop = all_coords[j, "int_stop"]
      j_ipr_status = all_coords[j, "ipr_status"]
      if ((min(i_stop, j_stop) - max(i_start, j_start) > 0) &
          (i_ipr_status == j_ipr_status)) {
        overlaps = c(overlaps, T)
        overlap_detected = T
        break
      }
    }
    if (!overlap_detected) {
      overlaps = c(overlaps, F)
    }
  }
  return(overlaps)
}
ips_domains_ipr_ens99_int_specific_retained5_overlapping.fam = ips_domains_ipr_ens99_int_specific_retained5 %>%
  group_by(ensembl_transcript_id) %>%
  filter(ENTRY_TYPE == "Family") %>%
  dplyr::select(ensembl_transcript_id, ipr_accession, int_start, int_stop, ENTRY_TYPE, ipr_status) %>%
  distinct() %>%
  do(mutate(., overlaps = check_overlaps(.$int_start, .$int_stop, .$ipr_status))) %>%
  filter(overlaps == T)
kable(ips_domains_ipr_ens99_int_specific_retained5_overlapping.fam) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

No overlaps of specific with specific or general with general Family matches.

Overall, with this filtering stage we went down from  `r ips_domains_ipr_ens99_int_specific_retained %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` to `r ips_domains_ipr_ens99_int_specific_retained5 %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` specific InterPro entry matches, from `r nrow(ips_domains_ipr_ens99_int)` signatures to `r nrow(ips_domains_ipr_ens99_int_specific_retained5 %>% filter(ipr_status == "specific"))` signatures under specific matches, from `r ips_domains_ipr_ens99_iprs %>% length()` unique InterPro entries to `r ips_domains_ipr_ens99_int_specific_retained5_iprs %>% length()` unique specific entries, and from `r length(ips_domains_ipr_ens99_iprs[ips_domains_ipr_ens99_iprs %in% humantfs_dbd_ids])` entries from HumanTFs to `r length(ips_domains_ipr_ens99_int_specific_retained5_iprs[ips_domains_ipr_ens99_int_specific_retained5_iprs %in% humantfs_dbd_ids])` specific ones. Hence, `r length(ips_domains_ipr_ens99_iprs[ips_domains_ipr_ens99_iprs %in% humantfs_dbd_ids]) - length(ips_domains_ipr_ens99_int_specific_retained5_iprs[ips_domains_ipr_ens99_int_specific_retained5_iprs %in% humantfs_dbd_ids])` InterPro entries from HumanTFs were removed or became general after the filtering procedure above. The vast majority of the retained specific InterPro entries are of the Domain type, which is good.

## Compare numbers of all InterPro entry matches before and after filtering

```{r, include=T}
ipr.matches.before.filtering = ips_domains_ipr_ens99_int_specific_retained %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession, ENTRY_TYPE) %>%
  distinct() %>%
  ungroup() %>%
  count(ENTRY_TYPE) %>%
  mutate(df_state = "before")

ipr.matches.after.filtering = ips_domains_ipr_ens99_int_specific_retained5 %>%
  group_by(ensembl_transcript_id) %>%
  dplyr::select(ipr_accession, ENTRY_TYPE) %>%
  distinct() %>%
  ungroup() %>%
  count(ENTRY_TYPE) %>%
  mutate(df_state = "after")

ipr.matches.filtering.comparison = ipr.matches.before.filtering %>%
  bind_rows(ipr.matches.after.filtering) %>%
  bind_rows(data.frame(ENTRY_TYPE = c("Active_site", "Domain_Family"),
                       n = c(1, 1),
                       df_state = c("after", "before"))) %>%
  mutate(df_state = factor(df_state, levels = c("before", "after"))) %>%
  mutate(ENTRY_TYPE = factor(ENTRY_TYPE, levels = c("Domain", "Domain_Family",
                                                    "Homologous_superfamily",
                                                    "Active_site", "Binding_site",
                                                    "Conserved_site", "Repeat",
                                                    "Family")))

p = ipr.matches.filtering.comparison %>%
  ggplot(aes(x = ENTRY_TYPE,
             y = log10(n),
             fill = df_state)) +
    geom_col(width = .5, 
             position = "dodge") +
    geom_text(aes(x = ENTRY_TYPE, label = n),
              position = position_dodge(width = 1),
              vjust = -1) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave(filename = "data/results/ipr_matches_filtering_comparison_barplot.pdf",
       plot = p,
       width = 6,
       height = 3)

p
```

# Select one signature per match

## Initial selection

Now, let us implement the next stage, which is the selection of a representative signature within each InterPro entry in each transcript.

So, after the first stage of filtering we have the following signatures left (in specific InterPro matches):

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99_int_specific_retained5 %>%
  filter(ipr_status == "specific") %>%
  dplyr::select(db) %>%
  ggplot(aes(x = db)) +
    geom_bar(aes(fill = db)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 30000)) +
    theme_classic() +
    theme(legend.position = "none")
ips_domains_ipr_ens99_iprs = ips_domains_ipr_ens99 %>% pull(ipr_accession) %>% unique()
```

Originally, we had (with no specific-general divison yet):

```{r, include=T, fig.width=10}
ips_domains_ipr_ens99 %>%
  dplyr::select(db) %>%
  ggplot(aes(x = db)) +
    geom_bar(aes(fill = db)) +
    geom_text(stat = "count", aes(label = ..count..), vjust = -1) +
    ylim(c(0, 30000)) +
    theme_classic() +
    theme(legend.position = "none")
ips_domains_ipr_ens99_iprs = ips_domains_ipr_ens99 %>% pull(ipr_accession) %>% unique()
```

So, signatures from Hamap and TIGRFAM disappeared. The numbers of signatures from Gene3D, PANTHER, RIRSF, PRINTS, and SUPERFAMILY decreased dramatically. The numbers of signatures from the other databases (CDD, Pfam, ProSitePatterns, ProSiteProfiles, and SMART) also lowered but not as much.

Define the hierarchy of preference of signatures from different databases. Let us prioritize domain databases and put Pfam first as probably the most standard annotation. The order of the other domain databases is determined by the decreasing number of their signatures in our filtered results: Pfam, SMART, ProSiteProfiles, CDD.

Next, let us place SUPERFAMILY and Gene3D matches as they represent loci with certain 3D structures and hence can correspond to domains.

Next, let us put PRINTS and ProSitePatterns. These signatures are sets of small fragments (conserved motifs) that are used to characterize protein families. They often mark a domain or a conserved site. 

<!-- See, for example, IPR001523 in PAX6-201; IPR020479 in DLX6-202; IPR013087 in ZNF195-201 where the ProSitePatterns signature annotated a zinc-finger array; or IPR018362 in NFYA-202.-->

Finally, place signatures from PIRSF and PANTHER to the end of the list. These are databases of genes, not individual domains ([Mi et al., 2017](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5210595/)), and PANTHER signatures in proteins cover the whole sequence or are much longer than actual domains. 

<!-- See, for example, IPR008122 in TFAP2B-201, IPR001289 in NFYA-202, or IPR028128 in GPBP1-203. Same applies for PIRSF (see IPR001292 in ESR1-202 or ESR1-208). Nevertheless, the presence of a PANTHER or a PIRSF signature helps to recognize a protein as a member of a certain family. -->

Overall, we got the following signature preference hierarchy:

* Pfam;

* SMART;

* ProSiteProfiles;

* CDD;

* SUPERFAMILY;

* Gene3D;

* PRINTS;

* ProSitePatterns;

* PIRSF;

* PANTHER.

Now let us implement the selection for both general and specific matches.

First, choose a representative signature within each InterPro entry according to the preference hierarchy above:

```{r, include=T}
# For all domains
ips_domains_ipr_ens99_int_specific_retained5_raw = ips_domains_ipr_ens99_int_specific_retained5 %>%
  group_by(ensembl_transcript_id, ipr_accession) %>%
  mutate(source_db = case_when(
    "Pfam" %in% db ~ "Pfam",
    "SMART" %in% db ~ "SMART",
    "ProSiteProfiles" %in% db ~ "ProSiteProfiles",
    "CDD" %in% db ~ "CDD",
    "SUPERFAMILY" %in% db ~ "SUPERFAMILY",
    "Gene3D" %in% db ~ "Gene3D",
    "PRINTS" %in% db ~ "PRINTS",
    "ProSitePatterns" %in% db ~ "ProSitePatterns",
    "PIRSF" %in% db ~ "PIRSF",
    "PANTHER" %in% db ~ "PANTHER",
    TRUE ~ "Other"
  )) %>%
  filter(db == source_db) %>%
  ungroup()
```

Signatures from different databases are now represented as follows:

```{r, include=T, fig.width=10}
data.frame(Database = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"),
           Number_of_domains = c(ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "Pfam") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "SMART") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "ProSiteProfiles") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "CDD") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "SUPERFAMILY") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "Gene3D") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "PRINTS") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "ProSitePatterns") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "PIRSF") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_raw %>%
                                   filter(source_db == "PANTHER") %>%
                                   nrow())) %>%
  mutate(Database = factor(Database, levels = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"))) %>%
  ggplot(aes(x = Database, y = Number_of_domains)) +
    geom_col(aes(fill = Database)) +
    geom_text(aes(x = Database, label = Number_of_domains),
              position = position_dodge(width = 1),
              vjust = -1) +
    ylim(c(0, 25000)) +
    theme_classic() +
    theme(legend.position = "none")
```

Now the most part of signatures come from Pfam. The total number of signatures is `r nrow(ips_domains_ipr_ens99_int_specific_retained5_raw)`. PIRSF matches were filtered out.

<!-- # Check that we don't have two or more overlapping matches from a database in the same IRP. -->

## Re-select coordinates for C2H2 ZF and CCCH ZF domains

Secondly, re-select coordinates for C2H2 zinc finger domains and CCCH zinc finger domains (IPR) as SMART seem to represent them better than Pfam (see, for example, IPR013087 in ZNF195-201, ZNF143-202 or ZNF257-203 and IPR000571 in ZC3H8-201, ZGPAT-201, or MBNL2-201): 

```{r, include=T}
ips_domains_ipr_ens99_int_specific_retained5_c2h2 = ips_domains_ipr_ens99_int_specific_retained5 %>%
  filter(str_detect(ipr_description, "C2H2") | # C2H2 ZFs
         ipr_accession == "IPR000571") %>%     # CCCH ZF
  group_by(ensembl_transcript_id, ipr_accession) %>%
  mutate(source_db = case_when(
    "SMART" %in% db ~ "SMART",
    "Pfam" %in% db ~ "Pfam",
    "ProSiteProfiles" %in% db ~ "ProSiteProfiles",
    "CDD" %in% db ~ "CDD",
    "SUPERFAMILY" %in% db ~ "SUPERFAMILY",
    "Gene3D" %in% db ~ "Gene3D",
    "PRINTS" %in% db ~ "PRINTS",
    "ProSitePatterns" %in% db ~ "ProSitePatterns",
    "PANTHER" %in% db ~ "PANTHER",
    TRUE ~ "Other"
  )) %>%
  filter(db == source_db) %>%
  ungroup()
ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok = ips_domains_ipr_ens99_int_specific_retained5_raw %>%
  filter(!str_detect(ipr_description, "C2H2") &
         ipr_accession != "IPR000571") %>%
  bind_rows(ips_domains_ipr_ens99_int_specific_retained5_c2h2)
```

The following domains are now preferably annotated from SMART:

```{r, include=T}
kable(interpro_entries %>%
  filter(ENTRY_AC %in% (ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                          filter(str_detect(ipr_description, "C2H2") |
                                 ipr_accession == "IPR000571") %>%
                          pull(ipr_accession) %>%
                          unique()))) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

Signatures from different databases are now represented as follows:

```{r, include=T, fig.width=10}
data.frame(Database = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"),
           Number_of_domains = c(ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "Pfam") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "SMART") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "ProSiteProfiles") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "CDD") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "SUPERFAMILY") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "Gene3D") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "PRINTS") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "ProSitePatterns") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "PIRSF") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
                                   filter(source_db == "PANTHER") %>%
                                   nrow())) %>%
  mutate(Database = factor(Database, levels = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"))) %>%
  ggplot(aes(x = Database, y = Number_of_domains)) +
    geom_col(aes(fill = Database)) +
    geom_text(aes(x = Database, label = Number_of_domains),
              position = position_dodge(width = 1),
              vjust = -1) +
    ylim(c(0, 25000)) +
    theme_classic() +
    theme(legend.position = "none")
```

The total number of signatures is `r nrow(ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok)`. Hence, prioritizing SMART over Pfam for C2H2-related signatures enabled us to catch `r nrow(ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok) - nrow(ips_domains_ipr_ens99_int_specific_retained5_raw)` more occurences of these domains. And now the majority of signatures come from SMART, as all C2H2 zinc finger domains, as well as CCCH ZF domains, are annotated from this database.

## Re-select coordinates for IPR003656 (BED ZF) 

Thirdly, re-select coordinates for IPR003656 ("Zinc finger, BED-type"), as a signature SM00614 from SMART integrated into this entry is not relevant (according to InterPro support, this signature overhits many proteins, in comparison to other signatures integrated into the entry): 

```{r, include=T}
ips_domains_ipr_ens99_int_specific_retained5_IPR003656 = ips_domains_ipr_ens99_int_specific_retained5 %>%
  filter(ipr_accession == "IPR003656") %>% # "Zinc finger, BED-type"
  group_by(ensembl_transcript_id, ipr_accession) %>%
  mutate(source_db = case_when(
    "Pfam" %in% db ~ "Pfam",
    "ProSiteProfiles" %in% db ~ "ProSiteProfiles",
    "CDD" %in% db ~ "CDD",
    "SUPERFAMILY" %in% db ~ "SUPERFAMILY",
    "Gene3D" %in% db ~ "Gene3D",
    "PRINTS" %in% db ~ "PRINTS",
    "ProSitePatterns" %in% db ~ "ProSitePatterns",
    "PANTHER" %in% db ~ "PANTHER",
    "SMART" %in% db ~ "SMART",
    TRUE ~ "Other"
  )) %>%
  filter(db == source_db) %>%
  ungroup()
ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok = ips_domains_ipr_ens99_int_specific_retained5_c2h2.ok %>%
  filter(ipr_accession != "IPR003656") %>%
  bind_rows(ips_domains_ipr_ens99_int_specific_retained5_IPR003656)
```

Signatures from different databases are now represented as follows:

```{r, include=T, fig.width=10}
data.frame(Database = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"),
           Number_of_domains = c(ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "Pfam") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "SMART") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "ProSiteProfiles") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "CDD") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "SUPERFAMILY") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "Gene3D") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "PRINTS") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "ProSitePatterns") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "PIRSF") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
                                   filter(source_db == "PANTHER") %>%
                                   nrow())) %>%
  mutate(Database = factor(Database, levels = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"))) %>%
  ggplot(aes(x = Database, y = Number_of_domains)) +
    geom_col(aes(fill = Database)) +
    geom_text(aes(x = Database, label = Number_of_domains),
              position = position_dodge(width = 1),
              vjust = -1) +
    ylim(c(0, 25000)) +
    theme_classic() +
    theme(legend.position = "none")
```

The total number of signatures is `r nrow(ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok)`. The number of SMART signatures did not change, which means that either SM00614 or other signatures are present in IPR003656. Consequently, we will need to remove signature SM00614 from IPR003656 later.

## Re-select coordinates for signatures from Gene3D, PRINTS and ProSitePatterns

Next, for domains represented by coordinates from Gene3D, PRINTS or ProSitePatterns and that are not C2H2 zinc finger arrays, take the most upstream and the most downstream coordinates for further analysis:

<!-- (these signatures can be sets of small fragments under one InterPro entry; see, for example, IPR008121 in TFAP2A-201, IPR020479 in HOXA11-201, IPR032675 in FBXL19-201, IPR012295 in TBP-206, or IPR000637 and IPR000116 in HMGA2-201): -->

```{r, include=T}
get_final_coordinates = function(start, stop, source_db, ipr_description) {
  if (((unique(source_db) != "PRINTS") &
       (unique(source_db) != "ProSitePatterns") &
       (unique(source_db) != "Gene3D")) |
      (str_detect(unique(ipr_description), "C2H2"))) {
    return(str_c(as.character(start), "_", as.character(stop)))
  } else {
    return(str_c(as.character(min(start)), "_", as.character(max(stop))))
  }
}
ips_domains_ipr_ens99_int_specific_retained5_prints.ok = ips_domains_ipr_ens99_int_specific_retained5_IPR003656.ok %>%
  group_by(ensembl_transcript_id, ipr_accession) %>%
  do(mutate(., final_coordinates = get_final_coordinates(.$start, .$stop, .$source_db, .$ipr_description))) %>%
  mutate(start = unlist(purrr::map(str_split(final_coordinates, "_"), 1))) %>%
  mutate(stop = unlist(purrr::map(str_split(final_coordinates, "_"), 2))) %>%
  dplyr::select(-final_coordinates) %>%
  mutate(evalue = ifelse(((source_db == "PRINTS") |
                          (source_db == "ProSitePatterns") |
                          (source_db == "Gene3D")) &
                         (!str_detect(ipr_description, "C2H2")), NA, as.character(evalue))) %>%
  mutate(go_terms = ifelse(((source_db == "PRINTS") |
                            (source_db == "ProSitePatterns") |
                            (source_db == "Gene3D")) &
                           (!str_detect(ipr_description, "C2H2")), NA, go_terms)) %>%
  mutate(pathways = ifelse(((source_db == "PRINTS") |
                            (source_db == "ProSitePatterns") |
                            (source_db == "Gene3D")) &
                           (!str_detect(ipr_description, "C2H2")), NA, pathways)) %>%
  ungroup() %>%
  distinct()
```

The numbers of retained signatures are as follows:

```{r, include=T, fig.width=10}
data.frame(Database = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"),
           Number_of_domains = c(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "Pfam") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "SMART") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "ProSiteProfiles") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "CDD") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "SUPERFAMILY") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "Gene3D") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "PRINTS") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "ProSitePatterns") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "PIRSF") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "PANTHER") %>%
                                   nrow())) %>%
  mutate(Database = factor(Database, levels = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"))) %>%
  ggplot(aes(x = Database, y = Number_of_domains)) +
    geom_col(aes(fill = Database)) +
    geom_text(aes(x = Database, label = Number_of_domains),
              position = position_dodge(width = 1),
              vjust = -1) +
    ylim(c(0, 25000)) +
    theme_classic() +
    theme(legend.position = "none")
```

So the numbers of signatures from PRINTS and Gene3D decreased, which is expected. The number of signatures from PRINTS lowered most dramatically. The total number of signatures is `r nrow(ips_domains_ipr_ens99_int_specific_retained5_prints.ok)`.

## Compare the number of signature matches before and after filtering

```{r, include}
signature.matches.before.df = data.frame(Database = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"), 
           Number_of_domains = c(ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "Pfam") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "SMART") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "ProSiteProfiles") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "CDD") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "SUPERFAMILY") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "Gene3D") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "PRINTS") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "ProSitePatterns") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "PIRSF") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5 %>%
                                   filter(db == "PANTHER") %>%
                                   nrow())) %>%
  mutate(Database = factor(Database, levels = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"))) %>%
  mutate(df_state = "before")

signature.matches.after.df = data.frame(Database = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"),
           Number_of_domains = c(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "Pfam") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "SMART") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "ProSiteProfiles") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "CDD") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "SUPERFAMILY") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "Gene3D") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "PRINTS") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "ProSitePatterns") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "PIRSF") %>%
                                   nrow(),
                                 ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
                                   filter(source_db == "PANTHER") %>%
                                   nrow())) %>%
  mutate(Database = factor(Database, levels = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PIRSF", "PANTHER"))) %>%
  mutate(df_state = "after") %>%
  mutate(Number_of_domains = ifelse(Number_of_domains == 0, 1, Number_of_domains))

p = signature.matches.before.df %>%
  bind_rows(signature.matches.after.df) %>%
  mutate(df_state = factor(df_state, levels = c("before", "after"))) %>%
  ggplot(aes(x = Database, 
             y = log10(Number_of_domains),
             fill = df_state)) +
    geom_col(position = "dodge") +
    geom_text(aes(x = Database, label = Number_of_domains),
              position = position_dodge(width = 1),
              vjust = -1) +
    theme_classic() +
    theme(legend.position = "none") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5))

ggsave(filename = "data/results/signature_matches_filtering_comparison_barplot.pdf",
       plot = p,
       width = 6,
       height = 3)

p
```

## Check general matches not overlapping with related specific ones

Check which domain matches do general domain matches intersect:
  
```{r, include=T}
is_i_ancestor_for_j = function(ipr_hierarchy, i_accession, j_accession) {
  i_node = FindNode(ipr_hierarchy, i_accession)
  if (!is.null(i_node)) {
    i_node_t = Traverse(i_node)
    i_node_succ = unlist(lapply(seq_along(i_node_t), function(i) {i_node_t[[i]]$name}))
    return(j_accession %in% i_node_succ)
  } else {
    return(F)
  }
}
detect_overlaps = function(ipr_hierarchy, ipr_accession, start, stop) {
  overlaps = c()
  match_df = data.frame(ipr_accession = as.character(ipr_accession),
                        start = as.numeric(start),
                        stop = as.numeric(stop),
                        stringsAsFactors = FALSE)
  for (i in 1:nrow(match_df)) {
    i_ipr_accession = match_df[i, "ipr_accession"]
    i_start = match_df[i, "start"]
    i_stop = match_df[i, "stop"]
    i_overlaps = F
    for (j in 1:nrow(match_df)) {
      if (j == i) {
        next
      }
      j_ipr_accession = match_df[j, "ipr_accession"]
      j_start = match_df[j, "start"]
      j_stop = match_df[j, "stop"]
      if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
        if (is_i_ancestor_for_j(ipr_hierarchy, i_ipr_accession, j_ipr_accession)) {
          i_overlaps = T
          break
        }
      }
    }
    overlaps = c(overlaps, i_overlaps)
  }
  return(overlaps)
}
ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general = ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  group_by(ensembl_transcript_id) %>%
  filter(ENTRY_TYPE == "Domain") %>%
  do(mutate(., overlaps = detect_overlaps(ipr_hierarchy, 
                                          .$ipr_accession,
                                          .$start, 
                                          .$stop))) %>%
  filter(ipr_status == "general") %>%
  ungroup()
ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general2specific = ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general %>%
  filter(!overlaps) %>%
  mutate(ipr_status = "specific") %>%
  dplyr::select(-overlaps)
ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general.ok = ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general %>%
  filter(overlaps) %>%
  dplyr::select(-overlaps)
ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.specific = ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  filter(ENTRY_TYPE == "Domain") %>%
  filter(ipr_status == "specific")
ips_domains_ipr_ens99_int_specific_retained5_prints.ok_nondom = ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  filter(ENTRY_TYPE != "Domain")
ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general.corrected = ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general2specific %>%
  bind_rows(ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general.ok) %>%
  bind_rows(ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.specific) %>%
  bind_rows(ips_domains_ipr_ens99_int_specific_retained5_prints.ok_nondom)
ips_domains_ipr_ens99_int_specific_retained5_prints.ok = ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general.corrected
```

So `r nrow(ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general2specific)` general domain matches do not intersect their child (more specific) matches. Hence, we qualified these general matches as specific. Here is the list of the InterPro accessions of these matches:

```{r, include=T}
ips_domains_ipr_ens99_int_specific_retained5_prints.ok_dom.general2specific %>%
  dplyr::select(ipr_accession, ipr_description) %>%
  distinct() %>%
  arrange(ipr_accession)
```

# Examples of domain architectures in TFs

Some examples of domain architectures in TF isoforms are shown below:

    1) ZNF248:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000395867") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    2) POU2F2:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000342301") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

A POU domain contains a POU-specific domain and a Homeodomain, which is how it should be. But later, to avoid redundancy, we will need to remove the POU domain and retain only the POU-specific domain and the Homeodomain that the POU domain overlaps.

    3) HMGA2:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000403681") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    4) TBX19:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000431969") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    5) SMYD3:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000490107") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

A MYND domain is incorporated into a SET domain here.

    6) ZNF415:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000421033") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

Here we have two BED zinc finger matches overlapping C2H2 ZF matches. This is caused by the problematic signature SM00614 from IPR003656. We will exclude this signature later on.

    7) FBXL19:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000338343") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    8) KMT2A:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000389506") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    9) YBX2:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000007699") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ENTRY_TYPE, ipr_ancestor, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    10) MGA:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000219905") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    11) TP63:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000434928") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    12) TRPS1:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000220888") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

    13) MYF6:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>%
  filter(ensembl_transcript_id == "ENST00000228641") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, source_db, ipr_accession, ipr_status, ipr_description, start, stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, start, stop)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

The basic domain here is incorrect (it is clearly too long). We will correct this later.

# Classify matches (domains) into different types

Let us have a list of InterPro entries of all domains retained for the analysis (both specific and general):

```{r, include=T}
# Family-type entries that turned into Domain_Family entries may still retain
# Family type in some transcripts where they are not matched by domain signatures.
# So the number of rows in this table can be greater than the total number of
# InterPro entries retained for analysis, because one and the same entry can have
# Domain_Family type in one transcript but Family type in another transcript.
domain_table = ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  dplyr::select(ipr_accession, ipr_description, ENTRY_TYPE) %>%
  arrange(ipr_accession) %>%
  distinct()
write.table(domain_table,
            file = "analysis/filter_ipr_hierarchy/domain_table.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

At this point I ran a Python script that classified all domains into "Non-DBD" (those who do not have any mention of "DNA" in their InterPro description) and others (empty category: "") who have at least one mention of "DNA" in their InterPro descriptions. This script is called "classify_domains.py", and it produced the file "interpro_domain_binary_classification.tsv" which is used below.

Form a preliminary domain classification (here we remove Family entries as they do not represent domains):

```{r, include=T}
domain_table = read.delim("analysis/filter_ipr_hierarchy/domain_table.tsv")
draft_classification_table = read.delim("analysis/classify_domains/output/classify_domains/interpro_domain_binary_classification.tsv")
prelim_classification_table = domain_table %>%
  left_join(draft_classification_table, by = "ipr_accession") %>%
  filter(ENTRY_TYPE != "Family")
write.table(prelim_classification_table,
            file = "analysis/classify_domains/output/classify_domains/prelim_classification_table.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Also, let us move Family entries from the final set of matches into a separate set:

```{r, include=T}
ips_domains_ipr_ens99_int_specific_retained5_prints.ok.fam = ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  filter(ENTRY_TYPE == "Family")
ips_domains_ipr_ens99_int_specific_retained5_prints.ok = ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  filter(ENTRY_TYPE != "Family")
```

Next, I manually curated the preliminary binary classification (Non-DBD vs. everything else) using domain descriptions from InterPro, descriptions of individual signatures and scanning results in TF isoforms. I classified the domains into the following categories:

    - "DBD": DNA-binding domain, according to its InterPro description;

    - "Other": domain with a function different from DNA-binding, according to the InterPro description of the domain;

    - "Non-DBD": category formed automatically in the step above;

    - "Unknown": domain with an unknown function, as stated in its InterPro description;

    - "Unclear": domain whose function is not mentioned in its InterPro description.

Stratify domains in the InterProScan results into DBDs and others:

```{r, include=T}
domain_classification_wb = loadWorkbook("analysis/classify_domains/output/classify_domains/domain_table_manually_annotated.xlsx")
domain_classification_table = readWorksheet(domain_classification_wb, sheet = "domain_table_manually_annotated", header = TRUE)
ips_domains_ipr_ens99_final_strat = ips_domains_ipr_ens99_int_specific_retained5_prints.ok %>%
  left_join(domain_classification_table, by = "ipr_accession") %>%
  dplyr::select(-c("ipr_description.y", "ENTRY_TYPE.y")) %>%
  dplyr::rename("ipr_description" = "ipr_description.x",
                "ENTRY_TYPE" = "ENTRY_TYPE.x",
                "domain_type" = "category")
```

# Check domain types and print statistics

Check that no matches lack an associated domain type:

```{r, include=T}
ips_domains_ipr_ens99_final_strat %>%
  filter(!domain_type %in% c("DBD", "Non-DBD", "Other", "Unclear", "Unknown")) %>%
  dplyr::select(ensembl_transcript_id, ipr_accession, domain_type) %>%
  nrow()
```

Check that no matches have empty comments:

```{r, include=T}
ips_domains_ipr_ens99_final_strat %>%
  filter((category_comment == "") | (is.na(category_comment)))
```

So, all matches have proper category values and non-empty comments associated with them.

For each database, the following plot shows the number of domain types annotated using this database (different instances of the same domain type can be annotated using different databases; for example, in one transcript a particular domain was matched by a Pfam profile, while in another transcript a SMART profile gave a better match for the same domain):

```{r, include=T, fig.width=12}
ips_domains_ipr_ens99_final_strat = ips_domains_ipr_ens99_final_strat %>%
  mutate(ipr_accession = as.character(ipr_accession))
pfam_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Pfam") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
pfam_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Pfam") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
pfam_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Pfam") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
pfam_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Pfam") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
pfam_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Pfam") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
smart_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SMART") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
smart_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SMART") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
smart_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SMART") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
smart_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SMART") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
smart_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SMART") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
pspr_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSiteProfiles") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
pspr_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSiteProfiles") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
pspr_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSiteProfiles") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
pspr_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSiteProfiles") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
pspr_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSiteProfiles") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
cdd_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "CDD") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
cdd_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "CDD") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
cdd_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "CDD") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
cdd_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "CDD") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
cdd_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "CDD") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
sf_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SUPERFAMILY") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
sf_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SUPERFAMILY") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
sf_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SUPERFAMILY") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
sf_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SUPERFAMILY") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
sf_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "SUPERFAMILY") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
gene3d_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Gene3D") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
gene3d_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Gene3D") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
gene3d_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Gene3D") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
gene3d_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Gene3D") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
gene3d_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "Gene3D") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
prints_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PRINTS") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
prints_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PRINTS") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
prints_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PRINTS") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
prints_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PRINTS") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
prints_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PRINTS") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
pspt_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSitePatterns") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
pspt_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSitePatterns") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
pspt_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSitePatterns") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
pspt_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSitePatterns") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
pspt_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "ProSitePatterns") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
panther_domains_dbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PANTHER") & (domain_type == "DBD")) %>%
  pull(ipr_accession) %>%
  unique()
panther_domains_other = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PANTHER") & (domain_type == "Other")) %>%
  pull(ipr_accession) %>%
  unique()
panther_domains_nondbd = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PANTHER") & (domain_type == "Non-DBD")) %>%
  pull(ipr_accession) %>%
  unique()
panther_domains_unknown = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PANTHER") & (domain_type == "Unknown")) %>%
  pull(ipr_accession) %>%
  unique()
panther_domains_unclear = ips_domains_ipr_ens99_final_strat %>%
  filter((source_db == "PANTHER") & (domain_type == "Unclear")) %>%
  pull(ipr_accession) %>%
  unique()
dbd_other_domain_numbers = data.frame("Database" = c(rep("Pfam", 5),
                                                     rep("SMART", 5),
                                                     rep("ProSiteProfiles", 5),
                                                     rep("CDD", 5),
                                                     rep("SUPERFAMILY", 5),
                                                     rep("Gene3D", 5),
                                                     rep("PRINTS", 5),
                                                     rep("ProSitePatterns", 5),
                                                     rep("PANTHER", 5)),
                                      "Category" = c(rep(c("DBD", "Other", "Unknown", "Unclear", "Non-DBD"), 9)),
                                      "Number" = c(length(pfam_domains_dbd), length(pfam_domains_other), length(pfam_domains_unknown), length(pfam_domains_unclear), length(pfam_domains_nondbd),
                                                   length(smart_domains_dbd), length(smart_domains_other), length(smart_domains_unknown), length(smart_domains_unclear), length(smart_domains_nondbd),
                                                   length(pspr_domains_dbd), length(pspr_domains_other), length(pspr_domains_unknown), length(pspr_domains_unclear), length(pspr_domains_nondbd),
                                                   length(cdd_domains_dbd), length(cdd_domains_other), length(cdd_domains_unknown), length(cdd_domains_unclear), length(cdd_domains_nondbd),
                                                   length(sf_domains_dbd), length(sf_domains_other), length(sf_domains_unknown), length(sf_domains_unclear), length(sf_domains_nondbd),
                                                   length(gene3d_domains_dbd), length(gene3d_domains_other), length(gene3d_domains_unknown), length(gene3d_domains_unclear), length(gene3d_domains_nondbd),
                                                   length(prints_domains_dbd), length(prints_domains_other), length(prints_domains_unknown), length(prints_domains_unclear), length(prints_domains_nondbd),
                                                   length(pspt_domains_dbd), length(pspt_domains_other), length(pspt_domains_unknown), length(pspt_domains_unclear), length(pspt_domains_nondbd),
                                                   length(panther_domains_dbd), length(panther_domains_other), length(panther_domains_unknown), length(panther_domains_unclear), length(panther_domains_nondbd)))
dbd_other_domain_numbers %>%
  mutate(Database = factor(Database, levels = c("Pfam", "SMART", "ProSiteProfiles", "CDD", "SUPERFAMILY", "Gene3D", "PRINTS", "ProSitePatterns", "PANTHER"))) %>%
  ggplot(aes(x = Database, y = Number, group = Category)) +
  geom_col(aes(fill = Category), position = "dodge") +
  geom_text(aes(x = Database, label = Number),
            position = position_dodge(width = 1),
            vjust = -1) +
  ylim(c(0, 150)) +
  theme_classic()
```

The total number of DBD types is `r ips_domains_ipr_ens99_final_strat %>% filter(domain_type == "DBD") %>% pull(ipr_accession) %>% unique() %>% length()` (`r ips_domains_ipr_ens99_final_strat %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% pull(ipr_accession) %>% unique() %>% length()` of them are specific); the total number of other domain types is `r ips_domains_ipr_ens99_final_strat %>% filter(domain_type == "Other") %>% pull(ipr_accession) %>% unique() %>% length()`. The total number of all domain types is `r ips_domains_ipr_ens99_final_strat %>% pull(ipr_accession) %>% unique() %>% length()`. The total number of "unknown" (uncharacterized) and unclear domain types is relatively small (`r ips_domains_ipr_ens99_final_strat %>% filter((domain_type == "Unknown") | (domain_type == "Unclear")) %>% pull(ipr_accession) %>% unique() %>% length()`), which is good. Finally, the total number of non-DBD domains that should be classified into other, unknown and unclear types is `r ips_domains_ipr_ens99_final_strat %>% filter(domain_type == "Non-DBD") %>% pull(ipr_accession) %>% unique() %>% length()`, which is still a lot to handle. However, currently, the key point is that they are most probably not DBDs.

The plot shows `r dbd_other_domain_numbers %>% filter(Category == "DBD") %>% pull(Number) %>% sum()` DBD types and `r dbd_other_domain_numbers %>% filter(Category == "Other") %>% pull(Number) %>% sum()` other domain types. The difference with the stats above is caused by the aforementioned fact that different instances of the same domain can be matched by profiles from different databases, and so the same domain can be counted multiple times in the plot above.

A simple bar-chart representing the numbers of different types of specific domains:

```{r, include=T, fig.width=4, fig.height=6}
ggplot(data = data.frame("Category" = c("DBD", "Other", "Unknown", "Unclear", "Non-DBD"),
                         "Count" = c(ips_domains_ipr_ens99_final_strat %>%
                                       filter(ipr_status == "specific") %>%
                                       filter(domain_type == "DBD") %>%
                                       pull(ipr_accession) %>%
                                       unique() %>%
                                       length(),
                                     ips_domains_ipr_ens99_final_strat %>%
                                       filter(ipr_status == "specific") %>%
                                       filter(domain_type == "Other") %>%
                                       pull(ipr_accession) %>%
                                       unique() %>%
                                       length(),
                                     ips_domains_ipr_ens99_final_strat %>%
                                       filter(ipr_status == "specific") %>%
                                       filter(domain_type == "Unknown") %>%
                                       pull(ipr_accession) %>%
                                       unique() %>%
                                       length(),
                                     ips_domains_ipr_ens99_final_strat %>%
                                       filter(ipr_status == "specific") %>%
                                       filter(domain_type == "Unclear") %>%
                                       pull(ipr_accession) %>%
                                       unique() %>%
                                       length(),
                                     ips_domains_ipr_ens99_final_strat %>%
                                       filter(ipr_status == "specific") %>%
                                       filter(domain_type == "Non-DBD") %>%
                                       pull(ipr_accession) %>%
                                       unique() %>%
                                       length())),
       aes(x = Category, y = Count, group = Category)) +
  geom_col(aes(fill = Category), position = "dodge") +
  geom_text(aes(x = Category, label = Count),
            position = position_dodge(width = 1),
            vjust = -1) +
  ylim(c(0, 200)) +
  theme_classic() +
  theme(legend.position = "none")
```

Overall, there are `r ips_domains_ipr_ens99_final_strat %>% filter(domain_type == "DBD") %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` specific DBD-related matches (a match can have multiple domains of the same type in it; for example this is the case with C2H2 zinc fingers) and `r ips_domains_ipr_ens99_final_strat %>% filter(domain_type == "Other") %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` specific other matches.

The number of specific DBD-related InterPro entries (`r ips_domains_ipr_ens99_final_strat %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% pull(ipr_accession) %>% unique() %>% length()`) is way greater than the number of general TF families from HumanTFs (`r ips_domains_ipr_ens99_final_strat %>% left_join(tfs, by = c("ensembl_gene_id" = "Ensembl.ID")) %>% dplyr::select(-c(names(tfs)[(names(tfs) != "DBD") & (names(tfs) != "Ensembl.ID")])) %>% pull(DBD) %>% unique() %>% length()`). This is explained by the fact that there are some noncanonical DBDs, not used to form families, and also different subtypes of the same DBD.

Indeed, a part of these specific DBD-related entries have ancestor (more general) InterPro entries, but most of them do not: from `r ips_domains_ipr_ens99_final_strat %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% pull(ipr_accession) %>% unique() %>% length()` specific DBD-related entries, `r ips_domains_ipr_ens99_final_strat %>%  filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% filter(is.na(ipr_ancestor)) %>% pull(ipr_accession) %>% unique() %>% length()` do not have any ancestor entries. Consequently, the most part of the DBD types should represent subfamilies of the general TF families or be non-canonical.

# Make the final table of all human TF isoforms

Make a table of isoforms without domains (i. e., without matches to InterPro entries):

```{r, include=T}
all_tf_proteins = ensg_enst_ensp %>%
  filter(ensembl_gene_id %in% tfs$Ensembl.ID) %>%
  pull(ensembl_peptide_id) %>%
  unique()
matched_tf_proteins = ips_domains_ipr_ens99_final_strat %>%
  filter(ENTRY_TYPE != "Family") %>%
  pull(protein_accession) %>%
  unique()
unmatched_tf_proteins = all_tf_proteins[!all_tf_proteins %in% matched_tf_proteins]
protein_fasta = read.fasta(file = "analysis/scan_interpro/output/protein_fasta/protein_fasta_tfs_99.fa", seqtype = "AA")
is.unmatched = function(protein_record) {
  protein_id = as.character(str_match(getAnnot(protein_record), "ENSP[0-9]+"))
  return(protein_id %in% unmatched_tf_proteins)
}
unmatched_protein_fasta = protein_fasta[unlist(lapply(protein_fasta, function(p) {is.unmatched(p)}))]
ensp_unmatched_id = as.character(str_match(getAnnot(unmatched_protein_fasta), "ENSP[0-9]+"))
ensp_unmatched_length = as.numeric(purrr::map(seqinr::getSequence(unmatched_protein_fasta, as.string = T), nchar))
no_domain_tf_transcripts = ensg_enst_ensp %>%
  filter(ensembl_peptide_id %in% ensp_unmatched_id) %>%
  left_join(data.frame("ensp_unmatched_id" = ensp_unmatched_id,
                       "ensp_unmatched_length" = ensp_unmatched_length),
            by = c("ensembl_peptide_id" = "ensp_unmatched_id")) %>%
  dplyr::rename(seq_len = ensp_unmatched_length) %>%
  dplyr::rename(protein_accession = ensembl_peptide_id) %>%
  mutate(seq_md5 = NA) %>%
  mutate(db = NA) %>%
  mutate(domain_accession = NA) %>%
  mutate(domain_description = NA) %>%
  mutate(start = NA) %>%
  mutate(stop = NA) %>%
  mutate(evalue = NA) %>%
  mutate(status = NA) %>%
  mutate(run_date = NA) %>%
  mutate(ipr_accession = NA) %>%
  mutate(ipr_description = NA) %>%
  mutate(go_terms = NA) %>%
  mutate(pathways = NA) %>%
  mutate(source_db = NA) %>%
  mutate(domain_type = NA) %>%
  mutate(int_start = NA) %>%
  mutate(int_stop = NA) %>%
  mutate(retain_ipr = NA) %>%
  mutate(ENTRY_TYPE = NA) %>%
  mutate(ipr_status = NA) %>%
  mutate(ipr_ancestor = NA) %>%
  dplyr::select(protein_accession, seq_md5, seq_len, db, domain_accession, domain_description,
                start, stop, evalue, status, run_date, ipr_accession, ipr_description,
                go_terms, pathways, ensembl_gene_id, ensembl_transcript_id, int_start, int_stop, ENTRY_TYPE,
                ipr_status, ipr_ancestor, retain_ipr, source_db, domain_type)
```

Here is a snippet of the table:

```{r, include=T}
kable(head(no_domain_tf_transcripts)) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

This table contains `r no_domain_tf_transcripts %>% pull(ensembl_transcript_id) %>% unique() %>% length()` isoforms.

Combine the tables of isoforms with and without domains:

```{r, include=T}
tf_coding_transcripts_final_ens99 = ips_domains_ipr_ens99_final_strat %>%
  bind_rows(no_domain_tf_transcripts) %>%
  dplyr::select(-source_db)
```

Number of genes: `r tf_coding_transcripts_final_ens99 %>% pull(ensembl_gene_id) %>% unique() %>% length()`.
Number of isoforms: `r tf_coding_transcripts_final_ens99 %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms without matches: `r tf_coding_transcripts_final_ens99 %>% filter(is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms with matches: `r tf_coding_transcripts_final_ens99 %>% filter(!is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of InterPro entry matches: `r tf_coding_transcripts_final_ens99 %>% filter(!is.na(db)) %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()`.
Number of signature matches: `r tf_coding_transcripts_final_ens99 %>% filter(!is.na(db)) %>% nrow()`.
Number of DBD signature matches: `r tf_coding_transcripts_final_ens99 %>% filter(!is.na(db)) %>% filter(domain_type == "DBD") %>% nrow()`.
Number of unique InterPro entries: `r tf_coding_transcripts_final_ens99 %>% pull(ipr_accession) %>% unique() %>% length()`.
Number of specific InterPro entry matches: `r tf_coding_transcripts_final_ens99 %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99 %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).
Number of general InterPro entry matches: `r tf_coding_transcripts_final_ens99 %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99 %>% filter(ipr_status == "general") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).

The table also contains `r tf_coding_transcripts_final_ens99 %>% filter(domain_type == "Other") %>% filter(ipr_status == "specific") %>% pull(ipr_accession) %>% unique() %>% length()` specific other domain types, which is correct.

A simple bar-chart showing the proportion of matched and unmatched isoforms:

```{r, include=T, fig.width=4, fig.height=6}
ggplot(data = data.frame("Category" = c("Domains+", "Domains-"),
                         "Count" = c(tf_coding_transcripts_final_ens99 %>%
                                       filter(!is.na(ipr_accession)) %>%
                                       pull(ensembl_transcript_id) %>%
                                       unique() %>%
                                       length(),
                                     tf_coding_transcripts_final_ens99 %>%
                                       filter(is.na(ipr_accession)) %>%
                                       pull(ensembl_transcript_id) %>%
                                       length()),
                         "x" = rep("Transcripts", 2)),
       aes(x = x, y = Count, group = x)) +
  geom_col(aes(fill = Category)) +
  ylim(c(0, 7500)) +
  theme_classic()
```

Assign TF families to all isoforms:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = tf_coding_transcripts_final_ens99 %>%
  left_join(tfs, by = c("ensembl_gene_id" = "Ensembl.ID")) %>%
  dplyr::select(-c(names(tfs)[(names(tfs) != "DBD") & (names(tfs) != "Ensembl.ID")]))
```

Check that there are no isoforms (with or without domain matches) that do not belong to a general TF family:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter(is.na(DBD))
```

There are no NAs in TF family names, so every record has an associated family name.

Add gene names from HumanTFs:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names =
tf_coding_transcripts_final_ens99_with_fam_names %>%
  left_join(tfs %>% dplyr::select(Ensembl.ID, HGNC.symbol), 
            by = c("ensembl_gene_id" = "Ensembl.ID")) %>%
  dplyr::rename("humantfs_gene_name" = "HGNC.symbol")
```

## Correct DBD matches in isoforms

Before beginning the analysis, we need to additionally correct DBD matches.

1. The only PANTHER matches are in IRF, and they do not represent domains
(the HMM length of PTHR11949 is 349, so it certainly covers much more than a domain).

So we need to remove these PANTHER matches:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  # The only macthes in this transcript are the PANTHER ones, 
  # so I need to remove them retaining the isoform itself:
  filter(ensembl_transcript_id == "ENST00000505067") %>% 
  mutate_at(setdiff(names(tf_coding_transcripts_final_ens99_with_fam_names),
                    c("protein_accession",
                      "seq_md5",
                      "seq_len",
                      "ensembl_gene_id",
                      "ensembl_transcript_id",
                      "DBD",
                      "humantfs_gene_name")),
            function(x) { x = NA }) %>% 
  distinct() %>%
  bind_rows(tf_coding_transcripts_final_ens99_with_fam_names %>%
              filter(ensembl_transcript_id != "ENST00000505067")) %>%
  # and then I just remove all other PANTHER matches 
  # (they are not the only macthes in the corresponding isoforms)
  filter((db != "PANTHER") | is.na(db))
```

2. Remove zinc finger ribbons (3 C2H2 ZF motifs as one domain, IPR031799), as they almost always coincide with separate zinc finger motifs (and those few ribbon matches that do not coincide are most probably partial and do not represent whole zinc finger motifs):

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  # In isoform ENST00000593661,
  # a zinc finger ribbon is the only match, so I need to remove it
  # retaining the isoform itsef:
  filter(ensembl_transcript_id == "ENST00000593661") %>% 
  mutate_at(setdiff(names(tf_coding_transcripts_final_ens99_with_fam_names),
                    c("protein_accession",
                      "seq_md5",
                      "seq_len",
                      "ensembl_gene_id",
                      "ensembl_transcript_id",
                      "DBD",
                      "humantfs_gene_name")),
            function(x) { x = NA }) %>% 
  distinct() %>%
  bind_rows(tf_coding_transcripts_final_ens99_with_fam_names %>%
              filter(ensembl_transcript_id != "ENST00000593661"))
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  # In isoform ENST00000594748,
  # a zinc finger ribbon is the only match, so I need to remove it
  # retaining the isoform itself:
  filter(ensembl_transcript_id == "ENST00000594748") %>% 
  mutate_at(setdiff(names(tf_coding_transcripts_final_ens99_with_fam_names),
                    c("protein_accession",
                      "seq_md5",
                      "seq_len",
                      "ensembl_gene_id",
                      "ensembl_transcript_id",
                      "DBD",
                      "humantfs_gene_name")),
            function(x) { x = NA }) %>% 
  distinct() %>%
  bind_rows(tf_coding_transcripts_final_ens99_with_fam_names %>%
              filter(ensembl_transcript_id != "ENST00000594748"))
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  # In other isoforms, these ribbons coincide with
  # separate zinc finger motifs, so I just need to remove 
  # the ribbon matches
  filter((ipr_accession != "IPR031799") | is.na(ipr_accession))
```

3. Remove zinc finger dimers, as they almost always conincide with separate zinc finger motifs (and those few ribbon matches that do not coincide are most probably partial and do not represent whole zinc finger motifs):

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  # In isoform ENST00000421864,
  # a zinc finger dimer is the only match, so I need to remove it
  # retaining the isoform itself:
  filter(ensembl_transcript_id == "ENST00000421864") %>% 
  mutate_at(setdiff(names(tf_coding_transcripts_final_ens99_with_fam_names),
                    c("protein_accession",
                      "seq_md5",
                      "seq_len",
                      "ensembl_gene_id",
                      "ensembl_transcript_id",
                      "DBD",
                      "humantfs_gene_name")),
            function(x) { x = NA }) %>% 
  distinct() %>%
  bind_rows(tf_coding_transcripts_final_ens99_with_fam_names %>%
              filter(ensembl_transcript_id != "ENST00000421864"))
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  # In other isoforms, these dimers coincide with
  # separate zinc finger motifs, so I just need to remove 
  # the dimer matches
  filter((ipr_accession != "IPR041661") | is.na(ipr_accession))
```

4. Remove the triple CCCH ZF-match (IPR041686), as it coincides with separate CCCH ZF matches:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter((ipr_accession != "IPR041686") | is.na(ipr_accession))
```

5. Remove the VDR DBD matches (IPR042153) as they coincide with the dimeric zinc finger motif matches (IPR001628):

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter((ipr_accession != "IPR042153") | is.na(ipr_accession))
```

6. Remove the POU domain (IPR013847) as it always overlaps with Homeobox and/or POU-specific domains:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter((ipr_accession != "IPR013847") | is.na(ipr_accession))
```

7. Remove matches of the C-terminal part of Homeobox engrailed (IPR019549; it always coincides with the homeobox match):

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter((ipr_accession != "IPR019549") | is.na(ipr_accession))
```

8. Remove CTF transcription factor/nuclear factor 1, DNA-binding domain matches (IPR020604), as they always contain IPR019548 (CTF TF/NF1, N-terminal) and/or IPR003619 (MH1, Dwarfin-type) matches:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter((ipr_accession != "IPR020604") | is.na(ipr_accession))
```

9. In two very short isoforms of RBPJ gene from the CSL family, ENST00000509158 and ENST00000514807, remove the only two matches: "p53-like transcription factor, DNA-binding" (IPR008967) and "RBP-J/Cbf11/Cbf12, DNA binding domain superfamily" (IPR037095) matches. The problem is that they are very general, and the proper CSL (LAG-1) DBD ("RBP-J/Cbf11/Cbf12, DNA binding", IPR015351) does not match in these isoforms:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter(ensembl_transcript_id %in% c("ENST00000509158", "ENST00000514807")) %>% 
  mutate_at(setdiff(names(tf_coding_transcripts_final_ens99_with_fam_names),
                    c("protein_accession",
                      "seq_md5",
                      "seq_len",
                      "ensembl_gene_id",
                      "ensembl_transcript_id",
                      "DBD",
                      "humantfs_gene_name")),
            function(x) { x = NA }) %>% 
  distinct() %>%
  bind_rows(tf_coding_transcripts_final_ens99_with_fam_names %>%
              filter(!ensembl_transcript_id %in% c("ENST00000509158", "ENST00000514807")))
```

10. In a short isoform ENST00000488107 of TFDP2 gene from the E2F family, remove the "Winged helix-like DNA-binding domain superfamily" (IPR036388) match, because "E2F/DP family, winged-helix DNA-binding domain" (E2F DBD, IPR003316) does not match in this isoform, and the IPR036388 match does not exactly correspond to a would-be E2F DBD fragment, according to the sequence and matches in longer isoforms; IPR036388 is the only match in ENST00000488107:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter(ensembl_transcript_id == "ENST00000488107") %>% 
  mutate_at(setdiff(names(tf_coding_transcripts_final_ens99_with_fam_names),
                    c("protein_accession",
                      "seq_md5",
                      "seq_len",
                      "ensembl_gene_id",
                      "ensembl_transcript_id",
                      "DBD",
                      "humantfs_gene_name")),
            function(x) { x = NA }) %>% 
  distinct() %>%
  bind_rows(tf_coding_transcripts_final_ens99_with_fam_names %>%
              filter(ensembl_transcript_id != "ENST00000488107"))
```

11. In a short isoform ENST00000587646 of STAT5A gene from the STAT family, remove the "p53-like transcription factor, DNA-binding" (IPR008967) match, because it is very general and does not correspond to a would-be match of the STAT DBD ("STAT transcription factor, DNA-binding", IPR013801), according to the sequence and matches in longer isoforms (for example, in STAT5A-201, ENST00000345506):

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter((ipr_accession != "IPR008967") | 
         (ensembl_transcript_id != "ENST00000587646"))
```

12. Some domain matches are most probably disrupted, so we need to make them whole matches:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
  tf_coding_transcripts_final_ens99_with_fam_names %>%
  # Make two parts of a disrupted Forkhead domain one match
  # Transcript: ENST00000376197
  mutate(start = ifelse((ensembl_transcript_id == "ENST00000376197") &
                        (ipr_accession == "IPR001766"),
                        287,
                        start),
         stop = ifelse((ensembl_transcript_id == "ENST00000376197") &
                       (ipr_accession == "IPR001766"),
                       422,
                       stop),
         evalue = ifelse((ensembl_transcript_id == "ENST00000376197") &
                         (ipr_accession == "IPR001766"),
                         NA,
                         evalue)) %>%
  # Transcript: ENST00000557224
  mutate(start = ifelse((ensembl_transcript_id == "ENST00000557224") &
                        (ipr_accession == "IPR001766"),
                        302,
                        start),
         stop = ifelse((ensembl_transcript_id == "ENST00000557224") &
                       (ipr_accession == "IPR001766"),
                       437,
                       stop),
         evalue = ifelse((ensembl_transcript_id == "ENST00000557224") &
                         (ipr_accession == "IPR001766"),
                         NA,
                         evalue)) %>%
  # Make two parts of a disrupted COE domain one match
  mutate(start = ifelse((ensembl_transcript_id == "ENST00000380654") &
                        (ipr_accession == "IPR032200"),
                        18,
                        start),
         stop = ifelse((ensembl_transcript_id == "ENST00000380654") &
                       (ipr_accession == "IPR032200"),
                       223,
                       stop),
         evalue = ifelse((ensembl_transcript_id == "ENST00000380654") &
                         (ipr_accession == "IPR032200"),
                         NA,
                         evalue)) %>%
  # Make two parts of a disrupted POU-specific domain one match
  # Transcript: ENST00000403058
  mutate(start = ifelse((ensembl_transcript_id == "ENST00000403058") &
                        (ipr_accession == "IPR000327"),
                        480,
                        start),
         stop = ifelse((ensembl_transcript_id == "ENST00000403058") &
                       (ipr_accession == "IPR000327"),
                       586,
                       stop),
         evalue = ifelse((ensembl_transcript_id == "ENST00000403058") &
                         (ipr_accession == "IPR000327"),
                         NA,
                         evalue)) %>%
  # Transcript: ENST00000518318
  mutate(start = ifelse((ensembl_transcript_id == "ENST00000518318") &
                        (ipr_accession == "IPR000327"),
                        509,
                        start),
         stop = ifelse((ensembl_transcript_id == "ENST00000518318") &
                       (ipr_accession == "IPR000327"),
                       615,
                       stop),
         evalue = ifelse((ensembl_transcript_id == "ENST00000518318") &
                         (ipr_accession == "IPR000327"),
                         NA,
                         evalue)) %>%
  distinct()
```

13. Restore some relevant DBD matches lost during hierarchical filtering:

1) AT hook (IPR017956, SMART) in BAZ2A (ENST00000379441, ENST00000549884, ENST00000551812).
2) C2H2C ZF (IPR002515, Pfam) in ST18 (ENST00000276480).
3) C2H2C ZF (IPR002515, Pfam) in MYT1L.

Implementation:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
  
  tf_coding_transcripts_final_ens99_with_fam_names %>%
  
  bind_rows(ips_domains_ipr_ens99_int_specific_retained %>%
              filter((ensembl_transcript_id %in% c("ENST00000379441", "ENST00000549884", "ENST00000551812")) & (ipr_accession == "IPR017956") & (db == "SMART")) %>%
              mutate(DBD = "AT hook; MBD", humantfs_gene_name = (humantfs %>% mutate(Ensembl.ID = as.character(Ensembl.ID)) %>% filter(Ensembl.ID == unique(ensembl_gene_id)) %>% pull(HGNC.symbol)), domain_type = "DBD", ipr_status = "specific") %>%
              left_join(domain_classification_table, 
                        by = c("ipr_accession" = "ipr_accession",
                               "ipr_description" = "ipr_description",
                               "ENTRY_TYPE" = "ENTRY_TYPE")) %>%
              dplyr::select(-category) %>%
              mutate(start = as.character(start)) %>%
              mutate(stop = as.character(stop))) %>%
  
  bind_rows(ips_domains_ipr_ens99_int_specific_retained %>%
              filter((ensembl_transcript_id == "ENST00000276480") & (ipr_accession == "IPR002515") & (db == "Pfam")) %>%
              mutate(DBD = "C2H2 ZF", humantfs_gene_name = (humantfs %>% mutate(Ensembl.ID = as.character(Ensembl.ID)) %>% filter(Ensembl.ID == unique(ensembl_gene_id)) %>% pull(HGNC.symbol)), domain_type = "DBD", ipr_status = "specific") %>%
              left_join(domain_classification_table, 
                        by = c("ipr_accession" = "ipr_accession",
                               "ipr_description" = "ipr_description",
                               "ENTRY_TYPE" = "ENTRY_TYPE")) %>%
              dplyr::select(-category) %>%
              mutate(start = as.character(start)) %>%
              mutate(stop = as.character(stop))) %>%
  
  bind_rows(ips_domains_ipr_ens99_int_specific_retained %>%
              filter((ensembl_gene_id == "ENSG00000186487") & (ipr_accession == "IPR002515") & (db == "Pfam")) %>%
              mutate(DBD = "C2H2 ZF", humantfs_gene_name = (humantfs %>% mutate(Ensembl.ID = as.character(Ensembl.ID)) %>% filter(Ensembl.ID == unique(ensembl_gene_id)) %>% pull(HGNC.symbol)), domain_type = "DBD", ipr_status = "specific") %>%
              left_join(domain_classification_table, 
                        by = c("ipr_accession" = "ipr_accession",
                               "ipr_description" = "ipr_description",
                               "ENTRY_TYPE" = "ENTRY_TYPE")) %>%
              dplyr::select(-category) %>%
              mutate(start = as.character(start)) %>%
              mutate(stop = as.character(stop))) %>%
  
  filter((ensembl_gene_id != "ENSG00000186487") | (ipr_accession != "IPR036060"))
```

14. Exclude InterPro entries and signatures that are integrated by mistake (as I clarified with InterPro support team):

1) IPR037220 is not a "Zinc finger BED domain" and will be unintegrated from InterPro in v82.0.

2) Signature SM00614 from IPR003656 ("Zinc finger, BED-type") does not correspond to a BED ZF, because, according to the InterPro support team, it overhits many proteins, in comparison to other signatures intergrated in this entry. Signature SM00614 will be unitegrated from InterPro in v82.0.

Implementation:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = 
  tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter((ipr_accession != "IPR037220") | is.na(ipr_accession)) %>% 
  filter((ipr_accession != "IPR003656") | (domain_accession != "SM00614") | is.na(ipr_accession))
```

Number of genes: `r tf_coding_transcripts_final_ens99_with_fam_names %>% pull(ensembl_gene_id) %>% unique() %>% length()`.
Number of isoforms: `r tf_coding_transcripts_final_ens99_with_fam_names %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms without matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms with matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(!is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(!is.na(db)) %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()`.
Number of signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(!is.na(db)) %>% nrow()`.
Number of DBD signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(!is.na(db)) %>% filter(domain_type == "DBD") %>% nrow()`.
Number of unique InterPro entries: `r tf_coding_transcripts_final_ens99_with_fam_names %>% pull(ipr_accession) %>% unique() %>% length()`.
Number of specific InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).
Number of general InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(ipr_status == "general") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).

The number of genes and the number of isoforms stay the same, which is correct. Additionally, the number of isoforms with matches declined a little, while the number of isoforms without matches increased by the same number, which is also correct. Finally, the numbers of InterPro entry matches, unique InterPro entries, specific and general matches declined, which is expected.

## Remove general DBD matches

We still have specific and general InterPro entry matches in our data (see the stats above).

By definition, a specific match does not have or overlap its children (if any) from the InterPro hierarchy in the same isoform. If a match is not specific, it is called general.

Let us check if all general DBD matches overlap with more specific DBD matches:

```{r, include=T}
compareNA = function(v1, v2) {
    same = (v1 == v2) | (is.na(v1) & is.na(v2))
    same[is.na(same)] = F
    return(same)
}
# is_i_ancestor_for_j = function(ipr_hierarchy, i_accession, j_accession) {
#   i_node = FindNode(ipr_hierarchy, i_accession)
#   if (!is.null(i_node)) {
#     i_node_t = Traverse(i_node)
#     i_node_succ = unlist(lapply(seq_along(i_node_t), function(i) {i_node_t[[i]]$name}))
#     return(j_accession %in% i_node_succ)
#   } else {
#     return(F)
#   }
# }
# 
# generate_overlap_table = function(ipr_hierarchy,
#                                   ensembl_gene_id,
#                                   ipr_accession,
#                                   ipr_description,
#                                   start, 
#                                   stop, 
#                                   ipr_status, 
#                                   domain_type, 
#                                   represents_family) {
#   match_df = data.frame(ensembl_gene_id = as.character(ensembl_gene_id),
#                         ipr_accession = as.character(ipr_accession),
#                         ipr_description = as.character(ipr_description),
#                         start = as.numeric(start),
#                         stop = as.numeric(stop),
#                         ipr_status = as.character(ipr_status),
#                         domain_type = as.character(domain_type),
#                         represents_family = as.character(represents_family),
#                         stringsAsFactors = FALSE)
#   overlap_table = data.frame(ensembl_gene_id = "",
#                              ipr_accession = "",
#                              start = "",
#                              stop = "",
#                              overlap_ipr_accession = "", 
#                              overlap_ipr_description = "", 
#                              overlap_ipr_status = "",
#                              overlap_domain_type = "",
#                              overlap_represents_family = "",
#                              overlap_start = "",
#                              overlap_stop = "")
#   for (i in 1:nrow(match_df)) {
#     i_ensembl_gene_id = match_df[i, "ensembl_gene_id"]
#     i_ipr_accession = match_df[i, "ipr_accession"]
#     i_ipr_status = match_df[i, "ipr_status"]
#     i_domain_type = match_df[i, "domain_type"]
#     i_start = match_df[i, "start"]
#     i_stop = match_df[i, "stop"]
#     i_represents_family = match_df[i, "represents_family"]
#     if (!compareNA(i_ipr_status, "general") | 
#         !compareNA(i_domain_type, "DBD") | 
#         is.na(i_represents_family)) {
#       overlap_table = overlap_table %>%
#         bind_rows(c(ensembl_gene_id = i_ensembl_gene_id,
#                     ipr_accession = i_ipr_accession,
#                     start = i_start,
#                     stop = i_stop,
#                     overlap_ipr_accession = "", 
#                     overlap_ipr_description = "",
#                     overlap_ipr_status = "",
#                     overlap_domain_type = "",
#                     overlap_represents_family = "",
#                     overlap_start = "",
#                     overlap_stop = ""))
#       next
#     }
#     i_overlaps = F
#     for (j in 1:nrow(match_df)) {
#       if (j == i) {
#         next
#       }
#       j_ipr_accession = match_df[j, "ipr_accession"]
#       j_ipr_description = match_df[j, "ipr_description"]
#       j_domain_type = match_df[j, "domain_type"]
#       j_start = match_df[j, "start"]
#       j_stop = match_df[j, "stop"]
#       j_ipr_status = match_df[j, "ipr_status"]
#       j_represents_family = match_df[j, "represents_family"]
#       overlap_length = min(i_stop, j_stop) - max(i_start, j_start)
#       if (overlap_length > 0) {
#         i_overlaps = T
#         overlap_table = overlap_table %>%
#           bind_rows(c(ensembl_gene_id = i_ensembl_gene_id,
#                       ipr_accession = i_ipr_accession,
#                       start = i_start,
#                       stop = i_stop,
#                       overlap_ipr_accession = j_ipr_accession, 
#                       overlap_ipr_description = j_ipr_description,
#                       overlap_ipr_status = j_ipr_status,
#                       overlap_domain_type = j_domain_type,
#                       overlap_represents_family = j_represents_family,
#                       overlap_start = j_start,
#                       overlap_stop = j_stop))
#       }
#     }
#     if (!i_overlaps) {
#       overlap_table = overlap_table %>%
#         bind_rows(c(ensembl_gene_id = i_ensembl_gene_id,
#                     ipr_accession = i_ipr_accession,
#                     start = i_start,
#                     stop = i_stop,
#                     overlap_ipr_accession = "", 
#                     overlap_ipr_description = "", 
#                     overlap_ipr_status = "",
#                     overlap_domain_type = "",
#                     overlap_represents_family = "",
#                     overlap_start = "",
#                     overlap_stop = ""))
#     }
#   }
#   overlap_table = overlap_table[-1,]
#   return(overlap_table)
# }
# 
# general_dbd_overlap_table = tf_coding_transcripts_final_ens99_with_fam_names %>%
#   group_by(ensembl_transcript_id) %>%
#   do(left_join(., generate_overlap_table(ipr_hierarchy, 
#                                          .$ensembl_gene_id,
#                                          .$ipr_accession,
#                                          .$ipr_description,
#                                          .$start,
#                                          .$stop,
#                                          .$ipr_status,
#                                          .$domain_type,
#                                          .$represents_family),
#                by = c("ensembl_gene_id" = "ensembl_gene_id", 
#                       "ipr_accession" = "ipr_accession", 
#                       "start" = "start", 
#                       "stop" = "stop"))) %>%
#   ungroup()
# write.table(general_dbd_overlap_table, 
#             file = "general_dbd_overlap_table.tsv", 
#             quote = F, 
#             sep = "\t", 
#             row.names = F)
general_dbd_overlap_table = read.delim("analysis/general_dbd_overlap_table.tsv") %>%
  mutate(start = as.character(start)) %>%
  mutate(stop = as.character(stop)) %>%
  mutate(overlap_start = as.character(overlap_start)) %>%
  mutate(overlap_stop = as.character(overlap_stop)) %>%
  mutate(overlap_start = ifelse(is.na(overlap_start), "", overlap_start)) %>%
  mutate(overlap_stop = ifelse(is.na(overlap_stop), "", overlap_stop)) %>%
  mutate(category_content_comment = as.character(category_content_comment)) %>%
  mutate(represents_family = as.character(represents_family)) %>%
  mutate(overlap_represents_family = as.character(overlap_represents_family))
  
general_dbd_overlap_table %>%
  filter(ipr_status == "general") %>%
  filter(domain_type == "DBD") %>%
  filter(!is.na(represents_family)) %>%
  filter(!compareNA(represents_family, overlap_represents_family)) %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, ensembl_transcript_id, DBD, ipr_accession, ipr_description, start, stop, represents_family, overlap_represents_family, overlap_ipr_accession, overlap_ipr_description, overlap_ipr_status, overlap_domain_type, overlap_start, overlap_stop) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, ipr_accession)
```

Hence, general DBD matches, not overlapped by other matches representing the same family, are overlapped by domains of a different specific type, and so we retain the more specific matches as they could be more functionally relevant (we will correct this later, during the curation of TF families, if necessary).

The only exception are Nuclear receptor ZF DBD matches in VDR: they do not overlap with any other domains. So we just need to make them specific:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = tf_coding_transcripts_final_ens99_with_fam_names %>%
  mutate(ipr_status = ifelse((ensembl_gene_id == "ENSG00000111424") &
                             (ensembl_transcript_id %in% c("ENST00000395324",
                                                           "ENST00000546653",
                                                           "ENST00000549336",
                                                           "ENST00000550325")) &
                             (ipr_accession == "IPR001628"),
                             "specific",
                             ipr_status))
```

Now, we can remove general DBD matches:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names = tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter(is.na(ipr_accession) | (domain_type != "DBD") | (ipr_status != "general"))
```

Number of genes: `r tf_coding_transcripts_final_ens99_with_fam_names %>% pull(ensembl_gene_id) %>% unique() %>% length()`.
Number of isoforms: `r tf_coding_transcripts_final_ens99_with_fam_names %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms without matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms with matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(!is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(!is.na(db)) %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()`.
Number of signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(!is.na(db)) %>% nrow()`.
Number of DBD signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(!is.na(db)) %>% filter(domain_type == "DBD") %>% nrow()`.
Number of unique InterPro entries: `r tf_coding_transcripts_final_ens99_with_fam_names %>% pull(ipr_accession) %>% unique() %>% length()`.
Number of specific InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).
Number of general InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names %>% filter(ipr_status == "general") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).

The numbers of genes, isoforms, isoforms with and without matches stay the same, which is correct. On the other hand, the numbers of InterPro entry matches, signature matches and unique InterPro entries decreased, which is expected. Finally, the total number of general matches decreased and the number of general DBD matches turned into zero, which is also expected; on the other hand, the numbers of specific matches slightly increased, because we turned the general matches without overlaps into specific.

## Deduplicate DBD matches

Next, check if there are overlapping specific DBD matches and in each overlap select the longest match (we do not want to count the same DBD multiple times if it is matched by slightly different InterPro entries):

```{r, include=T}
calc_overlap_result = function(start, stop) {
  results = c()
  all_coords = data.frame(start = start,
                          stop = stop)
  for (i in 1:nrow(all_coords)) {
    i_start = all_coords[i, "start"]
    i_stop = all_coords[i, "stop"]
    i_length = i_stop - i_start
    j_length_max = 0
    for (j in 1:nrow(all_coords)) {
      if (j == i) {
        next
      }
      j_start = all_coords[j, "start"]
      j_stop = all_coords[j, "stop"]
      j_length = j_stop - j_start
      if (min(i_stop, j_stop) - max(i_start, j_start) > 0) {
        if (j_length > j_length_max) {
          j_length_max = j_length
        }
      }
    }
    results = c(results, str_c(c(j_length_max,
                                 i_length), 
                               collapse = "|"))
  }
  return(results)
}
selected_overlapping_dbds = tf_coding_transcripts_final_ens99_with_fam_names %>%
  filter(domain_type == "DBD") %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop)) %>% 
  group_by(ensembl_transcript_id) %>%
  mutate(overlap_result = calc_overlap_result(start, stop)) %>%
  mutate(overlapping_max_length = t(as.data.frame(str_split(overlap_result, fixed("|"))))[,1]) %>%
  mutate(self_length = t(as.data.frame(str_split(overlap_result, fixed("|"))))[,2]) %>%
  ungroup() %>%
  dplyr::select(-overlap_result) %>% 
  filter(as.numeric(self_length) >= as.numeric(overlapping_max_length))
```

Check if we have overlapping DBDs of exactly same length:

```{r, include=T}
selected_overlapping_dbds %>%
  filter(as.numeric(overlapping_max_length) == as.numeric(self_length)) %>%
  dplyr::select(humantfs_gene_name,
                ensembl_gene_id,
                ensembl_transcript_id,
                ipr_accession,
                ipr_description,
                start,
                stop,
                overlapping_max_length,
                self_length) %>%
  arrange(ensembl_gene_id,
          ensembl_transcript_id,
          start,
          stop)
```

Yes, we do. So let us retain one match from the two overlapping ones. Let it be IPR041042 as a more specific-looking one:

```{r, include=T}
selected_overlapping_dbds = selected_overlapping_dbds %>%
  filter((ensembl_transcript_id != "ENST00000323684") | 
         (ipr_accession != "IPR013087") | 
         (start != 112) |
         (stop != 143))
```

Let us combine the whole table:

```{r, include=T}
selected_overlapping_dbds = selected_overlapping_dbds %>%
  dplyr::select(-overlapping_max_length, -self_length)
selected_unknown_others = tf_coding_transcripts_final_ens99_with_fam_names %>% 
  filter(is.na(domain_type) | (domain_type != "DBD")) %>%
  mutate(start = as.numeric(start)) %>%
  mutate(stop = as.numeric(stop))
tf_coding_transcripts_final_ens99_with_fam_names_corrected = selected_overlapping_dbds %>%
  bind_rows(selected_unknown_others)
```

Number of genes: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(ensembl_gene_id) %>% unique() %>% length()`.
Number of isoforms: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms without matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms with matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(db)) %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()`.
Number of signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(db)) %>% nrow()`.
Number of DBD signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(db)) %>% filter(domain_type == "DBD") %>% nrow()`.
Number of unique InterPro entries: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(ipr_accession) %>% unique() %>% length()`.
Number of specific InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).
Number of general InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(ipr_status == "general") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).

The number of genes, the total number of isoforms, the numbers of isoforms with and without matches did not change, which is correct. The numbers of InterPro entry matches, signature matches, unique InterPro entries and specific matches has decreased, which is expected. Finally, the numbers of general matches stayed the same, which is also correct.

The corrected table has `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(domain_type == "DBD") %>% nrow()` DBD signature matches (hence, `r (tf_coding_transcripts_final_ens99_with_fam_names %>% filter(domain_type == "DBD") %>% nrow()) - (tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(domain_type == "DBD") %>% nrow())` DBD signature matches were filtered out in overlaps).

```{r}
tf_coding_transcripts_final_ens99_with_fam_names_corrected.prev = tf_coding_transcripts_final_ens99_with_fam_names_corrected
```

## Classify DBDs into canonical and noncanonical

We call a DBD "canonical" if least one TF family is described on the basis of its presence. Otherwise, we call a DBD "noncanonical". I manually grouped DBD-related InterPro entries that represent the same TF family. Based on this grouping, we can classify DBDs into canonical and noncanonical.

Canonical DBD InterPro entries and the TF families they represent are:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  filter(!is.na(represents_family)) %>%
  dplyr::select(ipr_accession, ipr_description, represents_family) %>%
  arrange(represents_family, ipr_accession) %>%
  distinct()
```

The number of TF families these entries represent is `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(represents_family)) %>% pull(represents_family) %>% unique() %>% length()`. It is less than the number of TF families that we have from HumanTFs (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(DBD) %>% unique() %>% length()`), because HumanTFs has combined families (they are described based on the presence of more than one DBD).

Let us store the canonical DBD InterPro entries:

```{r, include=T}
canonical_dbd_iprs = tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  filter(!is.na(represents_family)) %>%
  dplyr::select(ipr_accession, ipr_description, represents_family) %>%
  arrange(represents_family, ipr_accession) %>%
  distinct() %>%
  pull(ipr_accession)
```

Noncanonical DBD InterPro entries (these domains can have other functions, apart from putative DNA binding, however, I prioritised their possible DNA binding role):

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  filter((domain_type == "DBD") & is.na(represents_family)) %>%
  dplyr::select(ipr_accession, ipr_description, represents_family) %>%
  arrange(represents_family, ipr_accession) %>%
  distinct()
```

Winged helix(-like) DBD superfamilies are, of course, a well known type of DBD fold, but it is very general and does not correspond to any particular family. That is why it is among noncanonical DBDs.

Let us store the noncanonical DBD InterPro entries:

```{r, include=T}
noncanonical_dbd_iprs = tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  filter((domain_type == "DBD") & is.na(represents_family)) %>%
  dplyr::select(ipr_accession, ipr_description, represents_family) %>%
  arrange(represents_family, ipr_accession) %>%
  distinct() %>%
  pull(ipr_accession)
```

Overall, there are `r canonical_dbd_iprs %>% length()` InterPro entries for canonical DBDs and `r noncanonical_dbd_iprs %>% length()` InterPro entries for noncanonical DBDs. The number of canonical DBD entries is greater than the number of TF families (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(DBD) %>% unique() %>% length()`), because some DBD types can be represented by several InterPro entries.

## Curate TF families

Currently, we have `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(DBD) %>% unique() %>% length()` TF families (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!stringr::str_detect(DBD, ";")) %>% filter(!DBD %in% c("Unknown", "Excluded")) %>% pull(DBD) %>% unique() %>% length()` of them are monotypical, i. e. are defined based on one DBD type, and `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(stringr::str_detect(DBD, ";")) %>% pull(DBD) %>% unique() %>% length()` are combined, i. e. defined based on the presence of several DBD types, and `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(DBD %in% c("Unknown", "Excluded")) %>% pull(DBD) %>% unique() %>% length()` is technical: "Unknown").

Let us check (and possibly curate) the assignment of TFs to families. Let Fam be a family to which a TF belongs according to HumanTFs (DBD column in the tf_coding_transcripts_final_ens99_with_fam_names_corrected table) and Post be a family to which it should belong according to the DBDs contained in its isoforms after the filtering and corrections. Then our strategy is as follows:

1) (Fam == Post) => no curation is necessary;

2) (Fam != Post) => check DBD matches before filtering and corrections and take actions accordingly.

Implementation:

```{r, include=T}
order_family_name = function(family_name) {
  dbd_type_vector = unlist(stringr::str_split(family_name, fixed("; ")))
  return(paste(unique(dbd_type_vector[order(dbd_type_vector)]), collapse="; "))
}
create_family_name = function(represents_family) {
  family_vector_ordered = unique(represents_family[order(represents_family)])
  family_vector_nona = family_vector_ordered[!is.na(family_vector_ordered)]
  return(paste(family_vector_nona, collapse="; "))
}
tf_curation_table = tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  dplyr::select(DBD, 
                ensembl_gene_id, 
                humantfs_gene_name,
                ensembl_transcript_id, 
                ipr_accession, 
                ipr_description,
                represents_family) %>%
  group_by(ensembl_gene_id) %>%
  do(mutate(., DBD_ordered = order_family_name(.$DBD))) %>%
  do(mutate(., represents_family_ordered = create_family_name(.$represents_family))) %>%
  ungroup() %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD_ordered, represents_family_ordered) %>%
  distinct() %>%
  arrange(ensembl_gene_id)
```

Now we can use this table to curate the TF assignment to families.

First of all, let us check if proteins from the Unknown family have any canonical DBDs (by the definition of the family, they should not). 

```{r, include=T}
tf_curation_table %>%
  filter(DBD_ordered == "Unknown") %>%
  pull(represents_family_ordered) %>%
  unique()
```

No, the Unknown family does not have any proteins with canonical DBD matches.

Next, let us look at the TFs not from the Unknown family, but still without canonical DBD matches. To make sure that we do not miss canonical DBD matches, we need to check the original scanning results for these genes (the results that were obtained before filtering and corrections):

```{r, include=T}
tf_domain_table_before_filtering = ips_domains_ipr_ens99_int_specific_retained %>%
  group_by(ensembl_gene_id) %>%
  arrange(ipr_accession) %>%
  dplyr::select(ipr_accession, ipr_description) %>%
  distinct() %>%
  do(mutate(., desc_combination = str_c(.$ipr_description, collapse = "_"))) %>%
  do(mutate(., ipr_combination = str_c(.$ipr_accession, collapse = "_"))) %>%
  dplyr::select(-ipr_accession, -ipr_description) %>%
  distinct() %>%
  ungroup()
kable(tf_curation_table %>%
  filter(DBD_ordered != "Unknown") %>%
  filter(represents_family_ordered == "") %>%
  arrange(DBD_ordered) %>%
  left_join(tf_domain_table_before_filtering,
            by = "ensembl_gene_id")) %>%
kable_styling(bootstrap_options = c("striped", "hover")) %>%
scroll_box(width = "100%")
```

Let us restore the following matches:

1) C2H2 ZF (IPR036236) in KIN (ENSG00000151657).

2) C2H2C ZF (IPR002515) in MYT1 (ENSG00000196132).

3) RHD DBD (IPR011539) and remove "Proto-oncogene c-Rel, RHD, N-terminal subdomain" (IPR042845) in REL (ENSG00000162924).

4) "Tesmin/TSO1-like CXC domain" (IPR033467) and remove the CRC domain (IPR005172) in LIN54 (ENSG00000189308).

Implementation:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names_corrected = 
  
  tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% 
  
  bind_rows(ips_domains_ipr_ens99_int_specific_retained %>%
            filter((ensembl_gene_id == "ENSG00000151657") & (ipr_accession == "IPR036236") & (db == "SUPERFAMILY")) %>%
            mutate(DBD = "C2H2 ZF", humantfs_gene_name = (humantfs %>% mutate(Ensembl.ID = as.character(Ensembl.ID)) %>% filter(Ensembl.ID == unique(ensembl_gene_id)) %>% pull(HGNC.symbol)),  domain_type = "DBD", ipr_status = "specific") %>%
            left_join(domain_classification_table, 
                      by = c("ipr_accession" = "ipr_accession",
                             "ipr_description" = "ipr_description",
                             "ENTRY_TYPE" = "ENTRY_TYPE")) %>%
            dplyr::select(-category)) %>%
  
  bind_rows(ips_domains_ipr_ens99_int_specific_retained %>%
            filter((ensembl_gene_id == "ENSG00000196132") & (ipr_accession == "IPR002515") & (db == "Pfam")) %>%
            mutate(DBD = "C2H2 ZF", humantfs_gene_name = (humantfs %>% mutate(Ensembl.ID = as.character(Ensembl.ID)) %>% filter(Ensembl.ID == unique(ensembl_gene_id)) %>% pull(HGNC.symbol)), domain_type = "DBD", ipr_status = "specific") %>%
            left_join(domain_classification_table, 
                      by = c("ipr_accession" = "ipr_accession",
                             "ipr_description" = "ipr_description",
                             "ENTRY_TYPE" = "ENTRY_TYPE")) %>%
            dplyr::select(-category)) %>%
  
  bind_rows(ips_domains_ipr_ens99_int_specific_retained %>%
            filter((ensembl_gene_id == "ENSG00000162924") & (ipr_accession == "IPR011539") & (db == "ProSiteProfiles")) %>%
            mutate(DBD = "Rel", humantfs_gene_name = (humantfs %>% mutate(Ensembl.ID = as.character(Ensembl.ID)) %>% filter(Ensembl.ID == unique(ensembl_gene_id)) %>% pull(HGNC.symbol)), domain_type = "DBD", ipr_status = "specific") %>%
            left_join(domain_classification_table, 
                      by = c("ipr_accession" = "ipr_accession",
                             "ipr_description" = "ipr_description",
                             "ENTRY_TYPE" = "ENTRY_TYPE")) %>%
            dplyr::select(-category)) %>%
  
  filter((ensembl_gene_id != "ENSG00000162924") | (ipr_accession != "IPR042845")) %>%
  
  bind_rows(ips_domains_ipr_ens99_int_specific_retained %>%
            filter((ensembl_gene_id == "ENSG00000189308") & (ipr_accession == "IPR033467") & (db == "SMART")) %>%
            mutate(DBD = "TCR/CxC", humantfs_gene_name = (humantfs %>% mutate(Ensembl.ID = as.character(Ensembl.ID)) %>% filter(Ensembl.ID == unique(ensembl_gene_id)) %>% pull(HGNC.symbol)), domain_type = "DBD", ipr_status = "specific") %>%
            left_join(domain_classification_table, 
                      by = c("ipr_accession" = "ipr_accession",
                             "ipr_description" = "ipr_description",
                             "ENTRY_TYPE" = "ENTRY_TYPE")) %>%
            dplyr::select(-category)) %>%
  
  filter((ensembl_gene_id != "ENSG00000189308") | (ipr_accession != "IPR005172"))
```

Add the restored InterPro entries to the list of canonical DBDs, in case they were not there:

```{r, include=T}
canonical_dbd_iprs = unique(c(canonical_dbd_iprs, "IPR036236", "IPR002515", "IPR011539", "IPR033467"))
```

Let us also move the following TFs into the Unknown family:

1) ZNF804A (ENSG00000170396) and ZNF804B (ENSG00000182348), as their C2H2 ZF matches (IPR036236, IPR013087) overlap with a dsRNA-binding zinc-finger domain (IPR022755).

2) MYSM1 (ENSG00000162601), as the SANT/Myb domain (IPR001005) in it overlaps with a more specific SANT domain (IPR001005) which in turn is not a DBD, according to the InterPro entry description.

3) SKOR2 (ENSG00000215474), as it has a SAND-like domain (IPR010919), but SAND domain binding motifs (http://jaspar.genereg.net/search?q=sand&collection=all&tax_group=all&tax_id=all&type=all&class=all&family=all&version=all) do not resembl a putative SKOR2 binding motif (http://jaspar.genereg.net/matrix/UN0136.1/), and additionally SKOR2 has a SKI-like DBD which does not correspond to any family in our analysis.

Implementation:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names_corrected = 
  tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  mutate(DBD = ifelse(ensembl_gene_id == "ENSG00000170396", "Unknown", DBD)) %>%
  mutate(DBD = ifelse(ensembl_gene_id == "ENSG00000182348", "Unknown", DBD)) %>%
  mutate(DBD = ifelse(ensembl_gene_id == "ENSG00000162601", "Unknown", DBD)) %>%
  mutate(DBD = ifelse(ensembl_gene_id == "ENSG00000215474", "Unknown", DBD))
```

Let us exclude all other proteins without relevant DBD matches from the analysis. For this, let us put them in a separate technical family "Excluded":

```{r, include=T}
gene_ids_to_exclude = tf_curation_table %>%
  filter(DBD_ordered != "Unknown") %>%
  filter(represents_family_ordered == "") %>%
  arrange(DBD_ordered) %>%
  filter(!ensembl_gene_id %in% c("ENSG00000151657", # KIN
                                 "ENSG00000196132", # MYT1
                                 "ENSG00000162924", # REL
                                 "ENSG00000189308", # LIN54
                                 "ENSG00000170396", # ZNF804A
                                 "ENSG00000182348", # ZNF804B
                                 "ENSG00000162601", # MYSM1
                                 "ENSG00000215474")) %>% # SKOR2
  pull(ensembl_gene_id)
tf_coding_transcripts_final_ens99_with_fam_names_corrected = 
  tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  mutate(DBD = ifelse(ensembl_gene_id %in% gene_ids_to_exclude, "Excluded", DBD))
```

Next, check if there are TFs that have fewer canonical DBD types than their family implies. For such TFs, check that we did not lose the relevant canonical DBD matches during the filtering and corrections:

```{r, include=T}
fewer_dbd_types = function(tf_fam_str, tf_dbds_str) {
  tf_fam = unlist(stringr::str_split(tf_fam_str, fixed("; ")))
  tf_dbds = unlist(stringr::str_split(tf_dbds_str, fixed("; ")))
  if ((length(setdiff(tf_fam, tf_dbds)) > 0) &
      (length(setdiff(tf_dbds, tf_fam)) == 0)) {
    return(T)
  } else {
    return(F)
  }
}
tfs_to_move_table = tf_curation_table %>% 
  group_by(ensembl_gene_id) %>%
  do(filter(., fewer_dbd_types(.$DBD_ordered, .$represents_family_ordered))) %>%
  ungroup() %>%
  left_join(tf_domain_table_before_filtering,
            by = "ensembl_gene_id")
kable(tfs_to_move_table) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

We did not lose any DBD types during the filtering and corrections, so now we need to move these TFs into families corresponding to the DBDs that are present in them:

```{r, include=T}
take_represents_family_ordered = function(gene_id) {
  represents_family_ordered_str = tfs_to_move_table %>%
    filter(ensembl_gene_id == gene_id) %>%
    pull(represents_family_ordered)
  return(represents_family_ordered_str)
}
tfs_to_move_ids = tfs_to_move_table %>%
  pull(ensembl_gene_id) %>%
  unique()
tf_coding_transcripts_final_ens99_with_fam_names_corrected = 
  tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  group_by(ensembl_gene_id) %>%
  mutate(DBD = ifelse(ensembl_gene_id %in% tfs_to_move_ids,
                      take_represents_family_ordered(unique(ensembl_gene_id)),
                      DBD)) %>%
  ungroup()
```

Next, check if there are TFs that have more canonical DBD types than their family implies. Move such TFs, if any, to the appropriate families:

```{r, include=T}
more_dbd_types = function(tf_fam_str, tf_dbds_str) {
  tf_fam = unlist(stringr::str_split(tf_fam_str, fixed("; ")))
  tf_dbds = unlist(stringr::str_split(tf_dbds_str, fixed("; ")))
  if ((length(setdiff(tf_fam, tf_dbds)) == 0) &
      (length(setdiff(tf_dbds, tf_fam)) > 0)) {
    return(T)
  } else {
    return(F)
  }
}
tfs_to_move_table = tf_curation_table %>% 
  group_by(ensembl_gene_id) %>%
  do(filter(., more_dbd_types(.$DBD_ordered, .$represents_family_ordered))) %>%
  ungroup()
tfs_to_move_table
```

Move these TFs into families that match their DBD type combinations:

```{r, include = T}
take_represents_family_ordered = function(gene_id) {
  represents_family_ordered_str = tfs_to_move_table %>%
    filter(ensembl_gene_id == gene_id) %>%
    pull(represents_family_ordered)
  return(represents_family_ordered_str)
}
tfs_to_move_ids = tfs_to_move_table %>%
  pull(ensembl_gene_id) %>%
  unique()
tf_coding_transcripts_final_ens99_with_fam_names_corrected = 
  tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  group_by(ensembl_gene_id) %>%
  mutate(DBD = ifelse(ensembl_gene_id %in% tfs_to_move_ids,
                      take_represents_family_ordered(unique(ensembl_gene_id)),
                      DBD)) %>%
  ungroup()
```

Next, check if we have TFs whose DBDs only partially reflect their family assignment:

```{r, include=T}
diff_dbd_types = function(tf_fam_str, tf_dbds_str) {
  tf_fam = unlist(stringr::str_split(tf_fam_str, fixed("; ")))
  tf_dbds = unlist(stringr::str_split(tf_dbds_str, fixed("; ")))
  if (unique(tf_dbds == c(""))) {
    tf_dbds = c()
  }
  if ((length(setdiff(tf_fam, tf_dbds)) > 0) &
      (length(setdiff(tf_dbds, tf_fam)) > 0)) {
    return(T)
  } else {
    return(F)
  }
}
tfs_diff_table = tf_curation_table %>% 
  group_by(ensembl_gene_id) %>%
  do(filter(., diff_dbd_types(.$DBD_ordered, .$represents_family_ordered))) %>%
  ungroup() %>%
  left_join(tf_domain_table_before_filtering,
            by = "ensembl_gene_id")
kable(tfs_diff_table) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

So, we did not lose the missing canonical DBDs due to filtering and corrections, and hence we need to move these TFs to the families corresponding to their present canonical DBDs:

```{r, include=T}
take_diff_represents_family_ordered = function(gene_id) {
  represents_family_ordered_str = tfs_diff_table %>%
    filter(ensembl_gene_id == gene_id) %>%
    pull(represents_family_ordered)
  return(represents_family_ordered_str)
}
tfs_diff_to_move_ids = tfs_diff_table %>%
  pull(ensembl_gene_id)
tf_coding_transcripts_final_ens99_with_fam_names_corrected = tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  group_by(ensembl_gene_id) %>%
  mutate(DBD = ifelse(ensembl_gene_id %in% tfs_diff_to_move_ids,
                      take_diff_represents_family_ordered(unique(ensembl_gene_id)),
                      DBD)) %>%
  ungroup()
```

Finally, let us order DBD names alphabetically in all family names:

```{r, include=T}
order_family_name = function(family_name) {
  dbd_type_vector = unlist(stringr::str_split(family_name, fixed("; ")))
  return(paste(unique(dbd_type_vector[order(dbd_type_vector)]), collapse="; "))
}
tf_coding_transcripts_final_ens99_with_fam_names_corrected = tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  group_by(ensembl_gene_id) %>%
  do(mutate(., DBD = order_family_name(.$DBD))) %>%
  ungroup()
```

Number of genes: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(ensembl_gene_id) %>% unique() %>% length()`.
Number of isoforms: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms without matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms with matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(db)) %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()`.
Number of signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(db)) %>% nrow()`.
Number of DBD signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!is.na(db)) %>% filter(domain_type == "DBD") %>% nrow()`.
Number of unique InterPro entries: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(ipr_accession) %>% unique() %>% length()`.
Number of specific InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).
Number of general InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(ipr_status == "general") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).

The number of genes, the total number of isoforms, the numbers of isoforms with and without matches did not change, which is correct. The numbers of InterPro entry matches, specific InterPro entry matches and specific DBD entry matches increased, because we restored more specific domains then removed. The number of specific DBD entry matches increased more than the overall number of specific InterPro entry matches, because we restored some DBD matches and removed some specific matches of other types (I think that for the same reason the number of DBD signature matches increased). Finally, the numbers of general matches stayed the same, which is correct.

After the curation, we have `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% pull(DBD) %>% unique() %>% length()` TF families (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!stringr::str_detect(DBD, ";")) %>% filter(!DBD %in% c("Unknown", "Excluded")) %>% pull(DBD) %>% unique() %>% length()` of them are monotypical, i. e. are defined based on one DBD type, and `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(stringr::str_detect(DBD, ";")) %>% pull(DBD) %>% unique() %>% length()` are combined, i. e. defined based on the presence of several DBD types, and `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(DBD %in% c("Unknown", "Excluded")) %>% pull(DBD) %>% unique() %>% length()` are technical: "Unknown" and "Excluded").

The number of monotypical families decreased as the following families were excluded:

```{r, include=T}
setdiff(tf_coding_transcripts_final_ens99_with_fam_names_corrected.prev %>%
          filter(!stringr::str_detect(DBD, ";")) %>% 
          filter(!DBD %in% c("Unknown", "Excluded")) %>% 
          pull(DBD) %>% 
          unique(), 
        tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
          filter(!stringr::str_detect(DBD, ";")) %>% 
          filter(!DBD %in% c("Unknown", "Excluded")) %>% 
          pull(DBD) %>% 
          unique())
```

MADF was merged with Myb/SANT; mTERF was excluded as there were no DBD matches in the mTERF proteins; and CENPB and Brinker became part of combined families (see below). 

Overall, we have the following monotypical families:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  filter(!stringr::str_detect(DBD, ";")) %>% 
  filter(!DBD %in% c("Unknown", "Excluded")) %>% 
  dplyr::select(DBD) %>%
  arrange(DBD) %>%
  pull(DBD) %>% 
  unique()
```

and the following combined families:

```{r}
tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  filter(stringr::str_detect(DBD, ";")) %>% 
  dplyr::select(DBD) %>%
  arrange(DBD) %>%
  pull(DBD) %>% 
  unique()
```

Number of TFs in these families: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!DBD %in% c("Unknown", "Excluded")) %>% pull(ensembl_gene_id) %>% unique() %>% length()`.

Number of TF isoforms in these families: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected %>% filter(!DBD %in% c("Unknown", "Excluded")) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.

## Filter isoforms by the Transcript Support Level

Finally, let us filter TF isoforms by the Transcript Support Level:

```{r, include=T}
ensembl = useEnsembl(biomart = "ensembl",
                     dataset = "hsapiens_gene_ensembl",
                     version = "99")
# ensg_enst_tsl = getBM(attributes = c("ensembl_gene_id",
#                                      "ensembl_transcript_id",
#                                      "transcript_tsl",
#                                      "transcript_gencode_basic",
#                                      "transcript_appris",
#                                      "transcript_mane_select",
#                                      "ccds"),
#                       filters = "transcript_biotype",
#                       values = "protein_coding",
#                       mart = ensembl)
# write.table(ensg_enst_tsl,
#             file = "data/ensembl99/ensg_enst_tsl_99.tsv",
#             quote = F, sep = "\t", row.names = F)

ensg_enst_tsl = read.delim("data/ensembl99/ensg_enst_tsl_99.tsv",
                           stringsAsFactors = F) %>%
  dplyr::select(ensembl_gene_id,
                ensembl_transcript_id,
                transcript_tsl,
                transcript_mane_select,
                transcript_gencode_basic,
                transcript_appris,
                ccds) %>%
  arrange(ensembl_gene_id,
          ensembl_transcript_id)

tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl = 
tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  left_join(ensg_enst_tsl,
            by = c("ensembl_gene_id" = "ensembl_gene_id",
                   "ensembl_transcript_id" = "ensembl_transcript_id")) %>%
  group_by(ensembl_gene_id, ensembl_transcript_id) %>%
  mutate(transcript_tsl_code = unlist(stringr::str_split(transcript_tsl, fixed(" ")))[1]) %>%
  ungroup() %>%
  filter((transcript_tsl_code == "tsl1") | 
         (transcript_tsl_code == "tsl2") | 
         (transcript_tsl_code == "tslNA") | 
         (transcript_mane_select != ""))

write.table(tf_coding_transcripts_final_ens99_with_fam_names_corrected,
            file = "data/results/domain_analysis/tf_coding_transcripts_final_ens99_with_fam_names_corrected.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

write.table(tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl,
            file = "data/results/domain_analysis/tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Let us see which TFs we lost after the isoform filtering:

```{r}
diff.vector = setdiff(tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
                        filter(DBD != "Unknown") %>%
                        filter(DBD != "Excluded") %>%
                        pull(humantfs_gene_name) %>%
                        unique(),
                      tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
                        filter(DBD != "Unknown") %>%
                        filter(DBD != "Excluded") %>%
                        pull(humantfs_gene_name) %>%
                        unique())
lost.tf.table = tf_coding_transcripts_final_ens99_with_fam_names_corrected %>%
  left_join(ensg_enst_tsl,
            by = c("ensembl_gene_id" = "ensembl_gene_id",
                   "ensembl_transcript_id" = "ensembl_transcript_id")) %>%
  group_by(ensembl_gene_id, ensembl_transcript_id) %>%
  mutate(transcript_tsl_code = unlist(stringr::str_split(transcript_tsl, fixed(" ")))[1]) %>%
  ungroup() %>%
  filter(humantfs_gene_name %in% diff.vector) %>%
  dplyr::select(ensembl_gene_id, 
                humantfs_gene_name, 
                DBD, 
                ensembl_transcript_id, 
                transcript_tsl,
                transcript_tsl_code,
                transcript_mane_select,
                transcript_gencode_basic,
                transcript_appris,
                ccds) %>%
  dplyr::rename(Family = DBD) %>%
  arrange(Family, humantfs_gene_name) %>%
  distinct()
write.table(lost.tf.table,
            file = "data/results/lost_tf_table_tsl1_tsl2_tslNA_mane.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

So we lost those TFs for further analysis (here we do not count proteins lost from the "Unknown" or "Excluded" families):

```{r, include=T}
diff.vector
```

The majority of them are described very briefly in UniProtKB and GeneCards, and there are only `r length(diff.vector)` of them. So this is fine.

Number of genes: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% pull(ensembl_gene_id) %>% unique() %>% length()`.
Number of isoforms: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms without matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of isoforms with matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(!is.na(db)) %>% pull(ensembl_transcript_id) %>% unique() %>% length()`.
Number of InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(!is.na(db)) %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()`.
Number of signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(!is.na(db)) %>% nrow()`.
Number of DBD signature matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(!is.na(db)) %>% filter(domain_type == "DBD") %>% nrow()`.
Number of unique InterPro entries: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% pull(ipr_accession) %>% unique() %>% length()`.
Number of specific InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(ipr_status == "specific") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(ipr_status == "specific") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).
Number of general InterPro entry matches: `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(ipr_status == "general") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` (`r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(ipr_status == "general") %>% filter(domain_type == "DBD") %>% group_by(ensembl_transcript_id) %>% dplyr::select(ipr_accession) %>% distinct() %>% ungroup() %>% pull(ipr_accession) %>% length()` of which are DBD matches).

Number of TF families (total): `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% pull(DBD) %>% unique() %>% length()`.

Number of TF families (monotypical,  i. e. are defined based on one DBD type): `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(!stringr::str_detect(DBD, ";")) %>% filter(!DBD %in% c("Unknown", "Excluded")) %>% pull(DBD) %>% unique() %>% length()`.

Number of TF families (combined, i. e. defined based on the presence of several DBD types): `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(stringr::str_detect(DBD, ";")) %>% pull(DBD) %>% unique() %>% length()`.

Number of technical families ("Unknown" and "Excluded"): `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(DBD %in% c("Unknown", "Excluded")) %>% pull(DBD) %>% unique() %>% length()`.

So, after the isoform filtering, the number of isoforms decreased dramatically, and the vast majority of them now contain domain matches. The number of transcription factors also decreased, but just a little bit. The total number of families, as well as the numbers of monotypical and combined families, stay the same, which is good (we did not lose any families completely).

## Positive control: Check known examples of domain changes in alternative isoforms

Generate a comparison table using Ensembl gene ID:

```{r, include=T}
compare_transcripts = function(gene_id) {
  gene_table = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
    filter(ensembl_gene_id == gene_id)
  comparison_table = gene_table %>%
    dplyr::select(humantfs_gene_name, ensembl_gene_id, ipr_description, ipr_accession, domain_type) %>%
    distinct()
  gene_transcripts = gene_table %>% pull(ensembl_transcript_id) %>% unique()
  for (tx in gene_transcripts) {
    domain_counts = gene_table %>%
      filter(ensembl_transcript_id == tx) %>%
      dplyr::select(ipr_accession) %>%
      group_by(ipr_accession) %>%
      mutate(n = n()) %>%
      distinct()
    domain_counts[tx] = domain_counts$n
    domain_counts = domain_counts %>%
      dplyr::select(-n)
    comparison_table = comparison_table %>%
      left_join(domain_counts, by = c("ipr_accession"))
  }
  comparison_table = comparison_table %>%
    mutate_at(vars(-c("humantfs_gene_name",
                      "ensembl_gene_id",
                      "ipr_description",
                      "ipr_accession",
                      "domain_type")), 
              ~replace(., is.na(.), 0))
  return(comparison_table)
}
```

1) **TEAD4**:

TEAD4-FL is a full isoform with a DBD and a YAP-binding domains; TEAD4-S is a short isoform without DBD but with a YAP-binding domain. TEAD4-FL binds YAP and DNA and promotes Hippo-YAP signalling and hence - tissue growth. TEAD4-S competes with TEAD-FL for YAP binding and cannot bind to DNA, in this way blocking the Hippo-YAP signalling pathway ([Qi et al., 2016](https://www.nature.com/articles/ncomms11840)).

```{r, include=T}
kable(compare_transcripts("ENSG00000197905")) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

TEAD4-S could be represented by ENST00000397122.

2) **REST**:

The full isoform of this TF has 9 C2H2 ZFs, as well as an N-terminal and a C-terminal repressor domains, and represses neurogenesis. However, insertion of an exon specific to neural cells leads to the production of a truncated isoform (REST4) which is unable to bind DNA; REST4 "lacks four zinc fingers and a C-terminal repressor domain, both of which are required for full DNA-binding and repressive activity of REST." Expression of REST4 leads to the activation of REST target genes in neural cells which determines neurogenesis, while expression of the full REST protein inhibits neurogenesis genes ([Raj et al., 2011](https://www.sciencedirect.com/science/article/pii/S1097276511006320?via%3Dihub)).

```{r, include=T}
kable(compare_transcripts("ENSG00000084093")) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

Although all isoforms of REST above lack repressor domains, two of these isoforms contain 5 C2H2 ZF matches, like REST4, and two of them contain all 9 matches.

Let us check the original scanning results for this TF to see if they have the repressor domains:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained %>%
  filter(ensembl_gene_id == "ENSG00000084093") %>%
  dplyr::select(ipr_accession, ipr_description, db) %>% 
  arrange(ipr_accession) %>% 
  distinct()) %>%
kable_styling(bootstrap_options = c("striped", "hover")) %>%
scroll_box(width = "100%")
```

No repressor domains either. So these domains (shown in ([Raj et al., 2011](https://www.sciencedirect.com/science/article/pii/S1097276511006320?via%3Dihub)), Fig. 2a) are probably just not represented in InterPro.

3) **CREM**:

The activating isoforms of this TF are transcribed from a GC-rich noninducible promoter P1 and have an activation domain (P-box, or KID, kinase-inducible domain) surrounded by glutamine-rich regions Q1 and Q2 (they may contact basal transcription machinery), and a bZIP DBD (which is also a dimerisation domain). Repressor isoforms produced from the same promoter either lack Q1 and Q2 due to alternative splicing or the P-box and one of the Q-regions - due to alternative translation start usage. Another set of repressors, called ICERs (inducible cAMP early repressors) are transcribed from a cAMP-inducible promoter P2. They completely lack the P-box, as well as Q1 and Q2, but retain, fully or partially, the bZIP DBD. The activation isoforms get activated themselves by phosphorylation of their P-box domain. ICERs have circadian pattern of expression in the pineal gland ([de Cesare and Sassoni-Corsi, 2000](https://pubmed.ncbi.nlm.nih.gov/10697414-transcriptional-regulation-by-cyclic-amp-responsive-factors/)). Switch from inhibitory to activating CREM isoforms regulates spermatogenesis (an activating CREM-tau isoform is expressed only in postmeiotic germ cells ([Delmas et al., 1993](https://pubmed.ncbi.nlm.nih.gov/8114765-induction-of-crem-activator-proteins-in-spermatids-down-stream-targets-and-implications-for-haploid-germ-cell-differentiation/)).

```{r, include=T}
kable(compare_transcripts("ENSG00000095794")) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

Although, no isoforms show Q1 and Q2 regions, some of these isoforms can code for the full activation or repressor variants, where both P-box and bZIP domains are present, and some other may code for ICERs - where the P-box is lost. Interestingly, there is also an isoform that has the activation domain but not the DBD. If it is indeed translated, it could get phophorylated and bind cofactors, competing in this way with the full isoform. 

Check that we did not lose possible Q1 and Q2 region matches in the filtering procedure:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained %>%
  filter(ensembl_gene_id == "ENSG00000095794") %>%
  dplyr::select(ipr_accession, ipr_description, db) %>% 
  arrange(ipr_accession) %>% 
  distinct()) %>%
kable_styling(bootstrap_options = c("striped", "hover")) %>%
scroll_box(width = "100%")
```

No matches of the Q regions. So probably they are not represented in InterPro.

4) **MZF1**:

It is a transcription activator in hematopoetic cells and transcription repressor in all other cell types. According to a recent review ([Brix et al., 2020](https://www.mdpi.com/2073-4409/9/1/223/htm), Fig. 1), MZF1 has three isoforms. The full one contains an acidic domain (A) involved in transcription activation and protein-protein interactions, a SCAN domain (allows dimerisation), a TAD and 13 zinc-finger domains. A shorter isofom contains only the TAD (or its part) and the zinc-finger domains, while an even shorter one contains only the N-terminal part of the full protein (i. e., A and SCAN). A possible function of the latter isoform has not yet been elucidated.

```{r, include=T}
kable(compare_transcripts("ENSG00000099326")) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%")
```

Although there are no A domains or TADs matched in the MZF1 isoforms, the full and the shortest isoforms are essentially recovered. It is strange that there is no zinc finger-only isoform. However, this should be due to Ensembl annotation properties, because we do not have MZF1 isoforms without any matches where zinc fingers could be lost during the filtration and corection procedures; additionally, all isoforms have the SCAN domain which should be absent in zinc finger-only isoforms.

Let us check that we did not lose A domains and TADs:

```{r, include=T}
kable(ips_domains_ipr_ens99_int_specific_retained %>%
  filter(ensembl_gene_id == "ENSG00000099326") %>%
  dplyr::select(ipr_accession, ipr_description, db) %>% 
  arrange(ipr_accession) %>% 
  distinct()) %>%
kable_styling(bootstrap_options = c("striped", "hover")) %>%
scroll_box(width = "100%")
```

No A domain or TAD either. So, they are probably not represented in InterPro.

Overall, known TF isoforms retaining or lacking certain domains are present in the final table.

# Analysis

Let us include in the analysis only canonical DBDs: they correspond to families and comprise the vast majority of all DBD signature matches (`r (tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(ipr_accession %in% canonical_dbd_iprs) %>% nrow()) / (tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(domain_type == "DBD") %>% nrow()) * 100`%).

Hence, everywhere below, unless otherwise stated, "DBD" means "canonical DBD". We also exclude the "Unknown" and "Excluded" families. 

## Generate Table S3

Generate Table S3 as a TSV file:

```{r}
table_s3 = read.delim("results/domains/tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl.tsv",
                      header = T) %>%
  filter(DBD != "Excluded") %>%
  filter(DBD != "Unknown") %>%
  dplyr::select(humantfs_gene_name,
                DBD, # tf_family
                ensembl_gene_id,
                ensembl_transcript_id,
                transcript_tsl,
                transcript_tsl_code,
                transcript_mane_select,
                transcript_gencode_basic,
                transcript_appris,
                ccds,
                protein_accession,
                seq_md5,
                seq_len,
                db,
                domain_accession,
                domain_description,
                start,
                stop,
                evalue,
                status,
                run_date,
                ipr_accession, # interpro_entry
                ipr_description, # interpro_entry_name
                int_start, # integrated_start
                int_stop, # integrated_stop
                ENTRY_TYPE, # entry_type
                ipr_status, # interpro_entry_match_status
                ipr_ancestor, # interpro_entry_ancestor
                domain_type,
                represents_family) %>%
  dplyr::rename("tf_family" = "DBD",
                "interpro_entry" = "ipr_accession",
                "interpro_entry_name" = "ipr_description",
                "integrated_start" = "int_start",
                "integrated_stop" = "int_stop",
                # good from here
                "entry_type" = "ENTRY_TYPE",
                "interpro_entry_match_status" = "ipr_status",
                "interpro_entry_ancestor" = "ipr_ancestor")

write.table(table_s3,
            "results/domains/supplementary_table_3.tsv",
            quote = F, 
            sep = "\t",
            row.names = F,
            col.names = T)

```

## Assess DBD presence and absence in TF isoforms

Alternative splicing can potentially remove all DBDs from a TF. So let us find how many TFs have at least one isoform without DBDs.

Create a table showing which TFs have at least one isoform without DBDs:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl = read.delim("data/results/tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl.tsv",
            header = T)

dbd_yes_no_gene_table = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(DBD != "Unknown") %>%
  filter(DBD != "Excluded") %>%
  mutate(is_canonical = ifelse(!is.na(represents_family), T, F)) %>%
  group_by(ensembl_transcript_id) %>%
  mutate(n_canonical = length(is_canonical[is_canonical])) %>%
  ungroup() %>%
  dplyr::select(-is_canonical) %>%
  group_by(ensembl_gene_id) %>%
  mutate(are_all_isoforms_with_dbds = ifelse(!0 %in% n_canonical, T, F)) %>%
  ungroup() %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD, are_all_isoforms_with_dbds) %>%
  distinct()

saveRDS(dbd_yes_no_gene_table,
        "data/results/dbd_yes_no_gene_table.rds")
```

Plot the TF frequencies:

```{r, echo=F, fig.width=15, fig.height=5}
count_genes = function(domain_type) {
  return(dbd_gene_counts %>%
    filter(dbd == domain_type) %>%
    pull(n))
}

dbd_gene_counts = dbd_yes_no_gene_table %>%
  dplyr::select(ensembl_gene_id, DBD) %>%
  distinct() %>%
  dplyr::count(DBD) %>%
  dplyr::rename("dbd" = "DBD") %>%
  mutate(dbd = as.character(dbd))

tf.families = dbd_gene_counts %>%
  pull(dbd)

tf.family.count = length(tf.families)

tf.families.num = unlist(purrr::map(tf.families,
                             function(d) {
                               paste0(d, " (", as.character(count_genes(d)), ")")
                             }))

dbd.presence.frequencies = data.frame(family = character(),
                                      present.frequency = numeric(),
                                      absent.frequency = numeric())

for (tf.family in tf.families) { 
  dbd.present.count = dbd_yes_no_gene_table %>%
    filter(DBD == tf.family) %>%
    filter(are_all_isoforms_with_dbds) %>%
    nrow()
  dbd.absent.count = dbd_yes_no_gene_table %>%
    filter(DBD == tf.family) %>%
    filter(!are_all_isoforms_with_dbds) %>%
    nrow()
  total.count = dbd.present.count + dbd.absent.count
  dbd.presence.frequencies = dbd.presence.frequencies %>%
    bind_rows(c("family" = tf.family))
  dbd.presence.frequencies = dbd.presence.frequencies %>%
    mutate(present.frequency = ifelse(family == tf.family, dbd.present.count / total.count, present.frequency)) %>%
    mutate(absent.frequency = ifelse(family == tf.family, dbd.absent.count / total.count, absent.frequency))
}

dbd.presence.frequencies = dbd.presence.frequencies %>%
  bind_cols("family.num" = tf.families.num)

dbd.presence.frequencies = dbd.presence.frequencies %>%
  arrange(absent.frequency)

tf.families.ordered = dbd.presence.frequencies$family.num

dbd.presence.frequencies$family.num = factor(dbd.presence.frequencies$family.num, 
                                             levels = dbd.presence.frequencies$family.num)

dbd.presence.frequencies.tfs = dbd.presence.frequencies %>%
  arrange(family)

dbd.presence.absence.tf.frequencies = data.frame("Category" = c(rep("Some isoforms without DBD", tf.family.count),
                                                                rep("All isoforms with DBD", tf.family.count)),
                                                 "Frequency" = c(dbd.presence.frequencies$absent.frequency,
                                                                 dbd.presence.frequencies$present.frequency),
                                                 "Family" = rep(dbd.presence.frequencies$family.num, 2)) %>%
  mutate(Category = factor(Category, levels = c("Some isoforms without DBD",
                                                 "All isoforms with DBD")))

ggplot(data = dbd.presence.absence.tf.frequencies,
       aes(x = Family, y = Frequency, group = Family)) +
  geom_col(aes(fill = Category)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

After the family names, in parentheses, we show the number of TFs in each family.

```{r, include=T}
#kable(
dbd.presence.frequencies.summary = dbd.presence.frequencies %>%
  left_join(dbd_gene_counts, by = c("family" = "dbd")) %>%
  dplyr::select(family, family.num, absent.frequency) %>%
  left_join(tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
              group_by(DBD) %>%
              mutate(n_genes = length(unique(ensembl_gene_id))) %>%
              ungroup(),
            by = c("family" = "DBD")) %>%
  dplyr::select(family.num, absent.frequency, n_genes) %>%
  distinct() %>%
  arrange(dplyr::desc(n_genes)) %>%
  filter(n_genes >= 5)

dbd.presence.frequencies.summary
# ) %>%
# kable_styling(bootstrap_options = c("striped", "hover")) %>%
#   scroll_box(width = "100%")  
```

Find top 5 biggest differences in the % of DBD- isoforms between TF families with a comparable total number of isoforms (differing by no more than 20% of the bigger number):

```{r, include=T}
diff.cutoff.fraction = 0.2

dbd.presence.frequencies.diff = data.frame(family.num1 = character(),
                                           family.num2 = character(),
                                           absent.frequency1 = numeric(),
                                           absent.frequency2 = numeric(),
                                           absent.frequency.ratio = numeric(),
                                           n_genes1 = integer(),
                                           n_genes2 = integer())

for (i in 1:(nrow(dbd.presence.frequencies.summary) - 1)) {
  diff.cutoff = diff.cutoff.fraction * dbd.presence.frequencies.summary[i, "n_genes"]
  for (j in (i + 1):(nrow(dbd.presence.frequencies.summary))) {
    if (dbd.presence.frequencies.summary[i, "n_genes"] - 
        dbd.presence.frequencies.summary[j, "n_genes"] < diff.cutoff) {
      dbd.presence.frequencies.diff = bind_rows(dbd.presence.frequencies.diff,
                                                data.frame(family.num1 = dbd.presence.frequencies.summary[i, "family.num"],
                                                           family.num2 = dbd.presence.frequencies.summary[j, "family.num"],
                                                           absent.frequency1 = dbd.presence.frequencies.summary[i, "absent.frequency"],
                                                           absent.frequency2 = dbd.presence.frequencies.summary[j, "absent.frequency"],
                                                           absent.frequency.ratio = dbd.presence.frequencies.summary[j, "absent.frequency"] / dbd.presence.frequencies.summary[i, "absent.frequency"],
                                                           n_genes1 = dbd.presence.frequencies.summary[i, "n_genes"],
                                                           n_genes2 = dbd.presence.frequencies.summary[j, "n_genes"]))
    } else {
      break
    }
  }
}

dbd.presence.frequencies.diff = dbd.presence.frequencies.diff %>%
  arrange(absent.frequency.ratio)

dbd.presence.frequencies.diff %>%
  filter(absent.frequency1 > 0.2) %>%
  filter(n_genes1 > 10) #%>%
  #head(5)
```

Test and plot the differences.

First comparison:

```{r, include=T}
c2h2_hom.absent.freq = dbd.presence.frequencies.diff %>%
  filter(family.num1 == "C2H2 ZF; Homeodomain (13)") %>%
  pull(absent.frequency1) %>%
  unique()

c2h2_hom.present.freq = 1 - c2h2_hom.absent.freq

cat("The number of TF genes with all isoforms DBD+ (C2H2 ZF; Homeodomain):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "C2H2 ZF; Homeodomain") %>%
      filter(are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

cat("The number of TF genes with at least one DBD- isoform (C2H2 ZF; Homeodomain):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "C2H2 ZF; Homeodomain") %>%
      filter(!are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

thap.absent.freq = dbd.presence.frequencies.diff %>%
  filter(family.num1 == "THAP finger (12)") %>%
  pull(absent.frequency1) %>%
  unique()

thap.present.freq = 1 - thap.absent.freq

cat("The number of TF genes with all isoforms DBD+ (THAP finger):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "THAP finger") %>%
      filter(are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

cat("The number of TF genes with at least one DBD- isoform (THAP finger):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "THAP finger") %>%
      filter(!are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

cenpb.absent.freq = dbd.presence.frequencies.diff %>%
  filter(family.num2 == "CENPB; Pipsqueak (11)") %>%
  pull(absent.frequency2) %>%
  unique()

cenpb.present.freq = 1 - cenpb.absent.freq

cat("The number of TF genes with all isoforms DBD+ (CENPB; Pipsqueak):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "CENPB; Pipsqueak") %>%
      filter(are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

cat("The number of TF genes with at least one DBD- isoform (CENPB; Pipsqueak):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "CENPB; Pipsqueak") %>%
      filter(!are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

data.frame(family.num = rep(c("C2H2 ZF; Homeodomain (13)", "THAP finger (12)",
                              "CENPB; Pipsqueak (11)"), 2),
           isof.frequency = c(c2h2_hom.absent.freq, thap.absent.freq, 
                              cenpb.absent.freq, 
                              c2h2_hom.present.freq, thap.present.freq, 
                              cenpb.present.freq),
           isof.category = c(rep("DBD-", 3), rep("DBD+", 3))) %>%
  mutate(family.num = factor(family.num, levels = c("C2H2 ZF; Homeodomain (13)", "THAP finger (12)",
                                                    "CENPB; Pipsqueak (11)"))) %>%
  ggplot(aes(x = family.num, y = isof.frequency)) +
    geom_col(aes(fill = isof.category)) +
    theme_classic()

dbd.present.count.c2h2hom = dbd_yes_no_gene_table %>%
    filter(DBD == "C2H2 ZF; Homeodomain") %>%
    filter(are_all_isoforms_with_dbds) %>%
    nrow()

dbd.absent.count.c2h2hom = dbd_yes_no_gene_table %>%
    filter(DBD == "C2H2 ZF; Homeodomain") %>%
    filter(!are_all_isoforms_with_dbds) %>%
    nrow()

dbd.present.count.thap = dbd_yes_no_gene_table %>%
    filter(DBD == "THAP finger") %>%
    filter(are_all_isoforms_with_dbds) %>%
    nrow()

dbd.absent.count.thap = dbd_yes_no_gene_table %>%
    filter(DBD == "THAP finger") %>%
    filter(!are_all_isoforms_with_dbds) %>%
    nrow()

dbd.present.count.cenpbpip = dbd_yes_no_gene_table %>%
    filter(DBD == "CENPB; Pipsqueak") %>%
    filter(are_all_isoforms_with_dbds) %>%
    nrow()

dbd.absent.count.cenpbpip = dbd_yes_no_gene_table %>%
    filter(DBD == "CENPB; Pipsqueak") %>%
    filter(!are_all_isoforms_with_dbds) %>%
    nrow()

cont.matrix = matrix(data = c(dbd.present.count.c2h2hom,
                              dbd.absent.count.c2h2hom,
                              dbd.present.count.thap,
                              dbd.absent.count.thap),
                     nrow = 2,
                     dimnames = list(c("all.dbdplus", "some.dbdminus"),
                                     c("c2h2hom", "thap")))

fisher.test(cont.matrix,
            or = 1,
            alternative = "two.sided")
p1 = 0.6728

cont.matrix = matrix(data = c(dbd.present.count.c2h2hom,
                              dbd.absent.count.c2h2hom,
                              dbd.present.count.cenpbpip,
                              dbd.absent.count.cenpbpip),
                     nrow = 2,
                     dimnames = list(c("all.dbdplus", "some.dbdminus"),
                                     c("c2h2hom", "cenpbpip")))

fisher.test(cont.matrix,
            or = 1,
            alternative = "two.sided")
p2 = 0.04115

cont.matrix = matrix(data = c(dbd.present.count.thap,
                              dbd.absent.count.thap,
                              dbd.present.count.cenpbpip,
                              dbd.absent.count.cenpbpip),
                     nrow = 2,
                     dimnames = list(c("all.dbdplus", "some.dbdminus"),
                                     c("thap", "cenpbpip")))

fisher.test(cont.matrix,
            or = 1,
            alternative = "two.sided")
p3 = 0.2174

p.adjust(c(p1, p2, p3))
```

None of the tests gave a significant result under FDR = 10%.

Second comparison:

```{r}
cxxc.absent.freq = dbd.presence.frequencies.diff %>%
  filter(family.num1 == "CxxC ZF (11)") %>%
  pull(absent.frequency1) %>%
  unique()

cxxc.present.freq = 1 - cxxc.absent.freq

cat("The number of TF genes with all isoforms DBD+ (CxxC ZF):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "CxxC ZF") %>%
      filter(are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

cat("The number of TF genes with at least one DBD- isoform (CxxC ZF):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "CxxC ZF") %>%
      filter(!are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

rel.absent.freq = dbd.presence.frequencies.diff %>%
  filter(family.num2 == "Rel (10)") %>%
  pull(absent.frequency2) %>%
  unique()

rel.present.freq = 1 - rel.absent.freq

cat("The number of TF genes with all isoforms DBD+ (Rel):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "Rel") %>%
      filter(are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

cat("The number of TF genes with at least one DBD- isoform (Rel):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "Rel") %>%
      filter(!are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

irf.absent.freq = dbd.presence.frequencies.diff %>%
  filter(family.num2 == "IRF (9)") %>%
  pull(absent.frequency2) %>%
  unique()

irf.present.freq = 1 - irf.absent.freq

cat("The number of TF genes with all isoforms DBD+ (IRF):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "IRF") %>%
      filter(are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

cat("The number of TF genes with at least one DBD- isoform (IRF):", 
    dbd_yes_no_gene_table %>%
      filter(DBD == "IRF") %>%
      filter(!are_all_isoforms_with_dbds) %>%
      nrow(), "\n")

data.frame(family.num = rep(c("CxxC ZF (11)", 
                              "Rel (10)", "IRF (9)"), 2),
           isof.frequency = c(cxxc.absent.freq, 
                              rel.absent.freq, irf.absent.freq, 
                              cxxc.present.freq, 
                              rel.present.freq, irf.present.freq),
           isof.category = c(rep("DBD-", 3), rep("DBD+", 3))) %>%
  mutate(family.num = factor(family.num, levels = c("CxxC ZF (11)", 
                                                    "Rel (10)", "IRF (9)"))) %>%
  ggplot(aes(x = family.num, y = isof.frequency)) +
    geom_col(aes(fill = isof.category)) +
    theme_classic()

dbd.present.count.cxxc = dbd_yes_no_gene_table %>%
    filter(DBD == "CxxC ZF") %>%
    filter(are_all_isoforms_with_dbds) %>%
    nrow()

dbd.absent.count.cxxc = dbd_yes_no_gene_table %>%
    filter(DBD == "CxxC ZF") %>%
    filter(!are_all_isoforms_with_dbds) %>%
    nrow()

dbd.present.count.rel = dbd_yes_no_gene_table %>%
    filter(DBD == "Rel") %>%
    filter(are_all_isoforms_with_dbds) %>%
    nrow()

dbd.absent.count.rel = dbd_yes_no_gene_table %>%
    filter(DBD == "Rel") %>%
    filter(!are_all_isoforms_with_dbds) %>%
    nrow()

dbd.present.count.irf = dbd_yes_no_gene_table %>%
    filter(DBD == "IRF") %>%
    filter(are_all_isoforms_with_dbds) %>%
    nrow()

dbd.absent.count.irf = dbd_yes_no_gene_table %>%
    filter(DBD == "IRF") %>%
    filter(!are_all_isoforms_with_dbds) %>%
    nrow()

cont.matrix = matrix(data = c(dbd.present.count.cxxc,
                              dbd.absent.count.cxxc,
                              dbd.present.count.rel,
                              dbd.absent.count.rel),
                     nrow = 2,
                     dimnames = list(c("all.dbdplus", "some.dbdminus"),
                                     c("cxxc", "rel")))

fisher.test(cont.matrix,
            or = 1,
            alternative = "two.sided")
p1 = 0.387

cont.matrix = matrix(data = c(dbd.present.count.cxxc,
                              dbd.absent.count.cxxc,
                              dbd.present.count.irf,
                              dbd.absent.count.irf),
                     nrow = 2,
                     dimnames = list(c("all.dbdplus", "some.dbdminus"),
                                     c("cxxc", "irf")))

fisher.test(cont.matrix,
            or = 1,
            alternative = "two.sided")
p2 = 0.1968

cont.matrix = matrix(data = c(dbd.present.count.rel,
                              dbd.absent.count.rel,
                              dbd.present.count.irf,
                              dbd.absent.count.irf),
                     nrow = 2,
                     dimnames = list(c("all.dbdplus", "some.dbdminus"),
                                     c("rel", "irf")))

fisher.test(cont.matrix,
            or = 1,
            alternative = "two.sided")
p3 = 1

p.adjust(c(p1, p2, p3))
```

A hypothesis about such differences between TF families with a comparable number of isoforms is that TFs from families with a small proportion of DBD-less isoforms do not have any other functions, apart from being transcription factors, while TFs from the families with a big proportion of DBD-less isoforms may have additional functions when a DBD is lost (for example, be cofactors or sequestering factors). We will test this hypothesis later on by looking at the presence of domains of other types and at the level of expression of DBD-containing and DBD-less isoforms.

Generate the table and plot frequencies of TF isoforms with and without DBDs:

```{r, include=T}
dbd_yes_no_tx_table = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(DBD != "Unknown") %>%
  filter(DBD != "Excluded") %>%
  mutate(is_canonical = ifelse(!is.na(represents_family), T, F)) %>%
  group_by(ensembl_transcript_id) %>%
  mutate(n_canonical = length(is_canonical[is_canonical])) %>%
  ungroup() %>%
  dplyr::select(-is_canonical) %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, ensembl_transcript_id, DBD, n_canonical) %>%
  distinct()

write.table(dbd_yes_no_tx_table %>%
              dplyr::rename("n_dbd" = "n_canonical") %>%
              dplyr::rename("tf_family" = "DBD"),
            file = "data/results/base_dbd_expression_analysis_table.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Generate a list of DBD- isoforms:

```{r, include=T}
tf.isodorms.nodbd = dbd_yes_no_tx_table %>% 
  filter(n_canonical == 0) %>% 
  pull(ensembl_transcript_id)
```

So, we have `length(tf.isodorms.nodbd)` DBD- TF isoforms. Some of them may not contain any domain. Let us find those isoforms:

```{r, include=T}
tf.isodorms.nodom = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(DBD != "Unknown") %>%
  filter(DBD != "Excluded") %>%
  filter(is.na(ipr_accession)) %>%
  pull(ensembl_transcript_id) %>%
  unique()
```

So we have `r length(tf.isodorms.nodom)` isoforms without domains. Check that they are all in the `tf.isodorms.nodbd` list:

```{r, include=T}
length(intersect(tf.isodorms.nodom, tf.isodorms.nodbd)) == length(tf.isodorms.nodom)
```

Finally, let us generate the list of DBD- isoforms that have other domains:

```{r, include=T}
tf.isodorms.nodbd = tf.isodorms.nodbd[!tf.isodorms.nodbd %in% tf.isodorms.nodom]
```

Write down the list of domainless isoforms and the list of DBD- isoforms that have other domains:

```{r, include=T}
write.table(tf.isodorms.nodbd,
            file = "data/results/isoforms_no_dbd_list.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
write.table(tf.isodorms.nodom,
            file = "data/results/isoforms_no_domains_list.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Plot the isoform frequencies:

```{r, echo=F, fig.width=15, fig.height=5}
count_genes = function(domain_type) {
  return(dbd_gene_counts %>%
    filter(dbd == domain_type) %>%
    pull(n))
}

dbd_gene_counts = dbd_yes_no_tx_table %>%
  dplyr::select(ensembl_gene_id, DBD) %>%
  distinct() %>%
  dplyr::count(DBD) %>%
  dplyr::rename("dbd" = "DBD") %>%
  mutate(dbd = as.character(dbd))

tf.families = dbd_gene_counts %>%
  pull(dbd)

tf.family.count = length(tf.families)

tf.families.num = unlist(purrr::map(tf.families,
                             function(d) {
                               paste0(d, " (", as.character(count_genes(d)), ")")
                             }))

dbd.presence.frequencies = data.frame(family = character(),
                                      present.frequency = numeric(),
                                      absent.frequency = numeric())

for (tf.family in tf.families) { 
  dbd.present.count = dbd_yes_no_tx_table %>%
    filter(DBD == tf.family) %>%
    filter(n_canonical > 0) %>%
    nrow()
  dbd.absent.count = dbd_yes_no_tx_table %>%
    filter(DBD == tf.family) %>%
    filter(n_canonical == 0) %>%
    nrow()
  total.count = dbd.present.count + dbd.absent.count
  dbd.presence.frequencies = dbd.presence.frequencies %>%
    bind_rows(c("family" = tf.family))
  dbd.presence.frequencies = dbd.presence.frequencies %>%
    mutate(present.frequency = ifelse(family == tf.family, dbd.present.count / total.count, present.frequency)) %>%
    mutate(absent.frequency = ifelse(family == tf.family, dbd.absent.count / total.count, absent.frequency))
}

dbd.presence.frequencies = dbd.presence.frequencies %>%
  bind_cols("family.num" = tf.families.num)

dbd.presence.frequencies$family.num = factor(dbd.presence.frequencies$family.num, levels = tf.families.ordered)

dbd.presence.frequencies.isoforms = dbd.presence.frequencies %>%
  arrange(family)

ggplot(data = data.frame("Category" = c(rep("Some isoforms without DBD", tf.family.count),
                                        rep("All isoforms with DBD", tf.family.count)),
                         "Frequency" = c(dbd.presence.frequencies$absent.frequency,
                                         dbd.presence.frequencies$present.frequency),
                         "Family" = rep(dbd.presence.frequencies$family.num, 2)) %>%
         mutate(Category = factor(Category, levels = c("Some isoforms without DBD",
                                                       "All isoforms with DBD"))),
       aes(x = Family, y = Frequency, group = Family)) +
  geom_col(aes(fill = Category)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

After the family names, in parentheses, we show the number of TFs in each family.

The number of TFs in the plots is `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(DBD != "Unknown") %>% filter(DBD != "Excluded") %>% pull(ensembl_gene_id) %>% unique() %>% length()`, and the number of isoforms is `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(DBD != "Unknown") %>% filter(DBD != "Excluded") %>% pull(ensembl_transcript_id) %>% unique() %>% length()` (we excluded the Unknown and Excluded families). The number of families in the plot is `r tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>% filter(DBD != "Unknown") %>% filter(DBD != "Excluded") %>% pull(DBD) %>% unique() %>% length()`.

TFs with at least one isoform missing DBDs: `r dbd_yes_no_gene_table %>% filter(are_all_isoforms_with_dbds == F) %>% nrow()` (`r (dbd_yes_no_gene_table %>% filter(are_all_isoforms_with_dbds == F) %>% nrow()) / (dbd_yes_no_gene_table %>% nrow()) * 100`%).

TFs with all isoforms containing a DBD: `r dbd_yes_no_gene_table %>% filter(are_all_isoforms_with_dbds == T) %>% nrow()` (`r (dbd_yes_no_gene_table %>% filter(are_all_isoforms_with_dbds == T) %>% nrow()) / (dbd_yes_no_gene_table %>% nrow()) * 100`%).

A barplot with overall TF frequencies:

```{r, include=T}
ggplot(data = data.frame("Category" = c("Some isoforms without DBD",
                                        "All isoforms with DBD"),
                         "Frequency" = c((dbd_yes_no_gene_table %>% 
                                           filter(are_all_isoforms_with_dbds == F) %>% 
                                           nrow()) / 
                                         (dbd_yes_no_gene_table %>% 
                                           nrow()),
                                         (dbd_yes_no_gene_table %>% 
                                           filter(are_all_isoforms_with_dbds == T) %>% 
                                           nrow()) / 
                                         (dbd_yes_no_gene_table %>% 
                                           nrow())),
                         "Feature" = rep("TF", 2)) %>%
         mutate(Category = factor(Category, levels = c("Some isoforms without DBD",
                                                       "All isoforms with DBD"))),
       aes(x = Feature, y = Frequency, group = Feature)) +
  geom_col(aes(fill = Category)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_blank()) #element_text(angle = 90, hjust = 1, vjust = 0.5))
```

TF isoforms without DBDs: `r dbd_yes_no_tx_table %>% filter(n_canonical == 0) %>% nrow()` (`r (dbd_yes_no_tx_table %>% filter(n_canonical == 0) %>% nrow()) / (dbd_yes_no_tx_table %>% nrow()) * 100`%).

TF isoforms with DBDs: `r dbd_yes_no_tx_table %>% filter(n_canonical > 0) %>% nrow()` (`r (dbd_yes_no_tx_table %>% filter(n_canonical > 0) %>% nrow()) / (dbd_yes_no_tx_table %>% nrow()) * 100`%).

A barplot with overall isoform frequencies:

```{r, include=T}
ggplot(data = data.frame("Category" = c("Some isoforms without DBD",
                                        "All isoforms with DBD"),
                         "Frequency" = c((dbd_yes_no_tx_table %>% 
                                            filter(n_canonical == 0) %>% 
                                            nrow()) / 
                                         (dbd_yes_no_tx_table %>% 
                                            nrow()),
                                         (dbd_yes_no_tx_table %>% 
                                            filter(n_canonical > 0) %>% 
                                            nrow()) / 
                                         (dbd_yes_no_tx_table %>% 
                                            nrow())),
                         "Feature" = rep("Isoform", 2)) %>%
         mutate(Category = factor(Category, levels = c("Some isoforms without DBD",
                                                       "All isoforms with DBD"))),
       aes(x = Feature, y = Frequency, group = Feature)) +
  geom_col(aes(fill = Category)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_blank()) #element_text(angle = 90, hjust = 1, vjust = 0.5))
```

In `r dbd.presence.absence.tf.frequencies %>% filter(Category == "Some isoforms without DBD") %>% filter(Frequency == 1) %>% nrow()` families, 100% of TFs are missing a DBD in at least one isoform, but those families have only one or two genes. In contrast, in `r dbd.presence.absence.tf.frequencies %>% filter(Category == "All isoforms with DBD") %>% filter(Frequency == 1) %>% nrow()` families, TFs never miss a DBD, and many of these families have three or more TFs, althought these families are still relatively small. On the other hand, the majority of families, including the biggest ones, can have any frequency of one or the other category. 

In total, `r dbd_yes_no_gene_table %>% filter(are_all_isoforms_with_dbds == F) %>% nrow()` (`r (dbd_yes_no_gene_table %>% filter(are_all_isoforms_with_dbds == F) %>% nrow()) / (dbd_yes_no_gene_table %>% nrow()) * 100`%) of TFs miss a DBD in at least one isoform. 

There is a strong correlation between the number of TFs missing a DBD in at least one isoform and the number of isoforms without a DBD (Pearson's r=`r cor(dbd.presence.frequencies.tfs$absent.frequency, dbd.presence.frequencies.isoforms$absent.frequency, method = "pearson")`. 

Test if TF genes with at least one DBD- isoform are enriched among DBD- isoform producing TF genes known from literature:

```{r}
dbd_yes_no_gene_table = readRDS("data/results/dbd_yes_no_gene_table.rds")

all_tfs = dbd_yes_no_gene_table$humantfs_gene_name

no_dbd_lit_tfs = c("CREB1", "ELF5", "ESR1", "ESR2", "HOXB6", "RARA", "RFX4", "RFX8",
                   "IKZF3", "KLF4", "KLF5", "KLF6", "KLF7", "KLF8", "KLF10", "KLF12", 
                   "MEIS1", "MEIS2", "MZF1", "TFEC", "ZNF197", "NFIB", "NR2F2", "ZNF202", 
                   "ZNF215", "ZNF655")
# CREB1 = CREB in literature

# All TF genes from literature with DBD- isoforms are present among our set of TF genes
cat("The number of genes from literature missing in our set of TF genes:",
    length(setdiff(no_dbd_lit_tfs, intersect(no_dbd_lit_tfs, all_tfs))), "\n")

# The number of TF genes that have DBD- isoforms according to both literature and our analysis
q = dbd_yes_no_gene_table %>% 
  filter(are_all_isoforms_with_dbds == F) %>%
  filter(humantfs_gene_name %in% no_dbd_lit_tfs) %>%
  nrow()

# The total number of TF genes that have DBD- isoforms according to our analysis
m = dbd_yes_no_gene_table %>% 
  filter(are_all_isoforms_with_dbds == F) %>% 
  nrow()

# The total number of TF genes that do not have DBD- isoforms according to our analysis
n = length(all_tfs) - m

# The total number of TF genes that have DBD- isoforms according to literature
k = length(no_dbd_lit_tfs)

cat("Expected ratio:", m / (m + n), "\n")
# 0.2744709

cat("Observed ratio:", q / k, "\n")
# 0.5

p_val = phyper(q, m, n, k,
               lower.tail = F)

cat("Hypergeometric test p =", p_val, "\n")
# 0.003681145
```

The enrichment of TF genes with at least one DBD- isoform, according to our analysis, among TF genes with at least one DBD- isoform, according to literature, is significant. Although, the observed proportion of the former in the latter (0.5) is not as high as I would expect.

## Assess the number of DBDs in different TFs

Create a table with maximum number of DBDs for each TF:

```{r, include=T}
canonical_dbd_iprs_filtered = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(!is.na(represents_family)) %>%
  dplyr::select(ipr_accession, ipr_description, represents_family) %>%
  arrange(represents_family, ipr_accession) %>%
  distinct() %>%
  pull(ipr_accession)

n_dbd_table = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(!DBD %in% c("Unknown", "Excluded")) %>%
  filter(ipr_accession %in% canonical_dbd_iprs_filtered) %>%
  group_by(ensembl_transcript_id) %>%
  mutate(n_dbds = length(ipr_accession)) %>% 
  ungroup() %>%
  group_by(ensembl_gene_id) %>%
  mutate(max_n_dbds = max(n_dbds)) %>%
  ungroup() %>%
  dplyr::select(DBD, ensembl_gene_id, humantfs_gene_name, max_n_dbds) %>%
  distinct() %>%
  arrange(DBD, humantfs_gene_name)
```

Plot frequencies of TFs with different maximum numbers of DBDs. Let us order the bars by decreasing proportion of TFs with maximum one DBD:

```{r, echo=F, fig.width=15, fig.height=5}
count_genes = function(domain_type) {
  return(dbd_gene_counts %>%
    filter(dbd == domain_type) %>%
    pull(n))
}

dbd_gene_counts = n_dbd_table %>%
  dplyr::select(ensembl_gene_id, DBD) %>%
  distinct() %>%
  dplyr::count(DBD) %>%
  dplyr::rename("dbd" = "DBD") %>%
  mutate(dbd = as.character(dbd)) %>%
  filter(dbd != "Unknown")

tf.families = dbd_gene_counts %>%
  pull(dbd)

tf.family.count = length(tf.families)

tf.families.num = unlist(purrr::map(tf.families,
                             function(d) {
                               paste0(d, " (", as.character(count_genes(d)), ")")
                             }))

variability.frequencies = c()

for (tf.family in tf.families) { 
  dbd.1.count = n_dbd_table %>%
    filter(DBD == tf.family) %>%
    filter(max_n_dbds == 1) %>%
    nrow()
  dbd.2.count = n_dbd_table %>%
    filter(DBD == tf.family) %>%
    filter(max_n_dbds == 2) %>%
    nrow()
  dbd.3.count = n_dbd_table %>%
    filter(DBD == tf.family) %>%
    filter(max_n_dbds == 3) %>%
    nrow()
  dbd.many.count = n_dbd_table %>%
    filter(DBD == tf.family) %>%
    filter(max_n_dbds > 3) %>%
    nrow()
  total.count = dbd.1.count + dbd.2.count + dbd.3.count + dbd.many.count
  variability.frequencies = c(variability.frequencies, 
                              dbd.1.count / total.count, 
                              dbd.2.count / total.count, 
                              dbd.3.count / total.count,
                              dbd.many.count / total.count)
}

dbd.1.frequencies = unlist(lapply(1:length(variability.frequencies), function(i) {if ((i %% 4) == 1) variability.frequencies[i]}))

dbd.1.frequencies.tfs = dbd.1.frequencies

dbd.2.frequencies = unlist(lapply(1:length(variability.frequencies), function(i) {if ((i %% 4) == 2) variability.frequencies[i]}))

dbd.3.frequencies = unlist(lapply(1:length(variability.frequencies), function(i) {if ((i %% 4) == 3) variability.frequencies[i]}))

dbd.many.frequencies = unlist(lapply(1:length(variability.frequencies), function(i) {if ((i %% 4) == 0) variability.frequencies[i]}))

dbd.1.frequencies.sorted = dbd.1.frequencies[order(dbd.1.frequencies, decreasing = T, method = "radix")]

dbd.2.frequencies.sorted = dbd.2.frequencies[order(dbd.1.frequencies, decreasing = T, method = "radix")]

dbd.3.frequencies.sorted = dbd.3.frequencies[order(dbd.1.frequencies, decreasing = T, method = "radix")]

dbd.many.frequencies.sorted = dbd.many.frequencies[order(dbd.1.frequencies, decreasing = T, method = "radix")]

tf.families.num.sorted = tf.families.num[order(dbd.1.frequencies, decreasing = T, method = "radix")]

tf.families.num.sorted = factor(tf.families.num.sorted, levels = tf.families.num.sorted)

dbd.n.frequencies.sorted = c(dbd.1.frequencies.sorted,
                             dbd.2.frequencies.sorted,
                             dbd.3.frequencies.sorted,
                             dbd.many.frequencies.sorted)

ggplot(data = data.frame("Number_of_DBDs" = c(rep("1", tf.family.count),
                                              rep("2", tf.family.count),
                                              rep("3", tf.family.count),
                                              rep(">3", tf.family.count)),
                         "Frequency" = dbd.n.frequencies.sorted,
                         "Family" = rep(tf.families.num.sorted, 4)) %>%
         mutate(Number_of_DBDs = factor(Number_of_DBDs, levels = c("1",
                                                                   "2",
                                                                   "3",
                                                                   ">3"))),
       aes(x = Family, y = Frequency, group = Family)) +
  geom_col(aes(fill = Number_of_DBDs)) +
  #scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Families with at least one TF with max number of DBDs more than one in at least one isoform:

```{r, include=T}
mult.dbd.fams.tfs = n_dbd_table %>%
  filter(max_n_dbds > 1) %>%
  mutate(DBD = as.character(DBD)) %>%
  pull(DBD) %>%
  unique()
mult.dbd.fams.tfs
```

```{r, include=T}
n_dbd_table_summary = 
n_dbd_table %>%
  filter(DBD != "C2H2 ZF") %>%
  dplyr::count(max_n_dbds)
```

After the family names, in parentheses, we show the number of TFs in each family.

The number of TFs in the plot is `r n_dbd_table %>% nrow()`.

TFs with maximum 1 DBD: `r n_dbd_table %>% filter(max_n_dbds == 1) %>% nrow()` (`r (n_dbd_table %>% filter(max_n_dbds == 1) %>% nrow()) / (n_dbd_table %>% nrow()) * 100`%).

TFs with maximum 2 DBDs: `r n_dbd_table %>% filter(max_n_dbds == 2) %>% nrow()` (`r (n_dbd_table %>% filter(max_n_dbds == 2) %>% nrow()) / (n_dbd_table %>% nrow()) * 100`%).

TFs with maximum 3 DBDs: `r n_dbd_table %>% filter(max_n_dbds == 3) %>% nrow()` (`r (n_dbd_table %>% filter(max_n_dbds == 3) %>% nrow()) / (n_dbd_table %>% nrow()) * 100`%).

TFs with maximum >3 DBDs: `r n_dbd_table %>% filter(max_n_dbds > 3) %>% nrow()` (`r (n_dbd_table %>% filter(max_n_dbds > 3) %>% nrow()) / (n_dbd_table %>% nrow()) * 100`%). The vast majority (`r (n_dbd_table %>% filter(max_n_dbds > 3) %>% filter(DBD == "C2H2 ZF") %>% nrow()) / (n_dbd_table %>% filter(max_n_dbds > 3) %>% nrow()) * 100`%) of these TFs come from the C2H2 ZF family.

A barplot with overall TF frequencies:

```{r, include=T}
ggplot(data = data.frame("Number_of_DBDs" = c("1", "2", "3", ">3"),
                         "Frequency" = c((n_dbd_table %>% 
                                            filter(max_n_dbds == 1) %>% 
                                            nrow()) / 
                                         (n_dbd_table %>% 
                                             nrow()),
                                         (n_dbd_table %>% 
                                            filter(max_n_dbds == 2) %>% 
                                            nrow()) / 
                                         (n_dbd_table %>% 
                                            nrow()),
                                         (n_dbd_table %>% 
                                            filter(max_n_dbds == 3) %>% 
                                            nrow()) / 
                                         (n_dbd_table %>% 
                                            nrow()),
                                         (n_dbd_table %>% 
                                            filter(max_n_dbds > 3) %>% 
                                            nrow()) / 
                                         (n_dbd_table %>% 
                                            nrow())),
                         "Feature" = rep("TF", 4)) %>%
         mutate(Number_of_DBDs = factor(Number_of_DBDs, levels = c("1",
                                                                   "2",
                                                                   "3",
                                                                   ">3"))),
       aes(x = Feature, y = Frequency, group = Feature)) +
  geom_col(aes(fill = Number_of_DBDs)) +
  #scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

The majority (`r n_dbd_table %>% filter(max_n_dbds == 1) %>% pull(DBD) %>% unique() %>% length()` out of `r n_dbd_table %>% pull(DBD) %>% unique() %>% length()`, or `r (n_dbd_table %>% filter(max_n_dbds == 1) %>% pull(DBD) %>% unique() %>% length()) / (n_dbd_table %>% pull(DBD) %>% unique() %>% length()) * 100`%) of TF families have just one DBD match, and multiple DBD matches are mainly present in combined families (`r (n_dbd_table %>% filter(max_n_dbds > 1) %>% filter(stringr::str_detect(DBD, ";")) %>% nrow()) / (n_dbd_table %>% filter(max_n_dbds > 1) %>% nrow()) * 100`% of TFs with the maximum number of DBDs more than 1) and in the C2H2 ZF family (`r (n_dbd_table %>% filter(max_n_dbds > 1) %>% filter(DBD == "C2H2 ZF") %>% nrow()) / (n_dbd_table %>% filter(max_n_dbds > 1) %>% nrow()) * 100`% of such TFs).

If we do not count the C2H2 ZF family, then only `r n_dbd_table_summary %>% filter(max_n_dbds > 1) %>% summarise(n = sum(n)) %>% pull(n)` TFs (`r (n_dbd_table_summary %>% filter(max_n_dbds > 1) %>% summarise(n = sum(n)) %>% pull(n)) / (n_dbd_table_summary %>% summarise(n = sum(n)) %>% pull(n)) * 100`% of the TFs outside the C2H2 ZF family) have more than one DBD match, and only `r n_dbd_table_summary %>% filter(max_n_dbds > 3) %>% summarise(n = sum(n)) %>% pull(n)` TFs (`r (n_dbd_table_summary %>% filter(max_n_dbds > 3) %>% summarise(n = sum(n)) %>% pull(n)) / (n_dbd_table_summary %>% summarise(n = sum(n)) %>% pull(n)) * 100`% of such TFs have more than 3 DBD matches (and C2H2 ZF matches can still be present there, as not only TFs from the C2H2 ZF family have C2H2 ZF matches).

In TFs with maximum one DBD, alternative splicing can work as a switch between the TF and the non-TF states. We plotted the frequencies of the presence or absence of DBDs above. In TFs with multiple DBDs, alternative splicing can also work as the TF-non-TF switch (if it removes or includes all DBDs), but also it can include or exclude just parts of DBD combinations and in this way potentially change DNA binding specificity of the corresponding TF isoforms. We investigate this expansion/contraction of DBD combinations later on.

Plot the frequencies of isoforms with 1, 2, 3 or more than 3 DBDs:

```{r, include=T}
n_dbd_table_isof = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(!DBD %in% c("Unknown", "Excluded")) %>%
  filter(ipr_accession %in% canonical_dbd_iprs) %>%
  group_by(ensembl_transcript_id) %>%
  mutate(n_dbds = length(ipr_accession)) %>% 
  ungroup() %>%
  dplyr::select(DBD, ensembl_gene_id, humantfs_gene_name, ensembl_transcript_id, n_dbds) %>%
  distinct() %>%
  arrange(DBD, humantfs_gene_name, ensembl_transcript_id)
```

Plot the frequencies:

```{r, echo=F, fig.width=15, fig.height=5}
count_genes = function(domain_type) {
  return(dbd_gene_counts %>%
    filter(dbd == domain_type) %>%
    pull(n))
}
dbd_gene_counts = n_dbd_table %>%
  dplyr::select(ensembl_gene_id, DBD) %>%
  distinct() %>%
  dplyr::count(DBD) %>%
  dplyr::rename("dbd" = "DBD") %>%
  mutate(dbd = as.character(dbd)) %>%
  filter(dbd != "Unknown")
tf.families = dbd_gene_counts %>%
  pull(dbd)
tf.family.count = length(tf.families)
tf.families.num = unlist(map(tf.families,
                             function(d) {
                               paste0(d, " (", as.character(count_genes(d)), ")")
                             }))
variability.frequencies = c()
for (tf.family in tf.families) { 
  dbd.1.count = n_dbd_table_isof %>%
    filter(DBD == tf.family) %>%
    filter(n_dbds == 1) %>%
    nrow()
  dbd.2.count = n_dbd_table_isof %>%
    filter(DBD == tf.family) %>%
    filter(n_dbds == 2) %>%
    nrow()
  dbd.3.count = n_dbd_table_isof %>%
    filter(DBD == tf.family) %>%
    filter(n_dbds == 3) %>%
    nrow()
  dbd.many.count = n_dbd_table_isof %>%
    filter(DBD == tf.family) %>%
    filter(n_dbds > 3) %>%
    nrow()
  total.count = dbd.1.count + dbd.2.count + dbd.3.count + dbd.many.count
  variability.frequencies = c(variability.frequencies, 
                              dbd.1.count / total.count, 
                              dbd.2.count / total.count, 
                              dbd.3.count / total.count,
                              dbd.many.count / total.count)
}
dbd.1.frequencies = unlist(lapply(1:length(variability.frequencies), function(i) {if ((i %% 4) == 1) variability.frequencies[i]}))
dbd.2.frequencies = unlist(lapply(1:length(variability.frequencies), function(i) {if ((i %% 4) == 2) variability.frequencies[i]}))
dbd.3.frequencies = unlist(lapply(1:length(variability.frequencies), function(i) {if ((i %% 4) == 3) variability.frequencies[i]}))
dbd.many.frequencies = unlist(lapply(1:length(variability.frequencies), function(i) {if ((i %% 4) == 0) variability.frequencies[i]}))
# Use the sorting order from the TF-level plot above
dbd.1.frequencies.sorted = dbd.1.frequencies[order(dbd.1.frequencies.tfs, decreasing = T, method = "radix")]
dbd.2.frequencies.sorted = dbd.2.frequencies[order(dbd.1.frequencies.tfs, decreasing = T, method = "radix")]
dbd.3.frequencies.sorted = dbd.3.frequencies[order(dbd.1.frequencies.tfs, decreasing = T, method = "radix")]
dbd.many.frequencies.sorted = dbd.many.frequencies[order(dbd.1.frequencies.tfs, decreasing = T, method = "radix")]
tf.families.num.sorted = tf.families.num[order(dbd.1.frequencies.tfs, decreasing = T, method = "radix")]
tf.families.num.sorted = factor(tf.families.num.sorted, levels = tf.families.num.sorted)
dbd.n.frequencies.sorted = c(dbd.1.frequencies.sorted,
                             dbd.2.frequencies.sorted,
                             dbd.3.frequencies.sorted,
                             dbd.many.frequencies.sorted)
ggplot(data = data.frame("Number_of_DBDs" = c(rep("1", tf.family.count),
                                              rep("2", tf.family.count),
                                              rep("3", tf.family.count),
                                              rep(">3", tf.family.count)),
                         "Frequency" = dbd.n.frequencies.sorted,
                         "Family" = rep(tf.families.num.sorted, 4)) %>%
         mutate(Number_of_DBDs = factor(Number_of_DBDs, levels = c("1",
                                                                   "2",
                                                                   "3",
                                                                   ">3"))),
       aes(x = Family, y = Frequency, group = Family)) +
  geom_col(aes(fill = Number_of_DBDs)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Families with at least one DBD- TF isoform:

```{r, include=T}
mult.dbd.fams.isofs = n_dbd_table_isof %>%
  filter(n_dbds > 1) %>%
  mutate(DBD = as.character(DBD)) %>%
  pull(DBD) %>%
  unique()

mult.dbd.fams.isofs
```

After the family names, in parentheses, we show the number of TFs in each family.

The number of isoforms in the plot is: `r n_dbd_table_isof %>% nrow()`.

Isoforms with 1 DBD: `r n_dbd_table_isof %>% filter(n_dbds == 1) %>% nrow()` (`r (n_dbd_table_isof %>% filter(n_dbds == 1) %>% nrow()) / (n_dbd_table_isof %>% nrow()) * 100`%).

Isoforms with 2 DBDs: `r n_dbd_table_isof %>% filter(n_dbds == 2) %>% nrow()` (`r (n_dbd_table_isof %>% filter(n_dbds == 2) %>% nrow()) / (n_dbd_table_isof %>% nrow()) * 100`%).

Isoforms with 3 DBDs: `r n_dbd_table_isof %>% filter(n_dbds == 3) %>% nrow()` (`r (n_dbd_table_isof %>% filter(n_dbds == 3) %>% nrow()) / (n_dbd_table_isof %>% nrow()) * 100`%).

Isoforms with >3 DBDs: `r n_dbd_table_isof %>% filter(n_dbds > 3) %>% nrow()` (`r (n_dbd_table_isof %>% filter(n_dbds > 3) %>% nrow()) / (n_dbd_table_isof %>% nrow()) * 100`%). The vast majority (`r (n_dbd_table_isof %>% filter(n_dbds > 3) %>% filter(DBD == "C2H2 ZF") %>% nrow()) / (n_dbd_table_isof %>% filter(n_dbds > 3) %>% nrow()) * 100`%) of these TFs come from the C2H2 ZF family.

A barplot with overall TF frequencies:

```{r, include=T}
ggplot(data = data.frame("Number_of_DBDs" = c("1", "2", "3", ">3"),
                         "Frequency" = c((n_dbd_table_isof %>% 
                                            filter(n_dbds == 1) %>% 
                                            nrow()) / 
                                         (n_dbd_table_isof %>% 
                                             nrow()),
                                         (n_dbd_table_isof %>% 
                                            filter(n_dbds == 2) %>% 
                                            nrow()) / 
                                         (n_dbd_table_isof %>% 
                                            nrow()),
                                         (n_dbd_table_isof %>% 
                                            filter(n_dbds == 3) %>% 
                                            nrow()) / 
                                         (n_dbd_table_isof %>% 
                                            nrow()),
                                         (n_dbd_table_isof %>% 
                                            filter(n_dbds > 3) %>% 
                                            nrow()) / 
                                         (n_dbd_table_isof %>% 
                                            nrow())), 
                         "Feature" = rep("Isoform", 4)) %>%
         mutate(Number_of_DBDs = factor(Number_of_DBDs, levels = c("1",
                                                                   "2",
                                                                   "3",
                                                                   ">3"))),
       aes(x = Feature, y = Frequency, group = Feature)) +
  geom_col(aes(fill = Number_of_DBDs)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Hence, although `r (n_dbd_table %>% filter(max_n_dbds > 3) %>% nrow()) / (n_dbd_table %>% nrow()) * 100`% of TFs have maximum number of DBDs greater than 3, only `r (n_dbd_table_isof %>% filter(n_dbds > 3) %>% nrow()) / (n_dbd_table_isof %>% nrow()) * 100` of TF isoforms actually have that many DBDs. The difference between the TF-level (maximum number of DBDs) and isoform-level (number of DBDs) calculations is also clear for some particular TF families: all TFs in "Homeodomain; Paired box", "HMG/Sox; SAND", "bZIP; C2H2 ZF" and "bHLH; T-box" have maximum number of DBDs more than one, but actually, `r (n_dbd_table_isof %>% filter(n_dbds == 1) %>% filter(DBD == "Homeodomain; Paired box") %>% nrow()) / (n_dbd_table_isof %>% filter(DBD == "Homeodomain; Paired box") %>% nrow()) * 100` to `r (n_dbd_table_isof %>% filter(n_dbds == 1) %>% filter(DBD == "HMG/Sox; SAND") %>% nrow()) / (n_dbd_table_isof %>% filter(DBD == "HMG/Sox; SAND") %>% nrow()) * 100`% of their isoforms have just one DBD.

Check that from the table for TFs and for TF isoforms we obtain the same lists of families:

```{r, include=T}
unique(mult.dbd.fams.tfs == mult.dbd.fams.isofs)
```

Yes, this is the case.

## Investigate changes in the number and types of DBDs in TFs with multiple DBDs

All TFs with maximum one DBD have just one type of a DBD (all of them are monotypical on a TF-level plot above). This means that 1-DBD TFs do not swap DBD types through alternative splicing.

However, in TFs with multiple DBDs alternative isoforms can have different DBD combinations (i. e., different types and numbers of DBDs). Let us describe possible changes in DBD combinations between alternative isoforms:

```{r, include=T}
dbd_changing_num_table = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(DBD != "Unknown") %>%
  filter(DBD != "Excluded") %>%
  mutate(is_canonical = ifelse(!is.na(represents_family), T, F)) %>%
  group_by(ensembl_transcript_id) %>%
  mutate(n_canonical = length(is_canonical[is_canonical])) %>%
  ungroup() %>%
  dplyr::select(-is_canonical) %>%
  filter(n_canonical != 0) %>%
  group_by(ensembl_transcript_id) %>%
  mutate(dbd_combination = paste(sort(represents_family), collapse = "_")) %>%
  ungroup() %>%
  group_by(ensembl_gene_id) %>%
  mutate(n_isoforms = length(unique(ensembl_transcript_id))) %>%
  ungroup() %>%
  filter(n_isoforms > 1) %>%
  group_by(ensembl_gene_id) %>%
  mutate(is_dbd_combination_changing = ifelse(length(unique(dbd_combination)) > 1, T, F)) %>%
  ungroup() %>%
  left_join(n_dbd_table, by = c("DBD" = "DBD",
                                "ensembl_gene_id" = "ensembl_gene_id",
                                "humantfs_gene_name" = "humantfs_gene_name")) %>%
  filter(max_n_dbds > 1) %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD, is_dbd_combination_changing, max_n_dbds) %>%
  distinct()
```

Plot the frequencies:

```{r, include=T, fig.width=15, fig.height=5}
count_genes = function(domain_type) {
  return(dbd_gene_counts %>%
    filter(dbd == domain_type) %>%
    pull(n))
}

dbd_gene_counts = dbd_changing_num_table %>%
  dplyr::select(ensembl_gene_id, DBD) %>%
  distinct() %>%
  dplyr::count(DBD) %>%
  dplyr::rename("dbd" = "DBD") %>%
  mutate(dbd = as.character(dbd))

tf.families = dbd_gene_counts %>%
  pull(dbd)

tf.family.count = length(tf.families)

tf.families.num = unlist(purrr::map(tf.families,
                                    function(d) {
                                      paste0(d, " (", as.character(count_genes(d)), ")")
                                    }))

dbd.changing.num.frequencies = data.frame(family = character(),
                                          changing.frequency = numeric(),
                                          const.frequency = numeric())

for (tf.family in tf.families) { 
  dbd.changing.count = dbd_changing_num_table %>%
    filter(DBD == tf.family) %>%
    filter(is_dbd_combination_changing) %>%
    nrow()
  dbd.const.count = dbd_changing_num_table %>%
    filter(DBD == tf.family) %>%
    filter(!is_dbd_combination_changing) %>%
    nrow()
  total.count = dbd.changing.count + dbd.const.count
  dbd.changing.num.frequencies = dbd.changing.num.frequencies %>%
    bind_rows(c("family" = tf.family))
  dbd.changing.num.frequencies = dbd.changing.num.frequencies %>%
    mutate(changing.frequency = ifelse(family == tf.family, dbd.changing.count / total.count, changing.frequency)) %>%
    mutate(const.frequency = ifelse(family == tf.family, dbd.const.count / total.count, const.frequency))
}

dbd.changing.num.frequencies = dbd.changing.num.frequencies %>%
  bind_cols("family.num" = tf.families.num)

dbd.changing.num.frequencies = dbd.changing.num.frequencies %>%
  arrange(changing.frequency)

tf.families.ordered = dbd.changing.num.frequencies$family.num

dbd.changing.num.frequencies$family.num = factor(dbd.changing.num.frequencies$family.num, levels = dbd.changing.num.frequencies$family.num)

ggplot(data = data.frame("Category" = c(rep("Constant DBD combination", tf.family.count),
                                        rep("Changing DBD combination", tf.family.count)),
                         "Frequency" = c(dbd.changing.num.frequencies$const.frequency,
                                         dbd.changing.num.frequencies$changing.frequency),
                         "Family" = rep(dbd.changing.num.frequencies$family.num, 2)) %>%
         mutate(Category = factor(Category, levels = c("Constant DBD combination",
                                                       "Changing DBD combination"))),
       aes(x = Family, y = Frequency, group = Family)) +
  geom_col(aes(fill = Category)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

```{r}
dbd.changing.num.frequencies
```

Here, we selected TFs that have more than one isoform and more than one DBD in at least one isoform (N = `r dbd_changing_num_table %>% nrow()`). The number of such TFs in each family is given in parentheses. In `r (dbd_changing_num_table %>% filter(is_dbd_combination_changing) %>% nrow()) / (dbd_changing_num_table %>% nrow()) * 100`% of these TFs, the combination of DBDs changes between isoforms. The number of TF families in this plot is `r dbd_changing_num_table %>% pull(DBD) %>% unique() %>% length()`.

A plot for overall TF stats:

```{r, include=T}
ggplot(data = data.frame("Category" = c("Constant DBD combination",
                                        "Changing DBD combination"),
                         "Frequency" = c((dbd_changing_num_table %>% 
                                            filter(!is_dbd_combination_changing) %>% 
                                            nrow()) / 
                                         (dbd_changing_num_table %>% 
                                            nrow()),
                                         (dbd_changing_num_table %>% 
                                            filter(is_dbd_combination_changing) %>% 
                                            nrow()) / 
                                         (dbd_changing_num_table %>% 
                                            nrow())),
                         "Feature" = rep("TFs", 2)) %>%
         mutate(Category = factor(Category, levels = c("Constant DBD combination",
                                                       "Changing DBD combination"))),
       aes(x = Feature, y = Frequency, group = Feature)) +
  geom_col(aes(fill = Category)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

In the category of TFs with constant DBD combinations, production of alternative isoforms serves as a switch between the TF and the non-TF states by including or excluding whole DBD combinations. Hence, these combinations are probably encoded by a single exon in each TF of this category.

<!-- Functionally, it may mean that such TFs need the whole DBD combination to achieve DNA binding specificity, while partial DBD combinations would induce DNA binding specificity different from the normal one and consequently disrupt transcription regulation. Indeed, C2H2 zinc fingers were shown to have different DNA  binding specificities in different contexts (i. e., in the presence or absence of other closely located zinc fingers) [Garton et al., 2015](https://academic.oup.com/nar/article/43/19/9147/2528193). To test this hypothesis, we would need to check regions between DBDs from preserved combinations for selection against mutations that could lead to changes in splicing. -->

In the other category of TFs, where the combination of DBDs changes, production of alternative isoforms could lead to expression of TF isoforms with different DNA binding specificities, which may play a role in normal transcription regulation. 

Finally, different TFs from the same family may behave differently in terms of preserving or changing their DBD combination. It is interesting that in C2H2 ZF `r (dbd_changing_num_table %>% filter(!is_dbd_combination_changing) %>% filter(DBD == "C2H2 ZF") %>% nrow()) / (dbd_changing_num_table %>% filter(DBD == "C2H2 ZF") %>% nrow()) * 100`% of TFs do not change DBD combinations, although they can have many zinc finger DBDs in arrays. This also could mean that a considerable number of C2H2 ZF arrays are encoded by one exon and hence are either lost or retained as a whole.

## Investigate DBD sequences in TFs with maximum one DBD

Alternative splicing can change the sequence of a DBD and hence change its specificity or make it dysfunctional. For each TF, let us compare DBD sequences between its isoforms and infer how frequently alternative splicing changes a DBD sequence in different TF families.

First of all, let us obtain amino acid sequences of all DBDs (file "data/ensembl99/Homo_sapiens.GRCh38.pep.all.99.tsv" was obtained by running the command from "data/ensembl99/fa2tsv.txt" in "data/ensembl99/"):

```{r, include=T}
ens99_pep = read.delim("data/ensembl99/Homo_sapiens.GRCh38.pep.all.99.tsv", header = F) %>%
  dplyr::rename("protein_accession" = "V1",
                "protein_sequence" = "V2") %>%
  mutate(protein_sequence = as.character(protein_sequence))
dbd_seq_table = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(!DBD %in% c("Unknown", "Excluded")) %>%
  filter(ipr_accession %in% canonical_dbd_iprs_filtered) %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, protein_accession, ipr_accession, ipr_description, db, domain_accession, start, stop) %>%
  left_join(ens99_pep, by = c("protein_accession" = "protein_accession")) %>%
  mutate(dbd_sequence = stringr::str_sub(protein_sequence, start = start, end = stop)) %>%
  arrange(ensembl_gene_id, ensembl_transcript_id, as.numeric(start), as.numeric(stop))
```

Using TFs witn maximum one DBD, create a table of DBD variant counts per family:

```{r, include=T}
n_vardbd_table = dbd_seq_table %>%
  left_join(n_dbd_table, by = c("ensembl_gene_id" = "ensembl_gene_id")) %>%
  filter(max_n_dbds == 1) %>%
  group_by(ensembl_gene_id) %>%
  mutate(dbd_var_count = length(unique(dbd_sequence))) %>%
  ungroup() %>%
  dplyr::select(DBD, ensembl_gene_id, humantfs_gene_name, dbd_var_count) %>%
  arrange(DBD, ensembl_gene_id) %>%
  distinct()
```

Plot frequencies of different counts of DBD variants:

```{r, echo=F, fig.width=15, fig.height=5}
count_genes = function(domain_type) {
  return(dbd_gene_counts %>%
    filter(dbd == domain_type) %>%
    pull(n))
}
dbd_gene_counts = n_vardbd_table %>%
  dplyr::select(ensembl_gene_id, DBD) %>%
  distinct() %>%
  dplyr::count(DBD) %>%
  dplyr::rename("dbd" = "DBD") %>%
  mutate(dbd = as.character(dbd))
tf.families = dbd_gene_counts %>%
  pull(dbd)
tf.family.count = length(tf.families)
tf.families.num = unlist(purrr::map(tf.families,
                                    function(d) {
                                      paste0(d, " (", as.character(count_genes(d)), ")")
                                    }))
vardbd.frequencies = c()
for (tf.family in tf.families) { 
  vardbd.1.count = n_vardbd_table %>%
    filter(DBD == tf.family) %>%
    filter(dbd_var_count == 1) %>%
    nrow()
  vardbd.2.count = n_vardbd_table %>%
    filter(DBD == tf.family) %>%
    filter(dbd_var_count == 2) %>%
    nrow()
  vardbd.3.count = n_vardbd_table %>%
    filter(DBD == tf.family) %>%
    filter(dbd_var_count == 3) %>%
    nrow()
  vardbd.many.count = n_vardbd_table %>%
    filter(DBD == tf.family) %>%
    filter(dbd_var_count > 3) %>%
    nrow()
  total.count = vardbd.1.count + vardbd.2.count + vardbd.3.count + vardbd.many.count
  vardbd.frequencies = c(vardbd.frequencies, 
                         vardbd.1.count / total.count, 
                         vardbd.2.count / total.count, 
                         vardbd.3.count / total.count,
                         vardbd.many.count / total.count)
}
vardbd.1.frequencies = unlist(lapply(1:length(vardbd.frequencies), function(i) {if ((i %% 4) == 1) vardbd.frequencies[i]}))
vardbd.2.frequencies = unlist(lapply(1:length(vardbd.frequencies), function(i) {if ((i %% 4) == 2) vardbd.frequencies[i]}))
vardbd.3.frequencies = unlist(lapply(1:length(vardbd.frequencies), function(i) {if ((i %% 4) == 3) vardbd.frequencies[i]}))
vardbd.many.frequencies = unlist(lapply(1:length(vardbd.frequencies), function(i) {if ((i %% 4) == 0) vardbd.frequencies[i]}))
vardbd.1.frequencies.sorted = vardbd.1.frequencies[order(vardbd.1.frequencies, decreasing = T, method = "radix")]
vardbd.2.frequencies.sorted = vardbd.2.frequencies[order(vardbd.1.frequencies, decreasing = T, method = "radix")]
vardbd.3.frequencies.sorted = vardbd.3.frequencies[order(vardbd.1.frequencies, decreasing = T, method = "radix")]
vardbd.many.frequencies.sorted = vardbd.many.frequencies[order(vardbd.1.frequencies, decreasing = T, method = "radix")]
tf.families.num.sorted = tf.families.num[order(vardbd.1.frequencies, decreasing = T, method = "radix")]
tf.families.num.sorted = factor(tf.families.num.sorted, levels = tf.families.num.sorted)
vardbd.n.frequencies.sorted = c(vardbd.1.frequencies.sorted,
                                vardbd.2.frequencies.sorted,
                                vardbd.3.frequencies.sorted,
                                vardbd.many.frequencies.sorted)
ggplot(data = data.frame("Number_of_DBD_variants" = c(rep("1", tf.family.count),
                                                      rep("2", tf.family.count),
                                                      rep("3", tf.family.count),
                                                      rep(">3", tf.family.count)),
                         "Frequency" = vardbd.n.frequencies.sorted,
                         "Family" = rep(tf.families.num.sorted, 4)) %>%
         mutate(Number_of_DBD_variants = factor(Number_of_DBD_variants, levels = c("1",
                                                                                   "2",
                                                                                   "3",
                                                                                   ">3"))),
       aes(x = Family, y = Frequency, group = Family)) +
  geom_col(aes(fill = Number_of_DBD_variants)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

The number of TF families in the plot is `r n_vardbd_table %>% pull(DBD) %>% unique() %>% length()` and the number of TFs in the plot is `r n_vardbd_table %>% pull(ensembl_gene_id) %>% unique() %>% length()`, which is correct (see stats above for the number of TFs with maximum 1 DBD).

The number of TFs with 1 DBD variant `r n_vardbd_table %>% filter(dbd_var_count == 1) %>% nrow()` (`r (n_vardbd_table %>% filter(dbd_var_count == 1) %>% nrow()) / (n_vardbd_table %>% nrow()) * 100`%).

The number of TFs with 2 DBD variants `r n_vardbd_table %>% filter(dbd_var_count == 2) %>% nrow()` (`r (n_vardbd_table %>% filter(dbd_var_count == 2) %>% nrow()) / (n_vardbd_table %>% nrow()) * 100`%).

The number of TFs with 3 DBD variants `r n_vardbd_table %>% filter(dbd_var_count == 3) %>% nrow()` (`r (n_vardbd_table %>% filter(dbd_var_count == 3) %>% nrow()) / (n_vardbd_table %>% nrow()) * 100`%).

The number of TFs with >3 DBD variants `r n_vardbd_table %>% filter(dbd_var_count > 3) %>% nrow()` (`r (n_vardbd_table %>% filter(dbd_var_count > 3) %>% nrow()) / (n_vardbd_table %>% nrow()) * 100`%).

A plot for overall TF stats:

```{r, include=T}
ggplot(data = data.frame("Number_of_DBD_variants" = c("1", "2", "3", ">3"),
                         "Frequency" = c((n_vardbd_table %>% 
                                            filter(dbd_var_count == 1) %>% 
                                            nrow()) / 
                                         (n_vardbd_table %>% 
                                            nrow()),
                                         (n_vardbd_table %>% 
                                            filter(dbd_var_count == 2) %>% 
                                            nrow()) / 
                                         (n_vardbd_table %>% 
                                            nrow()),
                                         (n_vardbd_table %>% 
                                            filter(dbd_var_count == 3) %>% 
                                            nrow()) / 
                                         (n_vardbd_table %>% 
                                            nrow()),
                                         (n_vardbd_table %>% 
                                            filter(dbd_var_count > 3) %>% 
                                            nrow()) / 
                                         (n_vardbd_table %>% 
                                            nrow())),
                         "Feature" = rep("TFs", 4)) %>%
         mutate(Number_of_DBD_variants = factor(Number_of_DBD_variants, levels = c("1",
                                                                                   "2",
                                                                                   "3",
                                                                                   ">3"))),
       aes(x = Feature, y = Frequency, group = Feature)) +
  geom_col(aes(fill = Number_of_DBD_variants)) +
  scale_y_continuous(limits = c(0, 1), breaks = pretty_breaks(n = 11)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

---

Removal of a part of a DBD will have decisive consequences if DNA-contacting residues get removed. Hence, let us investigate how frequently these residues are removed from DBDs by alternative splicing.

First, let us select TFs that:

1) Have maximum one DBD, and

2) Have more than one DBD sequence variant.

Let us also select representative sequences for each DBD sequence variant (several isoforms of the same TF may have the same DBD sequence, so we need to take only one of them for further alignment):

```{r, include=T}
dbd_fasta_table = dbd_seq_table %>% # only canonical DBDs in TFs not from "Unknown" or "Excluded"
  left_join(n_vardbd_table, 
            by = c("ensembl_gene_id" = "ensembl_gene_id")) %>%
  left_join(n_dbd_table %>%
              dplyr::select(ensembl_gene_id, max_n_dbds), 
            by = c("ensembl_gene_id" = "ensembl_gene_id")) %>%
  filter(max_n_dbds == 1) %>% # maximum one DBD
  filter(dbd_var_count > 1) %>% # more than one DBD variant
  arrange(DBD, ensembl_gene_id, ensembl_transcript_id, as.numeric(start), as.numeric(stop)) %>%
  group_by(ensembl_gene_id, 
           ensembl_transcript_id, 
           ipr_accession) %>%
  do(mutate(., sequence_header = stringr::str_c(.$ensembl_gene_id, 
                                                .$humantfs_gene_name, 
                                                .$ensembl_transcript_id, 
                                                .$protein_accession,
                                                .$ipr_accession,
                                                sep  ="_"))) %>%
  ungroup() %>%
  dplyr::select(sequence_header, 
                ensembl_gene_id, 
                humantfs_gene_name, 
                ensembl_transcript_id, 
                protein_accession, 
                ipr_accession, 
                dbd_sequence)
representative_headers = dbd_fasta_table %>%
  group_by(ensembl_gene_id,
           dbd_sequence) %>%
  do(head(., 1)) %>%
  ungroup() %>%
  dplyr::select(sequence_header) %>%
  mutate(representative = T)
  
dbd_fasta_table = dbd_fasta_table %>%
  left_join(representative_headers, 
            by = c("sequence_header" = "sequence_header")) %>%
  mutate(representative = ifelse(is.na(representative), F, T))
```

This table has `r dbd_fasta_table %>% pull(ensembl_gene_id) %>% unique() %>% length()` TFs from `r dbd_fasta_table %>% left_join(n_vardbd_table, by = c("ensembl_gene_id" = "ensembl_gene_id", "humantfs_gene_name" = "humantfs_gene_name")) %>% pull(DBD) %>% unique() %>% length()` families, `r dbd_fasta_table %>% pull(ensembl_transcript_id) %>% unique() %>% length()` isoforms and `r dbd_fasta_table %>% filter(representative) %>% nrow()` unique DBD sequences.

Next, we manually selected relevant protein-DNA structures from PDB (data/results/TF_structures.xlsx) and the corresponding lists of hydrogen bonds (data/npidb/h_bonds_2020-10-20_selected) and sequences in FASTA (data/npidb/sequences_from_complexes_2020-10-20_selected). We also preprocessed the selected FASTA files to retain only protein sequences, one per FASTA file (so we split FASTA files with multiple protein chains;  data/results/npidb_2020-10-20_sequences_from_complexes_selected_preprocessed). 

Further, let us form FASTA files with representative DBD sequences and protein sequences from corresponding structures to do multiple sequence alignment:

```{r, include=T}
protein_chain_fastas = list.files(path = "data/results/npidb_2020-10-20_sequences_from_complexes_selected_preprocessed")
msa_fastas = data.frame(structure_id = character(),
                        chain_id = character(),
                        structure_header = character(),
                        structure_sequence = character(),
                        stringsAsFactors = F)
for (protein_chain_fasta in protein_chain_fastas) {
  structure_id = toupper(substring(protein_chain_fasta, first = 1, last = 4))
  chain_id = substring(protein_chain_fasta, first = 6, last = 6)
  current_fasta = read.fasta(file = file.path("data/results/npidb_2020-10-20_sequences_from_complexes_selected_preprocessed",
                                              protein_chain_fasta), 
                             seqtype = "AA",
                             as.string = T)
  msa_fastas = msa_fastas %>%
    bind_rows(data_frame(structure_id = structure_id,
                         chain_id = chain_id,
                         structure_header = unlist(getName(current_fasta)),
                         structure_sequence = unlist(seqinr::getSequence(current_fasta, as.string = T)),
                         stringsAsFactors = F))
}
tf_structure_table_wb = loadWorkbook("data/results/TF_structures.xlsx")
tf_structure_table = readWorksheet(tf_structure_table_wb, sheet = "Sheet1", header = TRUE)
msa_fastas = tf_structure_table %>%
  left_join(msa_fastas,
            by = c("PDB_ID" = "structure_id")) %>%
  left_join(dbd_fasta_table %>% filter(representative),
            by = c("TF" = "humantfs_gene_name"))
msa_fastas_out = msa_fastas %>%
  group_by(TF, structure_header) %>%
  mutate(msa_headers = paste0(c(unique(structure_header),
                                sequence_header),
                              collapse = "|")) %>%
  mutate(msa_sequences = paste0(c(unique(structure_sequence),
                                  dbd_sequence),
                                collapse = "|")) %>%
  mutate(msa_genename = unique(TF)) %>%
  ungroup() %>%
  dplyr::select(structure_header, msa_headers, msa_sequences, msa_genename) %>%
  distinct()
msa_fasta_headers = msa_fastas_out %>%
  pull(msa_headers) %>%
  unique()
for (msa_fasta_header in msa_fasta_headers) {
  write.fasta(as.list(unlist(stringr::str_split(msa_fastas_out %>%
                                                  filter(msa_headers == msa_fasta_header) %>%
                                                  pull(msa_sequences),
                                                pattern = fixed("|")))),
              as.list(unlist(stringr::str_split(msa_fastas_out %>%
                                                  filter(msa_headers == msa_fasta_header) %>%
                                                  pull(msa_headers),
                                                pattern = fixed("|")))),
              file.path("data/results/dbd_and_structure_sequences_for_msa/",
                        paste0(msa_fastas_out %>% 
                                 filter(msa_headers == msa_fasta_header) %>%
                                 pull(msa_genename),
                               "_",
                               msa_fastas_out %>% 
                                 filter(msa_headers == msa_fasta_header) %>%
                                 pull(structure_header),
                               ".fa")))
}
```

Number of TFs: `r msa_fastas %>% pull(TF) %>% unique() %>% length()`.

Number of structures: `r msa_fastas %>% pull(PDB_ID) %>% unique() %>% length()`.

Number of FASTA files (future alignments): `r length(msa_fasta_headers)` (one per protein chain per structure per TF).

Number of structure-chain pairs (unique sequences in FASTA files): `r msa_fastas %>% pull(structure_header) %>% unique() %>% length()` (some chain sequences are used in more than one FASTA file because they are relevant to more than one TF).

Now let us run multiple sequence alignment for each FASTA file and manually select alignments to retain:

```{r, include=T}
path_to_fasta = "data/results/dbd_and_structure_sequences_for_msa"
path_to_msa = "data/results/all_msa_results"
all_msa_results = list()
for (fasta_file in list.files(path_to_fasta)) {
  m = msa(inputSeqs = file.path(path_to_fasta, fasta_file),
          type = "protein",
          method = "ClustalOmega",
          order = "input")
  m_name = unlist(stringr::str_split(fasta_file, pattern = fixed(".")))[1]
  m_df = as.data.frame(m@unmasked)
  all_msa_results[[`m_name`]] = m_df
  write.table(m_df, 
              file.path(path_to_msa, 
                        paste0(m_name, "_msa.txt")),
              row.names = F,
              col.names = F,
              quote = F)
}
```

Remove the following alignments where DBD sequences did not align to the protein chain sequence or the protein chain sequence corresponded to the DBD sequences worse than in other alignments:

```{r, include=T}
aln_to_remove1 = list("ARNTL_4h10_B",
                      "CREB1_5zko_G",
                      "CREB1_5zko_H",
                      "FOS_1s9k_C",
                      "FOS_1s9k_E",
                      "FOSB_5vpf_B",
                      "FOSB_5vpe_D",
                      "GRHL1_5mpf_A",
                      "HSF1_5d5v_B",
                      "HSF1_5d5u_B",
                      "IRF3_2pi0_A",
                      "IRF3_2pi0_D",
                      "MBD2_6c1v_B",
                      "MBD2_6c1u_A",
                      "MBD2_6c1a_A",
                      "MBD2_6c1a_B",
                      "MXD1_1nlw_B",
                      "NFKB1_2o61_A",
                      "NFKB1_3gut_A",
                      "NFKB1_3gut_C",
                      "NR1H2_4nqa_A",
                      "NR1H2_4nqa_C",
                      "NR1H2_4nqa_D",
                      "NR3C1_6bqu_A",
                      "NR3C1_6bqu_B",
                      "PAX5_1k78_B",
                      "PAX5_1k78_I",
                      "PBX1_1b72_A",
                      "PBX1_1puf_A",
                      "PPARG_3dzu_A",
                      "PPARG_3e00_G",
                      "PPARG_3e00_E",
                      "PPARG_3e00_A",
                      "PPARG_3dzy_G",
                      "PPARG_3dzy_E",
                      "PPARG_3dzy_A",
                      "PPARG_3dzu_G",
                      "PPARG_3dzu_E",
                      "RARA_1dsz_B",
                      "RARA_6xwg_C",
                      "RARB_5uan_A",
                      "RARB_5uan_C",
                      "RARB_5uan_D",
                      "RBPJ_6py8_F",
                      "RBPJ_6py8_B",
                      "RBPJ_3v79_R",
                      "RBPJ_3v79_M",
                      "RBPJ_3v79_K",
                      "RBPJ_3nbn_F",
                      "RBPJ_3nbn_E",
                      "RBPJ_3nbn_C",
                      "RBPJ_3nbn_B",
                      "RBPJ_2f8x_M",
                      "RBPJ_2f8x_K",
                      "RELA_3gut_B",
                      "RELA_3gut_D",
                      "RFX4_1dp7_P",
                      "RUNX1_1h9d_B",
                      "SMAD3_5od6_A",
                      "SMAD5_6fzs_A",
                      "TBP_1c9b_A",
                      "TBP_4roe_A",
                      "TBP_4rod_A",
                      "TBP_4roc_A",
                      "TBP_1nvp_D",
                      "TBP_1nvp_C",
                      "TBP_1nvp_B",
                      "TBP_1jfi_B",
                      "TBP_1jfi_A",
                      "TCF3_2ypb_A",
                      "TFDP2_1cf7_A",
                      "THRB_2nll_A",
                      "TP53_3q06_A",
                      "TP53_3q06_B",
                      "TP53_3q06_C",
                      "TP53_3q06_D",
                      "TP53_2ata_C",
                      "TP53_2ahi_C",
                      "TP53_2ahi_D",
                      "TP53_2ata_A",
                      "TP53_2ahi_A",
                      "TP53_2ac0_C",
                      "TP53_2ac0_D",
                      "TP53_2ady_A",
                      "TP53_1tup_B",
                      "TP53_1tup_C",
                      "TP53_1tsr_B",
                      "TP53_1tsr_C",
                      "TP63_3qyn_A",
                      "TP63_3qyn_B",
                      "TP63_3qyn_D",
                      "TP63_3us0_A",
                      "TP63_3us0_B",
                      "TP63_3us0_D")
selected1_msa_results = all_msa_results[!names(all_msa_results) %in% aln_to_remove1]
```

Number of TFs: `r length(unique(unlist(map(stringr::str_split(names(selected1_msa_results), fixed("_")), function(x) {x[1]}))))`.

Hence, `r length(unique(unlist(map(stringr::str_split(names(all_msa_results), fixed("_")), function(x) {x[1]})))) - length(unique(unlist(map(stringr::str_split(names(selected1_msa_results), fixed("_")), function(x) {x[1]}))))` TFs are excluded because their DBDs did not align to the corresponding sequences from structures. These TFs are: `r setdiff(unique(unlist(map(stringr::str_split(names(all_msa_results), fixed("_")), function(x) {x[1]}))), unique(unlist(map(stringr::str_split(names(selected1_msa_results), fixed("_")), function(x) {x[1]}))))`.

Number of structures: `r length(unique(unlist(map(stringr::str_split(names(selected1_msa_results), fixed("_")), function(x) {x[2]}))))`.

Number of retained alignments: `r length(selected1_msa_results)`.

Number of removed alignments: `r length(aln_to_remove1)`.

Number of structure-chain pairs: `r length(unique(unlist(map(stringr::str_split(names(selected1_msa_results), fixed("_")), function(x) {paste0(x[2], "_", x[3])}))))`.

Next, let us retain alignments with maximal number of residues annotated in the structure (if several structures have the same annotation, then retain any one of them).

First of all, read in and parse lists of protein-DNA contacts from NPI DB:

```{r, include=T}
protein_dna_hbond_table = data.frame(na_atom = character(),
                                     na_base = character(),
                                     na_position = character(),
                                     aa_atom = character(),
                                     aa_residue = character(),
                                     aa_position = character(),
                                     aa_chain = character(),
                                     bond_type = character(),
                                     structure_id = character(),
                                     stringsAsFactors = F)
path_to_hbond_tables = "data/results/npidb_2020-10-20_hbonds_from_complexes_selected_preprocessed"
for (hbond_file in list.files(path_to_hbond_tables)) {
  structure_id = unlist(stringr::str_split(hbond_file, pattern = fixed(".")))[1]
  
  bond_type = unlist(stringr::str_split(unlist(stringr::str_split(hbond_file, 
                                                                  pattern = fixed(".")))[4], 
                                               pattern = fixed("_")))[2]
  
  hbond_table = read.delim(file.path(path_to_hbond_tables, hbond_file),
                           stringsAsFactors = F) %>%
    group_by(NA.Atom, Protein.Atom) %>%
    mutate(na_atom =  unlist(stringr::str_split(unlist(stringr::str_split(NA.Atom, 
                                                                          pattern = fixed(".")))[2],
                                                pattern = fixed("/")))[1]) %>%
    ungroup() %>%
    mutate(na_base = substr(NA.Atom, start = 2, stop = 2)) %>%
    group_by(NA.Atom, Protein.Atom) %>%
    mutate(na_base_position = unlist(stringr::str_split(NA.Atom, 
                                                        pattern = fixed(":")))[1]) %>%
    ungroup() %>%
    mutate(na_position = substr(na_base_position,
                                start = 3,
                                stop = nchar(na_base_position))) %>%
    dplyr::select(-na_base_position) %>%
    group_by(NA.Atom, Protein.Atom) %>%
    mutate(aa_atom = unlist(stringr::str_split(unlist(stringr::str_split(Protein.Atom, 
                                                                         pattern = fixed(".")))[2],
                                               pattern = fixed("/")))[1]) %>%
    ungroup() %>%
    mutate(aa_residue = substr(Protein.Atom, start = 1, stop = 3)) %>%
    group_by(NA.Atom, Protein.Atom) %>%
    mutate(aa_residue_position = unlist(stringr::str_split(Protein.Atom, 
                                                           pattern = fixed(":")))[1]) %>%
    ungroup() %>%
    mutate(aa_position = substr(aa_residue_position,
                                start = 4,
                                stop = nchar(aa_residue_position))) %>%
    dplyr::select(-aa_residue_position) %>%
    group_by(NA.Atom, Protein.Atom) %>%
    mutate(aa_chain = unlist(stringr::str_split(unlist(stringr::str_split(Protein.Atom, 
                                                                          pattern = fixed(":")))[2],
                                                pattern = fixed(".")))[1]) %>%
    ungroup() %>%
    mutate(bond_type = bond_type) %>%
    mutate(structure_id = structure_id)
  
  protein_dna_hbond_table = protein_dna_hbond_table %>%
    bind_rows(hbond_table %>%
                dplyr::select(na_atom,
                              na_base,
                              na_position,
                              aa_atom,
                              aa_residue,
                              aa_position,
                              aa_chain,
                              bond_type,
                              structure_id))
}
```

```{r}
protein_dna_hbond_table %>%
  filter(structure_id == "1b72") %>%
  filter(aa_chain == "A")
#head(protein_dna_hbond_table)
```

Number of TFs: `r protein_dna_hbond_table %>% left_join(msa_fastas %>% dplyr::select(TF, PDB_ID) %>% mutate(PDB_ID = tolower(PDB_ID)), by = c("structure_id" = "PDB_ID")) %>% pull(TF) %>% unique() %>% length()`.

Number of structures: `r protein_dna_hbond_table %>% pull(structure_id) %>% unique() %>% length()`.

Number of structure-chain pairs: `r protein_dna_hbond_table %>% dplyr::select(aa_chain, structure_id) %>% distinct() %>% nrow()`.

This number of structure-chain pairs is lower than the total number of alignments at the beginning because some protein chains, although aligned to DBD sequences, do not have contacts with DNA: 

```{r, include=T}
diff_structure_headers = setdiff(msa_fastas %>% 
                                   pull(structure_header) %>% 
                                   unique(), 
                                 protein_dna_hbond_table %>% 
                                   mutate(structure_header = paste0(structure_id, "_", aa_chain)) %>%
                                   pull(structure_header) %>% 
                                   unique())
diff_structure_headers
```

(Checked some of these pairs in NPI DB.)

There are `r length(diff_structure_headers)` such pairs, while it should be `r msa_fastas %>% pull(structure_header) %>% unique() %>% length() - protein_dna_hbond_table %>% dplyr::select(aa_chain, structure_id) %>% distinct() %>% nrow()`. The difference is explained by the fact that there is a structure-chain pair for which NPI DB calculated protein-DNA interactions but does not give a sequence:

```{r, include=T}
setdiff(protein_dna_hbond_table %>% 
          mutate(structure_header = paste0(structure_id, "_", aa_chain)) %>%
          pull(structure_header) %>% 
          unique(),
        msa_fastas %>% 
          pull(structure_header) %>% 
          unique())
```

This is clearly an error in NPI DB. So we just need to remove this structure-chain pair from the analysis:

```{r, include=T}
protein_dna_hbond_table = protein_dna_hbond_table %>%
  filter((structure_id != "5odg") | 
         (aa_chain != "B"))
```

Now the number of structure-chain pairs is `r protein_dna_hbond_table %>% dplyr::select(aa_chain, structure_id) %>% distinct() %>% nrow()`, which is correct. 

Number of TFs: `r protein_dna_hbond_table %>% left_join(msa_fastas %>% dplyr::select(TF, PDB_ID) %>% mutate(PDB_ID = tolower(PDB_ID)), by = c("structure_id" = "PDB_ID")) %>% pull(TF) %>% unique() %>% length()`.

Number of structures: `r protein_dna_hbond_table %>% pull(structure_id) %>% unique() %>% length()`.

Retain only structures and chains with good alignments:

```{r, include=T}
aln_headers_to_remove1 = list("4h10_B",
                              "5zko_G",
                              "5zko_H",
                              "1s9k_C",
                              "1s9k_E",
                              "5vpf_B",
                              "5vpe_D",
                              "5mpf_A",
                              "5d5v_B",
                              "5d5u_B",
                              "2pi0_A",
                              "2pi0_D",
                              "6c1v_B",
                              "6c1u_A",
                              "6c1a_A",
                              "6c1a_B",
                              "1nlw_B",
                              "2o61_A",
                              "4nqa_A",
                              "4nqa_C",
                              "4nqa_D",
                              "6bqu_A",
                              "6bqu_B",
                              "1k78_B",
                              "1k78_I",
                              "1b72_A",
                              "1puf_A",
                              "3dzu_A",
                              "3e00_G",
                              "3e00_E",
                              "3e00_A",
                              "3dzy_G",
                              "3dzy_E",
                              "3dzy_A",
                              "3dzu_G",
                              "3dzu_E",
                              "1dsz_B",
                              "6xwg_C",
                              "5uan_A",
                              "5uan_C",
                              "5uan_D",
                              "6py8_F",
                              "6py8_B",
                              "3v79_R",
                              "3v79_M",
                              "3v79_K",
                              "3nbn_F",
                              "3nbn_E",
                              "3nbn_C",
                              "3nbn_B",
                              "2f8x_M",
                              "2f8x_K",
                              "1dp7_P",
                              "1h9d_B",
                              "5od6_A",
                              "6fzs_A",
                              "1c9b_A",
                              "4roe_A",
                              "4rod_A",
                              "4roc_A",
                              "1nvp_D",
                              "1nvp_C",
                              "1nvp_B",
                              "1jfi_B",
                              "1jfi_A",
                              "2ypb_A",
                              "1cf7_A",
                              "2nll_A",
                              "3q06_A",
                              "3q06_B",
                              "3q06_C",
                              "3q06_D",
                              "2ata_C",
                              "2ahi_C",
                              "2ahi_D",
                              "2ata_A",
                              "2ahi_A",
                              "2ac0_C",
                              "2ac0_D",
                              "2ady_A",
                              "1tup_B",
                              "1tup_C",
                              "1tsr_B",
                              "1tsr_C",
                              "3qyn_A",
                              "3qyn_B",
                              "3qyn_D",
                              "3us0_A",
                              "3us0_B",
                              "3us0_D")
selected1_protein_dna_hbond_table = protein_dna_hbond_table %>%
  mutate(aln_header = paste0(structure_id, "_", aa_chain)) %>%
  filter(!aln_header %in% unlist(aln_headers_to_remove1))
```

Number of TFs: `r selected1_protein_dna_hbond_table %>% left_join(msa_fastas %>% dplyr::select(TF, PDB_ID) %>% mutate(PDB_ID = tolower(PDB_ID)), by = c("structure_id" = "PDB_ID")) %>% pull(TF) %>% unique() %>% length()`.

Number of structures: `r selected1_protein_dna_hbond_table %>% pull(structure_id) %>% unique() %>% length()`. Hence, it turns out that we filtered out one more structure in protein-DNA contact lists than in alignments:

```{r, include=T}
setdiff(unique(unlist(map(stringr::str_split(names(selected1_msa_results), fixed("_")), function(x) {x[2]}))),
        selected1_protein_dna_hbond_table %>% pull(structure_id) %>% unique())
```

This is explained shotly.

Number of structure-chain pairs: `r selected1_protein_dna_hbond_table %>% pull(aln_header) %>% unique() %>% length()`.

Let us check if the structure-chain pairs in the protein-DNA contact table and in our retained alignments are the same:

```{r, include=T}
setdiff(unlist(purrr::map(names(selected1_msa_results), 
                          function(x) {
                            paste0(unlist(stringr::str_split(x, fixed("_")))[2:3], collapse = "_")
                          })), 
        selected1_protein_dna_hbond_table %>% pull(aln_header) %>% unique())
```

5od6 has protein-DNA contacts calculated only for the A chain, not for B. Hence, we need to remove the 5od6_B alignment from the analysis. This means that we need to return 5od6_A, because this alignment is also good. The TF is SMAD3.

```{r, include=T}
setdiff(selected1_protein_dna_hbond_table %>% pull(aln_header) %>% unique(),
        unlist(purrr::map(names(selected1_msa_results), 
                          function(x) {
                            paste0(unlist(stringr::str_split(x, fixed("_")))[2:3], collapse = "_")
                          })))
```

So, let us restore 5od6_A in the alignments and protein-DNA contact lists:

```{r, include=T}
selected1_protein_dna_hbond_table = selected1_protein_dna_hbond_table %>%
  bind_rows(protein_dna_hbond_table %>%
              filter((structure_id == "5od6") &
                     (aa_chain == "A"))) %>%
  mutate(aln_header = ifelse((structure_id == "5od6") & 
                             (aa_chain == "A"), 
                             "5od6_A", 
                             aln_header))
selected1_msa_results[["SMAD3_5od6_A"]] = all_msa_results[["SMAD3_5od6_A"]]
```

Number of TFs: `r selected1_protein_dna_hbond_table %>% left_join(msa_fastas %>% dplyr::select(TF, PDB_ID) %>% mutate(PDB_ID = tolower(PDB_ID)), by = c("structure_id" = "PDB_ID")) %>% pull(TF) %>% unique() %>% length()`.

Number of structures: `r selected1_protein_dna_hbond_table %>% pull(structure_id) %>% unique() %>% length()`.

Number of alignments: `r length(selected1_msa_results)`.

Number of structure-chain pairs: `r selected1_protein_dna_hbond_table %>% pull(aln_header) %>% unique() %>% length()`.

Finally, let us retain only the alignments with the highest number of annotated protein-DNA contacts (choose any alignment with the highest number of annotated contacs if there are several such alignments):

```{r, include=T}
general_protein_dna_hbond_table = selected1_protein_dna_hbond_table %>%
  left_join(tf_structure_table %>%
              mutate(PDB_ID = tolower(PDB_ID)),
            by = c("structure_id" = "PDB_ID")) %>%
  filter((aln_header != "3gut_A") | (TF != "NFKB1")) %>%
  filter((aln_header != "3gut_C") | (TF != "NFKB1")) %>%
  filter((aln_header != "3gut_B") | (TF != "RELA")) %>%
  filter((aln_header != "3gut_D") | (TF != "RELA")) %>%
  arrange(TF, aln_header) %>%
  group_by(aln_header) %>%
  add_count() %>%
  ungroup() %>%
  group_by(TF) %>%
  mutate(max_n = max(n)) %>%
  ungroup() %>%
  filter(n == max_n) %>%
  group_by(TF) %>%
  mutate(first_aln_header = head(aln_header, 1)) %>%
  ungroup() %>%
  filter(aln_header == first_aln_header)
aln_to_retain = general_protein_dna_hbond_table %>%
  mutate(TF_aln_header = paste0(TF, "_", aln_header)) %>%
  pull(TF_aln_header) %>%
  unique()
selected2_msa_results = selected1_msa_results[names(selected1_msa_results) %in% aln_to_retain]
```

```{r}
general_protein_dna_hbond_table %>%
  filter(TF == "TP53")
```

Print out ARNTL:

```{r}
t = general_protein_dna_hbond_table %>%
  #filter(TF == "ARNTL") %>%
  filter(TF == "TP53") %>%
  arrange(as.numeric(aa_position), na_base)
write.table(t, file = "data/results/TP53_2ac0_A_annotation_table.tsv", quote = F, sep = "\t", row.names = F)
```

Number of TFs: `r general_protein_dna_hbond_table %>% pull(TF) %>% unique() %>% length()`.

Number of structures: `r general_protein_dna_hbond_table %>% pull(structure_id) %>% unique() %>% length()`.

Number of retained alignments: `r length(selected2_msa_results)`.

Number of structure-chain pairs: `r general_protein_dna_hbond_table %>% pull(aln_header) %>% unique() %>% length()`.

Check:
Leftmost K in 2: FOXO4_3l2c_A
Leftmost sequences in gaps in 1 and 2: GRHL1_5mpf_B
Rightmost E in 3: IRF3 (all retained)
Leftmost MERK in 2: MBD3_6cc8_A
Rightmost KL and KET in 3 and 4: MECP2
Leftmost S in 3: MXD1_1nlw_A
Leftmost QSSI in 3: NR4A2
Rightmost IIRTKVQQP in 3: PAX5 (all retained)
RELA: several mismatches with the sequence from structures
Rightmost RH in 2 and NT in 3 in RUNX1_1h9d_A
Leftmost MSCLHPRQTWKGAALVHRKAWWMG in 3: SMAD3
Leftmost NL, GL and NLE in 2, 3 and 4: TCF3_2ypb_B
Leftmost and rightmost mismatches, several mismatches in the middle: TP53

---

## Analyse non-DBDs

Generate the raw table of non-DBDs:

```{r, include=T}
tf.matches = read.delim("data/results/domain_analysis/tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl.tsv")

# iprs.excluded.only = tf.matches %>%
#   dplyr::select(ipr_accession, DBD) %>%
#   distinct() %>%
#   mutate(is.excluded = ifelse(DBD == "Excluded" | DBD == "Unknown",
#                               T, F)) %>%
#   group_by(ipr_accession) %>%
#   mutate(is.excluded.only = Reduce(function(x, y) x & y,
#                                    is.excluded)) %>%
#   ungroup() %>%
#   filter(is.excluded.only) %>%
#   pull(ipr_accession) %>%
#   unique()

nondbd.annot.raw = tf.matches %>%
  filter(DBD != "Excluded" & DBD != "Unknown") %>%
  filter(is.na(represents_family)) %>%
  filter(!is.na(ipr_accession)) %>%
  dplyr::select(ipr_accession, ipr_description) %>%
  distinct()

# nondbd.annot.filtered = nondbd.annot %>%
#   filter(!InterPro_ID %in% iprs.excluded.only) %>%
#   filter(InterPro_ID %in% tf.matches$ipr_accession)

# write.table(nondbd.annot.filtered, 
#             file = "analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filtered.csv", 
#             quote = F, 
#             sep = "\t", 
#             row.names = F)

write.table(nondbd.annot.raw,
            file = "analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_raw.csv",
            quote = F,
            sep = "\t",
            row.names = F)

# nondbd.iprs.annotation = read.delim("analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filtered.csv")
#
# nondbd.annot.curated = nondbd.annot.raw %>%
#   left_join(nondbd.iprs.annotation,
#             by = c("ipr_accession" = "InterPro_ID",
#                    "ipr_description" = "Domain_name"))
# 
# write.table(nondbd.annot.curated,
#             file = "analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filled.csv",
#             quote = F,
#             sep = "\t",
#             row.names = F)
```

Load the table of manually curated non-DBDs:

```{r, include=T}
#nondbd.annot = read.delim("classify_domains/output/classify_domains/Other_domains_manually_curated.csv")
#nondbd.annot = read.delim("analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filtered.csv")
nondbd.annot = read.delim("analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filled.csv")
```

Summarise molecular functions:

```{r, include=T}
nondbd.annot.summary = nondbd.annot %>%
  count(Molecular_function) %>%
  arrange(desc(n))

nondbd.annot.summary
```

Write down the overall stats table:

```{r, include=T}
write.table(nondbd.annot.summary, 
            file = "analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_summary_mol_function_dbdminus.tsv", 
            quote = F, 
            sep = "\t", 
            row.names = F)
```

Summarise molecular mechanisms:

```{r, include=T}
count_mol_mechanisms = function(mol.mechanism) {
  return(nondbd.annot %>%
           filter(stringr::str_detect(Molecular_mechanism, fixed(mol.mechanism))) %>%
           nrow())
}

mol_mechanism_summary = data.frame(Molecular_mechanism = unique(unlist(stringr::str_split(nondbd.annot %>%
                                                                                            pull(Molecular_mechanism),
                                                                                          fixed("; "))))) %>%
  rowwise() %>%
  mutate(n = count_mol_mechanisms(Molecular_mechanism))

nondbd.type.number = nondbd.annot %>%
  pull(ipr_accession) %>%
  unique() %>%
  length()

mol_mechanism_summary %>%
  mutate(frequency = n / nondbd.type.number) %>%
  arrange(desc(n)) %>%
  head(10) %>%
  mutate(Molecular_mechanism = factor(Molecular_mechanism, levels = Molecular_mechanism)) %>%
  ggplot(aes(x = Molecular_mechanism, y = frequency)) +
    geom_col(fill = "blue") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Summarise all molecular functions of non-DBDs:

```{r, include=T, fig.height=7}
count_mol_functions = function(mol.function) {
  return(nondbd.annot %>%
           filter(stringr::str_detect(Molecular_function, fixed(mol.function))) %>%
           nrow())
}

mol_function_summary = data.frame(Molecular_function = unique(unlist(stringr::str_split(nondbd.annot %>%
                                                                                          pull(Molecular_function),
                                                                                        fixed("; "))))) %>%
  rowwise() %>%
  mutate(n = count_mol_functions(Molecular_function))

nondbd.type.number = nondbd.annot %>%
  pull(ipr_accession) %>%
  unique() %>%
  length()

mol_function_summary %>%
  mutate(frequency = n / nondbd.type.number) %>%
  arrange(desc(n)) %>%
  head(10) %>%
  mutate(Molecular_function = factor(Molecular_function, levels = Molecular_function)) %>%
  ggplot(aes(x = Molecular_function, y = frequency)) +
    geom_col(fill = "red") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

This plot shows the most popular non-DBD types (including non-canonical DBDs).

Check the actual frequency of non-DBDs of different types in expressed TF isoforms:

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl = read.delim("data/results/domain_analysis/tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl.tsv",
            header = T)

selected.table.log2.med = read.delim("data/results/gtex8_processed/tfs_nontfs_selected_table_tpm_log2_med_filtered.tsv",
                                     header = T,
                                     sep = "\t",
                                     stringsAsFactors = F)

tissue.names = names(selected.table.log2.med)

tf.isoforms.all = dbd_yes_no_tx_table %>% 
  pull(ensembl_transcript_id)

isoforms.expressed.all = selected.table.log2.med %>%
  tibble::rownames_to_column("ensembl_transcript_id") %>%
  filter(ensembl_transcript_id %in% tf.isoforms.all) %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., is.expressed = (any(.[, tissue.names] >= 1)))) %>%
  ungroup() %>%
  filter(is.expressed)

nodbd.annot.in.isoforms = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(ensembl_transcript_id %in% isoforms.expressed.all$ensembl_transcript_id) %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "ipr_accession",
                   "ipr_description" = "ipr_description")) %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD, represents_family,
                ensembl_transcript_id, ipr_accession, ipr_description, int_start, int_stop,
                Molecular_function) %>%
  distinct() %>%
  filter(!is.na(ipr_accession)) %>% # retain only domain+ isoforms
  filter(is.na(represents_family)) # retain only rows for non-DBDs

mol.function.summary.real = data.frame(Molecular_function = unlist(stringr::str_split(nodbd.annot.in.isoforms %>%
                                                                                        pull(Molecular_function),
                                                                                      fixed("; ")))) %>%
  count(Molecular_function)

mol.function.summary.real %>%
  mutate(frequency = n / nrow(nodbd.annot.in.isoforms)) %>%
  arrange(desc(n)) %>%
  head(10) %>%
  mutate(Molecular_function = factor(Molecular_function, levels = Molecular_function)) %>%
  ggplot(aes(x = Molecular_function, y = frequency)) +
    geom_col(fill = "red") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

So, the most frequent type of non-DBDs is a transcription repression domain. Check which domains have this type and from which TF families the corresponding isoforms come from:

```{r, include=T}
nodbd.annot.in.isoforms %>%
  filter(stringr::str_detect(Molecular_function, fixed("Transcription repression"))) %>%
  dplyr::select(ipr_accession, ipr_description) %>%
  count(ipr_accession, ipr_description) %>%
  arrange(desc(n))
```

Hence, the most frequent transcription repression domain is KRAB. Here are TF families where it occurs:

```{r, include=T}
nodbd.annot.in.isoforms %>%
  filter(ipr_accession == "IPR001909") %>% # Select only the KRAB domain
  dplyr::select(DBD) %>%
  count(DBD) %>%
  arrange(desc(n))
```

As expected, it comes from the C2H2 ZF family.

Summarise RNA-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_function, "RNA-binding")) %>%
  dplyr::select(InterPro_ID, Domain_name)
```

Summarise DBDs:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_function, "DBD")) %>%
  dplyr::select(InterPro_ID, Domain_name)
```

Summarise ligand-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_function, "Ligand-binding")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_subfunction)
```

Summarise catalytic domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_function, "Catalytic")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_subfunction)
```

Summarise protein / nucleic acid-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_function, "Protein / Nucleic acid-binding")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_subfunction)
```

Summarise protein / nucleic acid-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_function, "Lipid-binding")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_subfunction)
```

Summarise structural domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_function, "Structural")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_subfunction)
```

Print out unclear domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_function, "Unclear")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_subfunction)
```

Domains of unknown function: 16.
Other domains (potentially known but not defined clearly in InterPro): 70.

Summarise molecular mechanisms:

```{r, include=T}
# nondbd.annot.summary = nondbd.annot %>%
#   count(Molecular_mechanism) %>%
#   filter(Molecular_mechanism != "") %>%
#   arrange(desc(n))
# 
# nondbd.annot.summary
```

So now domains with unclear mechanisms of action comprise just `(nondbd.annot.summary %>% filter(Molecular_mechanism == "Unclear") %>% pull(n)) / (nondbd.annot.summary %>% pull(n) %>% sum()) * 100`% of all non-DBDs.

Write down the overall stats table:

```{r, include=T}
# write.table(nondbd.annot.summary, 
#             file = "analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filtered_summary.tsv", 
#             quote = F, 
#             sep = "\t", 
#             row.names = F)
```

Summarise protein-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "Protein-binding")) %>%
  count(Molecular_function) %>%
  arrange(desc(n))
```

Summarise RNA-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "RNA-binding")) %>%
  dplyr::select(InterPro_ID, Domain_name)
```

Summarise DBDs:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "DBD")) %>%
  dplyr::select(InterPro_ID, Domain_name)
```

Summarise ligand-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "Ligand-binding")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_function)
```

Summarise catalytic domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "Catalytic")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_function)
```

Summarise protein / nucleic acid-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "Protein / Nucleic acid-binding")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_function)
```

Summarise protein / nucleic acid-binding domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "Lipid-binding")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_function)
```

Summarise structural domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "Structural")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_function)
```

Print out unclear domains:

```{r, include=T}
nondbd.annot %>%
  filter(stringr::str_detect(Molecular_mechanism, "Unclear")) %>%
  dplyr::select(InterPro_ID, Domain_name, Molecular_function)
```

Print out and save all molecular function terms from the protein-binding mechanism:

```{r, include=T}
# pb.mol.functions = nondbd.annot %>%
#   filter(stringr::str_detect(Molecular_mechanism, "Protein-binding")) %>%
#   count(Molecular_function) %>%
#   arrange(desc(n))
# 
# pb.mol.functions
# 
# write.table(pb.mol.functions, 
#             file = "analysis/classify_domains/output/classify_domains/protein_binding_molecular_functions_dbdminus.csv", 
#             quote = F, 
#             sep = "\t", 
#             row.names = F)
```

Check non-DBDs in switching DBD- isoforms:

Load the switch tables:

```{r, include=T}
dom.isof.matrix = read.delim("data/results/dominant_isoform_number_matrix.tsv")
dom.isof.annot = read.delim("data/results/dominant_isoform_ids_and_numbers.tsv")
cluster.annot = read.delim("data/results/cluster_annot_df_final.tsv")
```

1) Check DBD- isoforms of ZNF655:

```{r, include=T}
dom.isof.matrix %>%
  filter(humantfs_gene_name == "ZNF655")

dom.isof.annot %>%
  filter(humantfs_gene_name == "ZNF655")

# ensembl_gene_id, humantfs_gene_name, tf_family, n_dbd, 

tf.matches %>%
  filter(ensembl_transcript_id == "ENST00000320583") %>% # , "ENST00000357864", "ENST00000440391")
  dplyr::select(ensembl_transcript_id, seq_len, ipr_accession, ipr_description, int_start, int_stop) %>%
  distinct() %>%
  arrange(int_start, int_stop) %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "InterPro_ID",
                   "ipr_description" = "Domain_name"))

tf.matches %>%
  filter(ensembl_transcript_id == "ENST00000357864") %>% # , "ENST00000440391")
  dplyr::select(ensembl_transcript_id, seq_len, ipr_accession, ipr_description, int_start, int_stop) %>%
  distinct() %>%
  arrange(int_start, int_stop) %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "InterPro_ID",
                   "ipr_description" = "Domain_name"))

tf.matches %>%
  filter(ensembl_transcript_id == "ENST00000440391") %>%
  dplyr::select(ensembl_transcript_id, seq_len, ipr_accession, ipr_description, int_start, int_stop) %>%
  distinct() %>%
  arrange(int_start, int_stop) %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "InterPro_ID",
                   "ipr_description" = "Domain_name"))
```

2) Check DBD- isoforms of IRF3:

```{r, include=T}
dom.isof.annot %>%
  filter(humantfs_gene_name == "IRF3")

# ensembl_gene_id, humantfs_gene_name, tf_family, n_dbd, 

tf.matches %>%
  filter(ensembl_transcript_id == "ENST00000309877") %>% 
  dplyr::select(ensembl_transcript_id, seq_len, ipr_accession, ipr_description, int_start, int_stop) %>%
  distinct() %>%
  arrange(int_start, int_stop) %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "InterPro_ID",
                   "ipr_description" = "Domain_name"))

tf.matches %>%
  filter(ensembl_transcript_id == "ENST00000599144") %>% 
  dplyr::select(ensembl_transcript_id, seq_len, ipr_accession, ipr_description, int_start, int_stop) %>%
  distinct() %>%
  arrange(int_start, int_stop) %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "InterPro_ID",
                   "ipr_description" = "Domain_name"))
```

## Check the presence of various known domains in some TFs

1) According to [Harms & Chen, 2006](https://www.nature.com/articles/4401904), TP53 should have two activation domains at its N terminus, a DBD, a nuclear localisation signal (NLS), a tetramerisation domain and a basic C-terminal domain.

```{r, include=T}
# Final domain annotation
tf.matches %>% 
  filter(humantfs_gene_name == "TP53") %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, ensembl_transcript_id, DBD, 
                represents_family, ipr_accession, ipr_description, int_start, int_stop, domain_type)

# Raw scan results from InterProScan
ips_domains_ipr_ens99 %>%
  filter(ensembl_gene_id == "ENSG00000141510") %>%
  dplyr::select(ensembl_gene_id, ensembl_transcript_id, ipr_accession, ipr_description) %>%
  distinct()
```

The DBD, the tetramerisation domain, two transactivation domains are present both in the final annotation and in the raw InterProScan results. NLS is absent from both.

## List TFs with conserved DBD- isoforms

```{r, include=T}
conserved.dbdminus.isoforms = c("ENST00000374726","ENST00000489321","ENST00000229387","ENST00000244303","ENST00000256852","ENST00000613414","ENST00000402136","ENST00000421109","ENST00000526600","ENST00000428343","ENST00000320583","ENST00000292538","ENST00000622516")

conserved.dbdminus.tfs = tf.matches %>%
  filter(ensembl_transcript_id %in% conserved.dbdminus.isoforms) %>%
  pull(ensembl_gene_id) %>%
  unique()

cluster.annot %>%
  filter(ensembl_gene_id %in% conserved.dbdminus.tfs)
```

## Separate DBD- isoforms

Separate DBD- isoforms with at least one non-DBD (domain+ isoforms) from DBD- isoforms without any domains (domain- isoforms).
Additionally, from domain+ isoforms exclude those with non-canonical DBDs.
Process only expressed DBD- isoforms.

```{r, include=T}
nodbd.isoforms = dbd_yes_no_tx_table %>% 
  filter(n_canonical == 0) %>%
  pull(ensembl_transcript_id)

nodbd.isoforms.expressed = selected.table.log2.med %>%
  tibble::rownames_to_column("ensembl_transcript_id") %>%
  filter(ensembl_transcript_id %in% nodbd.isoforms) %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., is.expressed = (any(.[, tissue.names] >= 1)))) %>%
  ungroup() %>%
  filter(is.expressed)

domain.minus.isoforms = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(ensembl_transcript_id %in% nodbd.isoforms.expressed$ensembl_transcript_id) %>%
  filter(is.na(ipr_accession))

domain.minus.isoforms.expression = nodbd.isoforms.expressed %>%
  filter(ensembl_transcript_id %in% domain.minus.isoforms$ensembl_transcript_id)

noncan.dbd.isoforms = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(ensembl_transcript_id %in% nodbd.isoforms.expressed$ensembl_transcript_id) %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "ipr_accession",
                   "ipr_description" = "ipr_description")) %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD, represents_family,
                ensembl_transcript_id, ipr_accession, ipr_description, int_start, int_stop,
                Molecular_function) %>%
  distinct() %>%
  filter(stringr::str_detect(Molecular_function, fixed("DBD")))

domain.plus.isoforms = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(ensembl_transcript_id %in% nodbd.isoforms.expressed$ensembl_transcript_id) %>%
  filter(!ensembl_transcript_id %in% domain.minus.isoforms$ensembl_transcript_id) %>%
  filter(!ensembl_transcript_id %in% noncan.dbd.isoforms$ensembl_transcript_id)

domain.plus.isoforms.expression = nodbd.isoforms.expressed %>%
  filter(ensembl_transcript_id %in% domain.plus.isoforms$ensembl_transcript_id)

nodbd.isoforms.perse = domain.plus.isoforms %>%
  bind_rows(domain.minus.isoforms)
```

## Annotate possible DBD- isoform functions

Create a raw table of molecular functions of non-DBDs in DBD- isoforms for further manual filling in:

```{r, include=T}
write.table(nondbd.annot.summary, 
            file = "analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filled_in_dbdminus_raw.tsv", 
            quote = F, 
            sep = "\t", 
            row.names = F)

# protein.binding.dbdminus.filled = read.delim("analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_summary_mol_function_dbdminus_filled.tsv")
# 
# write.table(nondbd.annot.summary %>%
#               left_join(protein.binding.dbdminus.filled %>%
#                           dplyr::select(-n),
#                         by = c("Molecular_function" = "Molecular_function")), 
#             file = "analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filled_in_dbdminus_filled.tsv", 
#             quote = F, 
#             sep = "\t", 
#             row.names = F)
```

Upload necessary tables:

```{r, include=T}
# tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl = read.delim("data/results/domain_analysis/tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl.tsv",
#             header = T)
# 
# selected.table.log2.med = read.delim("data/results/gtex8_processed/tfs_nontfs_selected_table_tpm_log2_med_filtered.tsv",
#                                      header = T,
#                                      sep = "\t",
#                                      stringsAsFactors = F)

# nondbd.iprs.annotation = read.delim("analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filtered.csv")

# nondbd.annot = read.delim("analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filled.csv")

# nondbd.iprs.dbdminus.annotation = read.delim("analysis/classify_domains/output/classify_domains/protein_binding_molecular_functions_dbdminus_filled.csv")

nondbd.iprs.dbdminus.annotation = read.delim("analysis/classify_domains/output/classify_domains/Other_domains_manually_curated_filled_in_dbdminus_filled.tsv")
```

Annotate expressed domain+ C2H2 ZF isoforms in terms of their possible functions:

```{r, include=T, fig.height=5}
domain.plus.isoforms.annotation = domain.plus.isoforms %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "ipr_accession",
                   "ipr_description" = "ipr_description")) %>%
  left_join(nondbd.iprs.dbdminus.annotation,
            by = c("Molecular_function" = "Molecular_function")) %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD, 
                ensembl_transcript_id, ipr_accession, ipr_description, int_start, int_stop,
                Molecular_function, Function_in_DBD_minus) %>%
  distinct() %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., dbdminus_annotation = paste0(unique(sort(unlist(stringr::str_split(.$Function_in_DBD_minus,
                                                                                  fixed("; "))))),
                                            collapse = "; "))) %>%
  ungroup() %>%
  mutate(dbdminus_annotation = ifelse(substring(dbdminus_annotation, 1, 2) == "; ",
                                      substring(dbdminus_annotation, 3),
                                      dbdminus_annotation)) %>%
  mutate(dbdminus_annotation = stringr::str_remove(dbdminus_annotation, "; Unclear")) %>%
  mutate(dbdminus_annotation = stringr::str_remove(dbdminus_annotation, "Unclear; ")) %>%
  mutate(dbdminus_annotation = stringr::str_remove(dbdminus_annotation, "Unclear")) %>%
  mutate(dbdminus_annotation = ifelse(dbdminus_annotation == "",
                                      "Unspecified",
                                      dbdminus_annotation))

domain.plus.isoforms.annotation.summary = data.frame(dbdminus_annotation = unlist(stringr::str_split(domain.plus.isoforms.annotation %>%
                                                                                                       filter(DBD == "C2H2 ZF") %>%
                                                                                                       dplyr::select(ensembl_transcript_id,
                                                                                                                     dbdminus_annotation) %>%
                                                                                                       distinct() %>%
                                                                                                       pull(dbdminus_annotation),
                                                                                                     fixed("; ")))) %>%
  count(dbdminus_annotation)

domain.plus.isoforms.number = domain.plus.isoforms %>%
  filter(DBD == "C2H2 ZF") %>%
  pull(ensembl_transcript_id) %>%
  unique() %>%
  length()

domain.plus.isoforms.annotation.summary %>%
  mutate(frequency = n / domain.plus.isoforms.number) %>%
  arrange(desc(n)) %>%
  head(10) %>%
  mutate(dbdminus_annotation = factor(dbdminus_annotation, levels = dbdminus_annotation)) %>%
  ggplot(aes(x = dbdminus_annotation, y = frequency)) +
    geom_col(fill = "orange") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

As expected according to the highest frequency of the KRAB transcription repression domain, the most frequent function of C2H2 ZF domain+ isoforms is corepressor sequestration.

Check function frequencies for non-C2H2 ZF domain+ isoforms:

```{r, include=T}
domain.plus.isoforms.annotation.summary = data.frame(dbdminus_annotation = unlist(stringr::str_split(domain.plus.isoforms.annotation %>%
                                                                                                       filter(DBD != "C2H2 ZF") %>%
                                                                                                       dplyr::select(ensembl_transcript_id,
                                                                                                                     dbdminus_annotation) %>%
                                                                                                       distinct() %>%
                                                                                                       pull(dbdminus_annotation),
                                                                                                     fixed("; ")))) %>%
  count(dbdminus_annotation)

domain.plus.isoforms.number = domain.plus.isoforms %>%
  filter(DBD != "C2H2 ZF") %>%
  pull(ensembl_transcript_id) %>%
  unique() %>%
  length()

domain.plus.isoforms.annotation.summary %>%
  mutate(frequency = n / domain.plus.isoforms.number) %>%
  arrange(desc(n)) %>%
  head(10) %>%
  mutate(dbdminus_annotation = factor(dbdminus_annotation, levels = dbdminus_annotation)) %>%
  ggplot(aes(x = dbdminus_annotation, y = frequency)) +
    geom_col(fill = "orange") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Now the most frequent function is "Self-sequestration". Check in which TF families it happens:

```{r, include=T}
domain.plus.isoforms.annotation.summary.dbd = data.frame(DBD = domain.plus.isoforms.annotation %>%
                                                                 filter(DBD != "C2H2 ZF") %>%
                                                                 filter(stringr::str_detect(dbdminus_annotation, fixed("Self-sequestration")))  %>%
                                                                 dplyr::select(DBD, ensembl_transcript_id) %>%
                                                                 distinct() %>%
                                                                 pull(DBD)) %>%
  count(DBD)

domain.plus.isoforms.annotation.summary.dbd %>%
  arrange(desc(n))
```

```{r, include=T}
domain.plus.isoforms.annotation.summary.dbd = data.frame(DBD = domain.plus.isoforms.annotation %>%
                                                                 filter(DBD != "C2H2 ZF") %>%
                                                                 filter(stringr::str_detect(dbdminus_annotation, fixed("Partner TF sequestration")))  %>%
                                                                 dplyr::select(DBD, ensembl_transcript_id) %>%
                                                                 distinct() %>%
                                                                 pull(DBD)) %>%
  count(DBD)

domain.plus.isoforms.annotation.summary.dbd %>%
  arrange(desc(n))
```

Summarise TFs that sequester themselves or their partner TFs with DBD- isoforms:

```{r, include=T}
dimer.tfs.summary = domain.plus.isoforms.annotation %>%
  filter(DBD != "C2H2 ZF") %>%
  filter(stringr::str_detect(Function_in_DBD_minus, fixed("Self-sequestration")) | 
           stringr::str_detect(Function_in_DBD_minus, fixed("Partner TF sequestration")))  %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD) %>%
  distinct() %>%
  arrange(DBD)

dimer.tfs.summary
```

It seems that too few TFs use their DBD- isoforms for self- or partner TF sequestration. Hence, let's check how many TFs from dimerising families listed above have annotated dimerization domains in their expressed isoforms. Such TFs could produce DBD- isoforms for sequestration, and we know the number of TFs in each of these families that actually do this.

```{r, include=T}
tf.families = dimer.tfs.summary %>%
  pull(DBD) %>%
  unique()

base.sequestr.table = tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  left_join(nondbd.annot,
            by = c("ipr_accession" = "ipr_accession",
                   "ipr_description" = "ipr_description")) %>%
  left_join(nondbd.iprs.dbdminus.annotation,
            by = c("Molecular_function" = "Molecular_function")) %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD, 
                ensembl_transcript_id, ipr_accession, ipr_description, int_start, int_stop,
                Molecular_function, Function_in_DBD_minus) %>%
  distinct() %>%
  filter(DBD %in% tf.families) %>%
  arrange(DBD)

dimer.annotated.table = base.sequestr.table %>%
  filter(stringr::str_detect(Function_in_DBD_minus, fixed("Self-sequestration")) | 
           stringr::str_detect(Function_in_DBD_minus, fixed("Partner TF sequestration")))

all.isoforms.expressed = selected.table.log2.med %>%
  tibble::rownames_to_column("ensembl_transcript_id") %>%
  group_by(ensembl_transcript_id) %>%
  do(mutate(., is.expressed = (any(.[, tissue.names] >= 1)))) %>%
  ungroup() %>%
  filter(is.expressed)

expr.dimer.table = dimer.annotated.table %>%
  filter(ensembl_transcript_id %in% all.isoforms.expressed$ensembl_transcript_id)

with.nodbd.expr.dimer.table = expr.dimer.table %>%
  filter(ensembl_transcript_id %in% nodbd.isoforms.expressed$ensembl_transcript_id)

data.frame(tf.families = tf.families,
           all.tfs = base.sequestr.table %>%
             dplyr::select(ensembl_gene_id, DBD) %>%
             distinct() %>% 
             count(DBD) %>%
             pull(n),
           dimer.annot = dimer.annotated.table %>%
             dplyr::select(ensembl_gene_id, DBD) %>%
             distinct() %>% 
             count(DBD) %>%
             pull(n),
           expr.dimer.annot = expr.dimer.table %>%
             dplyr::select(ensembl_gene_id, DBD) %>%
             distinct() %>% 
             count(DBD) %>%
             pull(n),
           with.nodbd.expr.dimer.annot = with.nodbd.expr.dimer.table %>%
             dplyr::select(ensembl_gene_id, DBD) %>%
             distinct() %>% 
             count(DBD) %>%
             pull(n)) %>%
  arrange(desc(all.tfs))
```

Dimerisation domains in each family:

```{r, include=T}
dimer.annotated.table %>%
  dplyr::select(DBD, humantfs_gene_name, ipr_accession, ipr_description, Function_in_DBD_minus) %>%
  distinct() %>%
  arrange(DBD, humantfs_gene_name) #%>%
  # filter(stringr::str_detect(Function_in_DBD_minus, fixed("Self-sequestration")) |
  #        stringr::str_detect(Function_in_DBD_minus, fixed("Partner TF sequestration")))
```

```{r, include=T}
tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  #filter(DBD %in% tf.families) %>%
  dplyr::select(DBD, humantfs_gene_name, ipr_accession, ipr_description) %>%
  distinct() %>%
  arrange(DBD, humantfs_gene_name, ipr_accession) %>%
  filter(!is.na(ipr_accession)) %>%
  filter(DBD == "T-box")
  #filter(humantfs_gene_name == "NFIX")
```

1) TF families where the characteristic dimerization domain is not annotated:

a) bHLH: We count IPR011598 (Myc-type, basic helix-loop-helix (bHLH) domain) as basic+HLH, so no DBD- isoforms can have a separate HLH domain in our annotation. Instead of the HLH domain, we have other dimerisation domains annotated in some TFs of this family: Orange domain (IPR003650), NCOA-type interlocking domain (IPR014920) and even, in one TF, an LZ domain (IPR003327). However, out of 15 bHLH TFs with these non-HLH dimerisation domains, only one TF expressed a dimerising DBD- isoform.

b) bZIP: We count IPR004827 (Basic-leucine zipper domain) as basic+LZ, so no DBD- isoforms can have a separate LZ domain in our annotation. Only two bZIP factors are expressed in our dataset.

2) Unclear families:

a) GATA: Not sure if all GATA TFs dimerise and which domains they use for dimerisation; these domains also could be a part of a DBD.

b) Homeodomain factors can use different parts of the protein for dimerisation, including the homeodomain itself. So it is hard to say how many TFs from the homeodomain family should have separately annotated dimerisation domains (and which). Also, those homeodmain TFs that dimerise using the DBD, by definition would not have any dimerising DBD- isoforms. However, from the 33 homeodomain TFs that do have some dimerisation domains and are expressed, only one produces a DBD- isoform with a dimerisation domain.

c) Myb/SANT: dimerisation can occur through the DBD.

d) SAND: 3 out of 7 SAND TFs are expressed in adult human tissues and do have a dimerisation domain, although it is not clear if it is the main, characteristic, dimerisation domain for these proteins. Anyway, out of these 3 TF, only 1 expresses a DBD- isoform with a dimerisation domain.

e) HSF: Unclear what the dimerisation domain there is, and if all HSFs should dimerise.

f) Ndt80/PhoG - Too few TFs there are, not interesting.

g) "HMG/Sox; SAND" - Too few TFs there are, not interesting.

3) TF families where the characteristic dimerization domain is annotated:

a) IRF (IPR019471: Interferon regulatory factor-3): Only 2 IRF TFs out of 7 with the dimerisation domain have a DBD- isoform with that domain.

b) STAT (IPR013799: STAT transcription factor, protein interaction): Only 1 STAT TF out of 7 with the dimerisation domain have a DBD- isoform with that domain.

c) SMAD (IPR001132: SMAD domain, Dwarfin-type; IPR019548: CTF transcription factor/nuclear factor 1, N-terminal; the second one is annotated in the NF-I subfamily): Only 2 SMAD TFs out of 9 with the dimerisation domain have a DBD- isoform with that domain.

We do not describe HSF, 

Although we lose the majority of TFs in about half of the families due to dimerisation domains not being annotated separately, we still observe that in all the families those TFs that are annotated with dimerisation domains almost do not use DBD- isoforms for sequestration. For example, among 33 Homeodomain TFs that are expressed in adult human tissues and have a dimerisation domain annotated, only one expresses a DBD- isoform with such a domain. On the other hand, we need to check if the classical HLH, leucine zipper and other dimerisation domains characteristic of particular families could be annotated, as TFs may not use some non-canonical dimerisation domains in their DBD- isoforms but instead retain the canonical ones that are not currently annotated.

To-do:
+1) Count "DBD-" isoforms with "DBD" or "?DBD". Ideally, exclude these isoforms from the set of DBD- and re-calculate the plots above.
1a) Make first slides for the 5' update.
2) Calculate buffered max expression of domain+ and domain- DBD- isoforms. 
3) Integrate IDRs into domain- isoforms (if there are any IDRs).
4) Check if the buffered max expression of domain- IDR+ isoforms positively correlates with the fraction of the IDRs in the whole isoform length (positive correlation would suggest functional importance of IDRs).
5) Check how the expression of domain- isoforms correlates with their length (if it's a negative correlation, then domain- isoforms are just noise, because if the expression level of a particular isoform doesn't matter then the longer isoforms will have lower level due to PolII randomly slipping from the template). Check this separately for IDR+ and IDR- isoforms as IDR+ isoforms may be longer than IDR- ones (we can check this).

---

The number of expressed DBD- isoforms without any domains (doman- isoforms):

```{r, include=T}
nodbd.isoforms.annotation %>%
  filter(is.na(ipr_accession)) %>%
  pull(ensembl_transcript_id) %>%
  unique() %>%
  length()
```

So, there are only 35 DBD- isoforms whose non-DNA binding domains are only non-protein binding.

```{r}
tf_coding_transcripts_final_ens99_with_fam_names_corrected.with_tsl %>%
  filter(ipr_accession == "IPR001810") %>%
  dplyr::select(ensembl_gene_id, humantfs_gene_name, DBD)
```

---

Plan:

- violin plots showing how the number of DBDs varies in sets of multiple DBDs (TFs vs. the number of DBDs in each isoform);

- variation of DBD types due to alternative splicing;

- group isoforms with the same types and numbers of DBDs, align their DBD sequences and see if they can be different;

- add other domains (classify them into big functional categories first) and relate their presence or absence to the presence or absence of DBDs;

- transcriptomics part (and finish up the DBD+/- part).
